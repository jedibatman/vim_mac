!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A01	or/routerparse.c	/^#define A01(/;"	d	file:
A2M	common/mempool.c	/^#define A2M(/;"	d	file:
ADDR	common/tortls.c	/^#define ADDR(/;"	d	file:
ADDRMAPSRC_AUTOMAP	or/or.h	/^  ADDRMAPSRC_AUTOMAP,$/;"	e	enum:__anon55
ADDRMAPSRC_CONTROLLER	or/or.h	/^  ADDRMAPSRC_CONTROLLER,$/;"	e	enum:__anon55
ADDRMAPSRC_DNS	or/or.h	/^  ADDRMAPSRC_DNS,$/;"	e	enum:__anon55
ADDRMAPSRC_TORRC	or/or.h	/^  ADDRMAPSRC_TORRC,$/;"	e	enum:__anon55
ADDRMAPSRC_TRACKEXIT	or/or.h	/^  ADDRMAPSRC_TRACKEXIT,$/;"	e	enum:__anon55
ADDR_LEGACY	test/test_addr.c	/^#define ADDR_LEGACY(/;"	d	file:
ADDR_POLICY_ACCEPT	or/or.h	/^  ADDR_POLICY_ACCEPT=1,$/;"	e	enum:__anon38
ADDR_POLICY_ACCEPTED	or/or.h	/^  ADDR_POLICY_ACCEPTED=0,$/;"	e	enum:__anon64
ADDR_POLICY_PROBABLY_ACCEPTED	or/or.h	/^  ADDR_POLICY_PROBABLY_ACCEPTED=1,$/;"	e	enum:__anon64
ADDR_POLICY_PROBABLY_REJECTED	or/or.h	/^  ADDR_POLICY_PROBABLY_REJECTED=2,$/;"	e	enum:__anon64
ADDR_POLICY_REJECT	or/or.h	/^  ADDR_POLICY_REJECT=2,$/;"	e	enum:__anon38
ADDR_POLICY_REJECTED	or/or.h	/^  ADDR_POLICY_REJECTED=-1,$/;"	e	enum:__anon64
ADD_DATA	test/test.c	/^#define ADD_DATA(/;"	d	file:
ADD_ENTROPY	common/crypto.c	/^#define ADD_ENTROPY /;"	d	file:
ADD_MALLINFO_LINE	or/directory.c	/^#define ADD_MALLINFO_LINE(/;"	d	file:
ALIGNMENT	common/mempool.c	/^#define ALIGNMENT /;"	d	file:
ALIGNMENT_TYPE	common/mempool.c	/^#define ALIGNMENT_TYPE /;"	d	file:
ALLOC	common/mempool.c	/^#define ALLOC(/;"	d	file:
ALLOC	or/routerparse.c	/^#define ALLOC(/;"	d	file:
ALLOC	or/routerparse.c	/^#undef ALLOC$/;"	d	file:
ALLOC_CAN_RETURN_NULL	common/mempool.c	/^#define ALLOC_CAN_RETURN_NULL$/;"	d	file:
ALLOC_CAN_RETURN_NULL	common/mempool.c	/^#undef ALLOC_CAN_RETURN_NULL$/;"	d	file:
ALLOC_ZERO	or/routerparse.c	/^#define ALLOC_ZERO(/;"	d	file:
ALLOC_ZERO	or/routerparse.c	/^#undef ALLOC_ZERO$/;"	d	file:
ALLOW_DIRECTORY_TIME_SKEW	or/directory.c	/^#define ALLOW_DIRECTORY_TIME_SKEW /;"	d	file:
ALLOW_INVALID_ENTRY	or/or.h	/^  ALLOW_INVALID_ENTRY       =1,$/;"	e	enum:invalid_router_usage_t
ALLOW_INVALID_EXIT	or/or.h	/^  ALLOW_INVALID_EXIT        =2,$/;"	e	enum:invalid_router_usage_t
ALLOW_INVALID_INTRODUCTION	or/or.h	/^  ALLOW_INVALID_INTRODUCTION=16,$/;"	e	enum:invalid_router_usage_t
ALLOW_INVALID_MIDDLE	or/or.h	/^  ALLOW_INVALID_MIDDLE      =4,$/;"	e	enum:invalid_router_usage_t
ALLOW_INVALID_RENDEZVOUS	or/or.h	/^  ALLOW_INVALID_RENDEZVOUS  =8,$/;"	e	enum:invalid_router_usage_t
ALL_FORMATS	or/control.c	/^#define ALL_FORMATS /;"	d	file:
APPDATA_PATH	or/config.c	/^#define APPDATA_PATH /;"	d	file:
APPEND16	or/eventdns.c	/^#define APPEND16(/;"	d	file:
APPEND16	or/eventdns.c	/^#undef APPEND16$/;"	d	file:
APPEND32	or/eventdns.c	/^#define APPEND32(/;"	d	file:
APPEND32	or/eventdns.c	/^#undef APPEND32$/;"	d	file:
AP_CONN_STATE_CIRCUIT_WAIT	or/or.h	/^#define AP_CONN_STATE_CIRCUIT_WAIT /;"	d
AP_CONN_STATE_CONNECT_WAIT	or/or.h	/^#define AP_CONN_STATE_CONNECT_WAIT /;"	d
AP_CONN_STATE_CONTROLLER_WAIT	or/or.h	/^#define AP_CONN_STATE_CONTROLLER_WAIT /;"	d
AP_CONN_STATE_IS_UNATTACHED	or/or.h	/^#define AP_CONN_STATE_IS_UNATTACHED(/;"	d
AP_CONN_STATE_NATD_WAIT	or/or.h	/^#define AP_CONN_STATE_NATD_WAIT /;"	d
AP_CONN_STATE_OPEN	or/or.h	/^#define AP_CONN_STATE_OPEN /;"	d
AP_CONN_STATE_RENDDESC_WAIT	or/or.h	/^#define AP_CONN_STATE_RENDDESC_WAIT /;"	d
AP_CONN_STATE_RESOLVE_WAIT	or/or.h	/^#define AP_CONN_STATE_RESOLVE_WAIT /;"	d
AP_CONN_STATE_SOCKS_WAIT	or/or.h	/^#define AP_CONN_STATE_SOCKS_WAIT /;"	d
ARGS	or/routerparse.c	/^#define ARGS /;"	d	file:
ASSERT	common/mempool.c	/^#define ASSERT(/;"	d	file:
AT	or/policies.c	/^#define AT(/;"	d	file:
ATTR_CONST	common/compat.h	/^#define ATTR_CONST /;"	d
ATTR_CONST	common/compat.h	/^#define ATTR_CONST$/;"	d
ATTR_MALLOC	common/compat.h	/^#define ATTR_MALLOC /;"	d
ATTR_MALLOC	common/compat.h	/^#define ATTR_MALLOC$/;"	d
ATTR_NONNULL	common/compat.h	/^#define ATTR_NONNULL(/;"	d
ATTR_NORETURN	common/compat.h	/^#define ATTR_NORETURN /;"	d
ATTR_NORETURN	common/compat.h	/^#define ATTR_NORETURN$/;"	d
AT_END	or/routerparse.c	/^#define AT_END /;"	d	file:
AT_START	or/routerparse.c	/^#define AT_START /;"	d	file:
AUTHENTICATION_COOKIE_LEN	or/control.c	/^#define AUTHENTICATION_COOKIE_LEN /;"	d	file:
AUTHORITY_CERT_1	test/test_data.c	/^const char AUTHORITY_CERT_1[] =$/;"	v
AUTHORITY_CERT_2	test/test_data.c	/^const char AUTHORITY_CERT_2[] =$/;"	v
AUTHORITY_CERT_3	test/test_data.c	/^const char AUTHORITY_CERT_3[] =$/;"	v
AUTHORITY_NS_CACHE_INTERVAL	or/networkstatus.c	/^#define AUTHORITY_NS_CACHE_INTERVAL /;"	d	file:
AUTHORITY_SIGNKEY_1	test/test_data.c	/^const char AUTHORITY_SIGNKEY_1[] =$/;"	v
AUTHORITY_SIGNKEY_2	test/test_data.c	/^const char AUTHORITY_SIGNKEY_2[] =$/;"	v
AUTHORITY_SIGNKEY_3	test/test_data.c	/^const char AUTHORITY_SIGNKEY_3[] =$/;"	v
AUTHTYPE_RSA_SHA256_TLSSECRET	or/or.h	/^#define AUTHTYPE_RSA_SHA256_TLSSECRET /;"	d
A_LAST_LISTED	or/routerparse.c	/^  A_LAST_LISTED,$/;"	e	enum:__anon69	file:
A_PURPOSE	or/routerparse.c	/^  A_PURPOSE,$/;"	e	enum:__anon69	file:
AccelDir	or/or.h	/^  char *AccelDir; \/**< Optional hardware acceleration engine search dir. *\/$/;"	m	struct:__anon49
AccelName	or/or.h	/^  char *AccelName; \/**< Optional hardware acceleration engine name. *\/$/;"	m	struct:__anon49
AccountingBytesAtSoftLimit	or/or.h	/^  uint64_t AccountingBytesAtSoftLimit;$/;"	m	struct:__anon52
AccountingBytesReadInInterval	or/or.h	/^  uint64_t AccountingBytesReadInInterval;$/;"	m	struct:__anon52
AccountingBytesWrittenInInterval	or/or.h	/^  uint64_t AccountingBytesWrittenInInterval;$/;"	m	struct:__anon52
AccountingExpectedUsage	or/or.h	/^  uint64_t AccountingExpectedUsage;$/;"	m	struct:__anon52
AccountingIntervalStart	or/or.h	/^  time_t AccountingIntervalStart;$/;"	m	struct:__anon52
AccountingMax	or/or.h	/^  uint64_t AccountingMax; \/**< How many bytes do we allow per accounting$/;"	m	struct:__anon49
AccountingSecondsActive	or/or.h	/^  int AccountingSecondsActive;$/;"	m	struct:__anon52
AccountingSecondsToReachSoftLimit	or/or.h	/^  int AccountingSecondsToReachSoftLimit;$/;"	m	struct:__anon52
AccountingSoftLimitHitAt	or/or.h	/^  time_t AccountingSoftLimitHitAt;$/;"	m	struct:__anon52
AccountingStart	or/or.h	/^  char *AccountingStart; \/**< How long is the accounting interval, and when$/;"	m	struct:__anon49
Address	or/or.h	/^  char *Address; \/**< OR only: configured address for this onion router. *\/$/;"	m	struct:__anon49
AddressMap	or/or.h	/^  config_line_t *AddressMap; \/**< List of address map directives. *\/$/;"	m	struct:__anon49
AllDirActionsPrivate	or/or.h	/^  int AllDirActionsPrivate; \/**< Should every directory action be sent$/;"	m	struct:__anon49
AllowDotExit	or/or.h	/^  int AllowDotExit;$/;"	m	struct:__anon49
AllowInvalidNodes	or/or.h	/^  smartlist_t *AllowInvalidNodes;$/;"	m	struct:__anon49
AllowNonRFC953Hostnames	or/or.h	/^  int AllowNonRFC953Hostnames; \/**< If true, we allow connections to hostnames$/;"	m	struct:__anon49
AllowSingleHopCircuits	or/or.h	/^  int AllowSingleHopCircuits;$/;"	m	struct:__anon49
AllowSingleHopExits	or/or.h	/^  int AllowSingleHopExits;$/;"	m	struct:__anon49
AlternateBridgeAuthority	or/or.h	/^  config_line_t *AlternateBridgeAuthority;$/;"	m	struct:__anon49
AlternateDirAuthority	or/or.h	/^  config_line_t *AlternateDirAuthority;$/;"	m	struct:__anon49
AlternateHSAuthority	or/or.h	/^  config_line_t *AlternateHSAuthority;$/;"	m	struct:__anon49
AssumeReachable	or/or.h	/^  int AssumeReachable; \/**< Whether to publish our descriptor regardless. *\/$/;"	m	struct:__anon49
AuthDirBadDir	or/or.h	/^  config_line_t *AuthDirBadDir; \/**< Address policy for descriptors to$/;"	m	struct:__anon49
AuthDirBadDirCCs	or/or.h	/^  smartlist_t *AuthDirBadDirCCs;$/;"	m	struct:__anon49
AuthDirBadExit	or/or.h	/^  config_line_t *AuthDirBadExit; \/**< Address policy for descriptors to$/;"	m	struct:__anon49
AuthDirBadExitCCs	or/or.h	/^  smartlist_t *AuthDirBadExitCCs;$/;"	m	struct:__anon49
AuthDirFastGuarantee	or/or.h	/^  uint64_t AuthDirFastGuarantee;$/;"	m	struct:__anon49
AuthDirGuardBWGuarantee	or/or.h	/^  uint64_t AuthDirGuardBWGuarantee;$/;"	m	struct:__anon49
AuthDirInvalid	or/or.h	/^  config_line_t *AuthDirInvalid; \/**< Address policy for descriptors to$/;"	m	struct:__anon49
AuthDirInvalidCCs	or/or.h	/^  smartlist_t *AuthDirInvalidCCs;$/;"	m	struct:__anon49
AuthDirListBadDirs	or/or.h	/^  int AuthDirListBadDirs; \/**< True iff we should list bad dirs,$/;"	m	struct:__anon49
AuthDirListBadExits	or/or.h	/^  int AuthDirListBadExits; \/**< True iff we should list bad exits,$/;"	m	struct:__anon49
AuthDirMaxServersPerAddr	or/or.h	/^  int AuthDirMaxServersPerAddr; \/**< Do not permit more than this$/;"	m	struct:__anon49
AuthDirMaxServersPerAuthAddr	or/or.h	/^  int AuthDirMaxServersPerAuthAddr; \/**< Do not permit more than this$/;"	m	struct:__anon49
AuthDirReject	or/or.h	/^  config_line_t *AuthDirReject; \/**< Address policy for descriptors to$/;"	m	struct:__anon49
AuthDirRejectCCs	or/or.h	/^  smartlist_t *AuthDirRejectCCs;$/;"	m	struct:__anon49
AuthDirRejectUnlisted	or/or.h	/^  int AuthDirRejectUnlisted; \/**< Boolean: do we reject all routers that$/;"	m	struct:__anon49
AuthoritativeDir	or/or.h	/^  int AuthoritativeDir; \/**< Boolean: is this an authoritative directory? *\/$/;"	m	struct:__anon49
AutomapHostsOnResolve	or/or.h	/^  int AutomapHostsOnResolve; \/**< If true, when we get a resolve request for a$/;"	m	struct:__anon49
AutomapHostsSuffixes	or/or.h	/^  smartlist_t *AutomapHostsSuffixes; \/**< List of suffixes for$/;"	m	struct:__anon49
AvoidDiskWrites	or/or.h	/^  int AvoidDiskWrites; \/**< Boolean: should we never cache things to disk?$/;"	m	struct:__anon49
B64_1	test/test_dir.c	/^#define B64_1 /;"	d	file:
B64_2	test/test_dir.c	/^#define B64_2 /;"	d	file:
B64_256_1	test/test_dir.c	/^#define B64_256_1 /;"	d	file:
B64_256_2	test/test_dir.c	/^#define B64_256_2 /;"	d	file:
B64_256_3	test/test_dir.c	/^#define B64_256_3 /;"	d	file:
B64_3	test/test_dir.c	/^#define B64_3 /;"	d	file:
BAD_HOSTNAME	or/connection_edge.h	/^  NORMAL_HOSTNAME, ONION_HOSTNAME, EXIT_HOSTNAME, BAD_HOSTNAME$/;"	e	enum:hostname_type_t
BANDWIDTH_RECHECK_INTERVAL	or/main.c	/^#define BANDWIDTH_RECHECK_INTERVAL /;"	d	file:
BASE32_CHARS	common/crypto.h	/^#define BASE32_CHARS /;"	d
BASE64_DIGEST256_LEN	common/crypto.h	/^#define BASE64_DIGEST256_LEN /;"	d
BASE64_DIGEST_LEN	common/crypto.h	/^#define BASE64_DIGEST_LEN /;"	d
BASE_CONNECTION_MAGIC	or/or.h	/^#define BASE_CONNECTION_MAGIC /;"	d
BIDI_FACTOR	or/rephist.c	/^#define BIDI_FACTOR /;"	d	file:
BIDI_INTERVAL	or/rephist.c	/^#define BIDI_INTERVAL /;"	d	file:
BIDI_THRESHOLD	or/rephist.c	/^#define BIDI_THRESHOLD /;"	d	file:
BIT	common/container.h	/^#define BIT(/;"	d
BIT	common/container.h	/^#undef BIT$/;"	d
BITARRAY_MASK	common/container.h	/^#define BITARRAY_MASK /;"	d
BITARRAY_SHIFT	common/container.h	/^#define BITARRAY_SHIFT /;"	d
BOOTSTRAP_MSG_LEN	or/control.c	/^#define BOOTSTRAP_MSG_LEN /;"	d	file:
BOOTSTRAP_PROBLEM_THRESHOLD	or/control.c	/^#define BOOTSTRAP_PROBLEM_THRESHOLD /;"	d	file:
BOOTSTRAP_STATUS_CIRCUIT_CREATE	or/or.h	/^  BOOTSTRAP_STATUS_CIRCUIT_CREATE=90,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_CONN_DIR	or/or.h	/^  BOOTSTRAP_STATUS_CONN_DIR=5,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_CONN_OR	or/or.h	/^  BOOTSTRAP_STATUS_CONN_OR=80,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_DONE	or/or.h	/^  BOOTSTRAP_STATUS_DONE=100$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_HANDSHAKE	or/or.h	/^  BOOTSTRAP_STATUS_HANDSHAKE=-2,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_HANDSHAKE_DIR	or/or.h	/^  BOOTSTRAP_STATUS_HANDSHAKE_DIR=10,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_HANDSHAKE_OR	or/or.h	/^  BOOTSTRAP_STATUS_HANDSHAKE_OR=85,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_LOADING_DESCRIPTORS	or/or.h	/^  BOOTSTRAP_STATUS_LOADING_DESCRIPTORS=50,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_LOADING_KEYS	or/or.h	/^  BOOTSTRAP_STATUS_LOADING_KEYS=40,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_LOADING_STATUS	or/or.h	/^  BOOTSTRAP_STATUS_LOADING_STATUS=25,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_ONEHOP_CREATE	or/or.h	/^  BOOTSTRAP_STATUS_ONEHOP_CREATE=15,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_REQUESTING_DESCRIPTORS	or/or.h	/^  BOOTSTRAP_STATUS_REQUESTING_DESCRIPTORS=45,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_REQUESTING_STATUS	or/or.h	/^  BOOTSTRAP_STATUS_REQUESTING_STATUS=20,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_STARTING	or/or.h	/^  BOOTSTRAP_STATUS_STARTING=0,$/;"	e	enum:__anon56
BOOTSTRAP_STATUS_UNDEF	or/or.h	/^  BOOTSTRAP_STATUS_UNDEF=-1,$/;"	e	enum:__anon56
BRIDGE_DIRINFO	or/or.h	/^  BRIDGE_DIRINFO  = 1 << 4,$/;"	e	enum:__anon45
BRIDGE_MAX_BELIEVABLE_BANDWIDTH	or/routerlist.c	/^#define BRIDGE_MAX_BELIEVABLE_BANDWIDTH /;"	d	file:
BRIDGE_MIN_BELIEVABLE_BANDWIDTH	or/routerlist.c	/^#define BRIDGE_MIN_BELIEVABLE_BANDWIDTH /;"	d	file:
BRIDGE_STATUSFILE_INTERVAL	or/main.c	/^#define BRIDGE_STATUSFILE_INTERVAL /;"	d	file:
BUFFERS_PRIVATE	or/buffers.c	/^#define BUFFERS_PRIVATE$/;"	d	file:
BUFFERS_PRIVATE	test/test.c	/^#define BUFFERS_PRIVATE$/;"	d	file:
BUFFER_MAGIC	or/buffers.c	/^#define BUFFER_MAGIC /;"	d	file:
BUILDTIMEOUT_SET_EVENT_COMPUTED	or/or.h	/^  BUILDTIMEOUT_SET_EVENT_COMPUTED  = 0,$/;"	e	enum:buildtimeout_set_event_t
BUILDTIMEOUT_SET_EVENT_DISCARD	or/or.h	/^  BUILDTIMEOUT_SET_EVENT_DISCARD = 3,$/;"	e	enum:buildtimeout_set_event_t
BUILDTIMEOUT_SET_EVENT_RESET	or/or.h	/^  BUILDTIMEOUT_SET_EVENT_RESET     = 1,$/;"	e	enum:buildtimeout_set_event_t
BUILDTIMEOUT_SET_EVENT_RESUME	or/or.h	/^  BUILDTIMEOUT_SET_EVENT_RESUME = 4$/;"	e	enum:buildtimeout_set_event_t
BUILDTIMEOUT_SET_EVENT_SUSPENDED	or/or.h	/^  BUILDTIMEOUT_SET_EVENT_SUSPENDED = 2,$/;"	e	enum:buildtimeout_set_event_t
BWHistoryDirReadEnds	or/or.h	/^  time_t      BWHistoryDirReadEnds;$/;"	m	struct:__anon52
BWHistoryDirReadInterval	or/or.h	/^  int         BWHistoryDirReadInterval;$/;"	m	struct:__anon52
BWHistoryDirReadMaxima	or/or.h	/^  smartlist_t *BWHistoryDirReadMaxima;$/;"	m	struct:__anon52
BWHistoryDirReadValues	or/or.h	/^  smartlist_t *BWHistoryDirReadValues;$/;"	m	struct:__anon52
BWHistoryDirWriteEnds	or/or.h	/^  time_t      BWHistoryDirWriteEnds;$/;"	m	struct:__anon52
BWHistoryDirWriteInterval	or/or.h	/^  int         BWHistoryDirWriteInterval;$/;"	m	struct:__anon52
BWHistoryDirWriteMaxima	or/or.h	/^  smartlist_t *BWHistoryDirWriteMaxima;$/;"	m	struct:__anon52
BWHistoryDirWriteValues	or/or.h	/^  smartlist_t *BWHistoryDirWriteValues;$/;"	m	struct:__anon52
BWHistoryReadEnds	or/or.h	/^  time_t      BWHistoryReadEnds;$/;"	m	struct:__anon52
BWHistoryReadInterval	or/or.h	/^  int         BWHistoryReadInterval;$/;"	m	struct:__anon52
BWHistoryReadMaxima	or/or.h	/^  smartlist_t *BWHistoryReadMaxima;$/;"	m	struct:__anon52
BWHistoryReadValues	or/or.h	/^  smartlist_t *BWHistoryReadValues;$/;"	m	struct:__anon52
BWHistoryWriteEnds	or/or.h	/^  time_t      BWHistoryWriteEnds;$/;"	m	struct:__anon52
BWHistoryWriteInterval	or/or.h	/^  int         BWHistoryWriteInterval;$/;"	m	struct:__anon52
BWHistoryWriteMaxima	or/or.h	/^  smartlist_t *BWHistoryWriteMaxima;$/;"	m	struct:__anon52
BWHistoryWriteValues	or/or.h	/^  smartlist_t *BWHistoryWriteValues;$/;"	m	struct:__anon52
BW_MAX_WEIGHT_SCALE	or/or.h	/^#define BW_MAX_WEIGHT_SCALE /;"	d
BW_MIN_WEIGHT_SCALE	or/or.h	/^#define BW_MIN_WEIGHT_SCALE /;"	d
BW_WEIGHTS_BALANCE_EG_ERROR	or/dirvote.c	/^ BW_WEIGHTS_BALANCE_EG_ERROR = 6$/;"	e	enum:__anon24	file:
BW_WEIGHTS_BALANCE_MID_ERROR	or/dirvote.c	/^ BW_WEIGHTS_BALANCE_MID_ERROR = 5,$/;"	e	enum:__anon24	file:
BW_WEIGHTS_NO_ERROR	or/dirvote.c	/^ BW_WEIGHTS_NO_ERROR = 0,$/;"	e	enum:__anon24	file:
BW_WEIGHTS_RANGE_ERROR	or/dirvote.c	/^ BW_WEIGHTS_RANGE_ERROR = 1,$/;"	e	enum:__anon24	file:
BW_WEIGHTS_SUMD_ERROR	or/dirvote.c	/^ BW_WEIGHTS_SUMD_ERROR = 4,$/;"	e	enum:__anon24	file:
BW_WEIGHTS_SUME_ERROR	or/dirvote.c	/^ BW_WEIGHTS_SUME_ERROR = 3,$/;"	e	enum:__anon24	file:
BW_WEIGHTS_SUMG_ERROR	or/dirvote.c	/^ BW_WEIGHTS_SUMG_ERROR = 2,$/;"	e	enum:__anon24	file:
BW_WEIGHT_SCALE	or/or.h	/^#define BW_WEIGHT_SCALE /;"	d
BandwidthBurst	or/or.h	/^  uint64_t BandwidthBurst; \/**< How much bandwidth, at maximum, are we willing$/;"	m	struct:__anon49
BandwidthRate	or/or.h	/^  uint64_t BandwidthRate; \/**< How much bandwidth, on average, are we willing$/;"	m	struct:__anon49
BridgeAuthoritativeDir	or/or.h	/^  int BridgeAuthoritativeDir; \/**< Boolean: is this an authoritative directory$/;"	m	struct:__anon49
BridgePassword	or/or.h	/^  char *BridgePassword;$/;"	m	struct:__anon49
BridgeRecordUsageByCountry	or/or.h	/^  int BridgeRecordUsageByCountry;$/;"	m	struct:__anon49
BridgeRelay	or/or.h	/^  int BridgeRelay; \/**< Boolean: are we acting as a bridge relay? We make$/;"	m	struct:__anon49
Bridges	or/or.h	/^  config_line_t *Bridges; \/**< List of bootstrap bridge addresses. *\/$/;"	m	struct:__anon49
BuildtimeHistogram	or/or.h	/^  config_line_t * BuildtimeHistogram;$/;"	m	struct:__anon52
CACHED_RESOLVE_MAGIC	or/dns.c	/^#define CACHED_RESOLVE_MAGIC /;"	d	file:
CACHE_GENERATED_KEYS	test/test.c	/^#undef CACHE_GENERATED_KEYS$/;"	d	file:
CACHE_STATE_CACHED_FAILED	or/dns.c	/^#define CACHE_STATE_CACHED_FAILED /;"	d	file:
CACHE_STATE_CACHED_VALID	or/dns.c	/^#define CACHE_STATE_CACHED_VALID /;"	d	file:
CACHE_STATE_DONE	or/dns.c	/^#define CACHE_STATE_DONE /;"	d	file:
CACHE_STATE_PENDING	or/dns.c	/^#define CACHE_STATE_PENDING /;"	d	file:
CAN_USE_OPENSSL_CTR	common/aes.c	/^#define CAN_USE_OPENSSL_CTR$/;"	d	file:
CASE	common/tortls.c	/^#define CASE(/;"	d	file:
CASE	common/tortls.c	/^#undef CASE$/;"	d	file:
CASE_ANY_LISTENER_TYPE	or/connection.c	/^#define CASE_ANY_LISTENER_TYPE /;"	d	file:
CASE_TOR_TLS_ERROR_ANY	common/tortls.h	/^#define CASE_TOR_TLS_ERROR_ANY /;"	d
CASE_TOR_TLS_ERROR_ANY_NONIO	common/tortls.h	/^#define CASE_TOR_TLS_ERROR_ANY_NONIO /;"	d
CATCH_SYSCALL	common/tortls.c	/^#define CATCH_SYSCALL /;"	d	file:
CATCH_ZERO	common/tortls.c	/^#define CATCH_ZERO /;"	d	file:
CBT_BIN_TO_MS	or/circuitbuild.c	/^#define CBT_BIN_TO_MS(/;"	d	file:
CBT_BIN_WIDTH	or/or.h	/^#define CBT_BIN_WIDTH /;"	d
CBT_BUILD_ABANDONED	or/or.h	/^#define CBT_BUILD_ABANDONED /;"	d
CBT_BUILD_TIME_MAX	or/or.h	/^#define CBT_BUILD_TIME_MAX /;"	d
CBT_DEFAULT_CLOSE_QUANTILE	or/or.h	/^#define CBT_DEFAULT_CLOSE_QUANTILE /;"	d
CBT_DEFAULT_MAX_RECENT_TIMEOUT_COUNT	or/or.h	/^#define CBT_DEFAULT_MAX_RECENT_TIMEOUT_COUNT /;"	d
CBT_DEFAULT_MIN_CIRCUITS_TO_OBSERVE	or/or.h	/^#define CBT_DEFAULT_MIN_CIRCUITS_TO_OBSERVE /;"	d
CBT_DEFAULT_NUM_XM_MODES	or/or.h	/^#define CBT_DEFAULT_NUM_XM_MODES /;"	d
CBT_DEFAULT_QUANTILE_CUTOFF	or/or.h	/^#define CBT_DEFAULT_QUANTILE_CUTOFF /;"	d
CBT_DEFAULT_RECENT_CIRCUITS	or/or.h	/^#define CBT_DEFAULT_RECENT_CIRCUITS /;"	d
CBT_DEFAULT_TEST_FREQUENCY	or/or.h	/^#define CBT_DEFAULT_TEST_FREQUENCY /;"	d
CBT_DEFAULT_TIMEOUT_INITIAL_VALUE	or/or.h	/^#define CBT_DEFAULT_TIMEOUT_INITIAL_VALUE /;"	d
CBT_DEFAULT_TIMEOUT_MIN_VALUE	or/or.h	/^#define CBT_DEFAULT_TIMEOUT_MIN_VALUE /;"	d
CBT_MAX_CLOSE_QUANTILE	or/or.h	/^#define CBT_MAX_CLOSE_QUANTILE /;"	d
CBT_MAX_MAX_RECENT_TIMEOUT_COUNT	or/or.h	/^#define CBT_MAX_MAX_RECENT_TIMEOUT_COUNT /;"	d
CBT_MAX_MIN_CIRCUITS_TO_OBSERVE	or/or.h	/^#define CBT_MAX_MIN_CIRCUITS_TO_OBSERVE /;"	d
CBT_MAX_NUM_XM_MODES	or/or.h	/^#define CBT_MAX_NUM_XM_MODES /;"	d
CBT_MAX_QUANTILE_CUTOFF	or/or.h	/^#define CBT_MAX_QUANTILE_CUTOFF /;"	d
CBT_MAX_RECENT_CIRCUITS	or/or.h	/^#define CBT_MAX_RECENT_CIRCUITS /;"	d
CBT_MAX_TEST_FREQUENCY	or/or.h	/^#define CBT_MAX_TEST_FREQUENCY /;"	d
CBT_MAX_TIMEOUT_INITIAL_VALUE	or/or.h	/^#define CBT_MAX_TIMEOUT_INITIAL_VALUE /;"	d
CBT_MAX_TIMEOUT_MIN_VALUE	or/or.h	/^#define CBT_MAX_TIMEOUT_MIN_VALUE /;"	d
CBT_MIN_CLOSE_QUANTILE	or/or.h	/^#define CBT_MIN_CLOSE_QUANTILE /;"	d
CBT_MIN_MAX_RECENT_TIMEOUT_COUNT	or/or.h	/^#define CBT_MIN_MAX_RECENT_TIMEOUT_COUNT /;"	d
CBT_MIN_MIN_CIRCUITS_TO_OBSERVE	or/or.h	/^#define CBT_MIN_MIN_CIRCUITS_TO_OBSERVE /;"	d
CBT_MIN_NUM_XM_MODES	or/or.h	/^#define CBT_MIN_NUM_XM_MODES /;"	d
CBT_MIN_QUANTILE_CUTOFF	or/or.h	/^#define CBT_MIN_QUANTILE_CUTOFF /;"	d
CBT_MIN_RECENT_CIRCUITS	or/or.h	/^#define CBT_MIN_RECENT_CIRCUITS /;"	d
CBT_MIN_TEST_FREQUENCY	or/or.h	/^#define CBT_MIN_TEST_FREQUENCY /;"	d
CBT_MIN_TIMEOUT_INITIAL_VALUE	or/or.h	/^#define CBT_MIN_TIMEOUT_INITIAL_VALUE /;"	d
CBT_MIN_TIMEOUT_MIN_VALUE	or/or.h	/^#define CBT_MIN_TIMEOUT_MIN_VALUE /;"	d
CBT_NCIRCUITS_TO_OBSERVE	or/or.h	/^#define CBT_NCIRCUITS_TO_OBSERVE /;"	d
CBT_SAVE_STATE_EVERY	or/or.h	/^#define CBT_SAVE_STATE_EVERY /;"	d
CEIL_DIV	common/util.h	/^#define CEIL_DIV(/;"	d
CELL_AUTHENTICATE	or/or.h	/^#define CELL_AUTHENTICATE /;"	d
CELL_AUTHORIZE	or/or.h	/^#define CELL_AUTHORIZE /;"	d
CELL_AUTH_CHALLENGE	or/or.h	/^#define CELL_AUTH_CHALLENGE /;"	d
CELL_CERTS	or/or.h	/^#define CELL_CERTS /;"	d
CELL_CREATE	or/or.h	/^#define CELL_CREATE /;"	d
CELL_CREATED	or/or.h	/^#define CELL_CREATED /;"	d
CELL_CREATED_FAST	or/or.h	/^#define CELL_CREATED_FAST /;"	d
CELL_CREATE_FAST	or/or.h	/^#define CELL_CREATE_FAST /;"	d
CELL_DESTROY	or/or.h	/^#define CELL_DESTROY /;"	d
CELL_DIRECTION_IN	or/or.h	/^  CELL_DIRECTION_IN=1, \/**< The cell is moving towards the origin. *\/$/;"	e	enum:__anon35
CELL_DIRECTION_OUT	or/or.h	/^  CELL_DIRECTION_OUT=2, \/**< The cell is moving away from the origin. *\/$/;"	e	enum:__anon35
CELL_NETINFO	or/or.h	/^#define CELL_NETINFO /;"	d
CELL_NETWORK_SIZE	or/or.h	/^#define CELL_NETWORK_SIZE /;"	d
CELL_PADDING	or/or.h	/^#define CELL_PADDING /;"	d
CELL_PAYLOAD_SIZE	or/or.h	/^#define CELL_PAYLOAD_SIZE /;"	d
CELL_QUEUE_HIGHWATER_SIZE	or/relay.c	/^#define CELL_QUEUE_HIGHWATER_SIZE /;"	d	file:
CELL_QUEUE_LOWWATER_SIZE	or/relay.c	/^#define CELL_QUEUE_LOWWATER_SIZE /;"	d	file:
CELL_RELAY	or/or.h	/^#define CELL_RELAY /;"	d
CELL_RELAY_EARLY	or/or.h	/^#define CELL_RELAY_EARLY /;"	d
CELL_VERSIONS	or/or.h	/^#define CELL_VERSIONS /;"	d
CELL_VPADDING	or/or.h	/^#define CELL_VPADDING /;"	d
CERTIFICATE_MEMBERS	or/routerparse.c	/^#define CERTIFICATE_MEMBERS /;"	d	file:
CERT_EXPIRY_SKEW	or/routerlist.c	/^#define CERT_EXPIRY_SKEW /;"	d	file:
CFG_AUTO_PORT	or/or.h	/^#define CFG_AUTO_PORT /;"	d
CHECK	or/config.c	/^#define CHECK(/;"	d	file:
CHECK_ALLOC	common/mempool.c	/^#define CHECK_ALLOC(/;"	d	file:
CHECK_DESCRIPTOR_INTERVAL	or/main.c	/^#define CHECK_DESCRIPTOR_INTERVAL /;"	d	file:
CHECK_EQ	or/dirvote.c	/^#define CHECK_EQ(/;"	d	file:
CHECK_EXPIRED_NS_INTERVAL	or/main.c	/^#define CHECK_EXPIRED_NS_INTERVAL /;"	d	file:
CHECK_FOR_COMPRESSION_BOMB_AFTER	common/torgzip.c	/^#define CHECK_FOR_COMPRESSION_BOMB_AFTER /;"	d	file:
CHECK_IPADDRESS_INTERVAL	or/main.c	/^#define CHECK_IPADDRESS_INTERVAL /;"	d	file:
CHECK_LENGTH	or/routerparse.c	/^#define CHECK_LENGTH(/;"	d	file:
CHECK_LENGTH	or/routerparse.c	/^#undef CHECK_LENGTH$/;"	d	file:
CHECK_PRINTF	common/compat.h	/^#define CHECK_PRINTF(/;"	d
CHECK_SENTINEL	common/memarea.c	/^#define CHECK_SENTINEL(/;"	d	file:
CHECK_STRTOX_RESULT	common/util.c	/^#define CHECK_STRTOX_RESULT(/;"	d	file:
CHECK_V3_CERTIFICATE_INTERVAL	or/main.c	/^#define CHECK_V3_CERTIFICATE_INTERVAL /;"	d	file:
CHECK_WRITE_STATS_INTERVAL	or/main.c	/^#define CHECK_WRITE_STATS_INTERVAL /;"	d	file:
CHILD_STATE_CLOSEFD	common/util.c	/^#define CHILD_STATE_CLOSEFD /;"	d	file:
CHILD_STATE_DUPERR	common/util.c	/^#define CHILD_STATE_DUPERR /;"	d	file:
CHILD_STATE_DUPOUT	common/util.c	/^#define CHILD_STATE_DUPOUT /;"	d	file:
CHILD_STATE_EXEC	common/util.c	/^#define CHILD_STATE_EXEC /;"	d	file:
CHILD_STATE_FAILEXEC	common/util.c	/^#define CHILD_STATE_FAILEXEC /;"	d	file:
CHILD_STATE_FORK	common/util.c	/^#define CHILD_STATE_FORK /;"	d	file:
CHILD_STATE_INIT	common/util.c	/^#define CHILD_STATE_INIT /;"	d	file:
CHILD_STATE_MAXFD	common/util.c	/^#define CHILD_STATE_MAXFD /;"	d	file:
CHILD_STATE_PIPE	common/util.c	/^#define CHILD_STATE_PIPE /;"	d	file:
CHILD_STATE_REDIRECT	common/util.c	/^#define CHILD_STATE_REDIRECT /;"	d	file:
CHUNK_ALLOC_SIZE	or/buffers.c	/^#define CHUNK_ALLOC_SIZE(/;"	d	file:
CHUNK_HEADER_LEN	or/buffers.c	/^#define CHUNK_HEADER_LEN /;"	d	file:
CHUNK_HEADER_SIZE	common/memarea.c	/^#define CHUNK_HEADER_SIZE /;"	d	file:
CHUNK_OVERHEAD	common/mempool.c	/^#define CHUNK_OVERHEAD /;"	d	file:
CHUNK_REMAINING_CAPACITY	or/buffers.c	/^CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)$/;"	f	file:
CHUNK_SIZE	common/memarea.c	/^#define CHUNK_SIZE /;"	d	file:
CHUNK_SIZE_WITH_ALLOC	or/buffers.c	/^#define CHUNK_SIZE_WITH_ALLOC(/;"	d	file:
CHUNK_WRITE_PTR	or/buffers.c	/^CHUNK_WRITE_PTR(chunk_t *chunk)$/;"	f	file:
CIPHER	common/tortls.c	/^#define CIPHER(/;"	d	file:
CIPHER	common/tortls.c	/^#undef CIPHER$/;"	d	file:
CIPHER_IV_LEN	common/crypto.h	/^#define CIPHER_IV_LEN /;"	d
CIPHER_KEY_LEN	common/crypto.h	/^#define CIPHER_KEY_LEN /;"	d
CIRCLAUNCH_IS_INTERNAL	or/circuituse.h	/^#define CIRCLAUNCH_IS_INTERNAL /;"	d
CIRCLAUNCH_NEED_CAPACITY	or/circuituse.h	/^#define CIRCLAUNCH_NEED_CAPACITY /;"	d
CIRCLAUNCH_NEED_UPTIME	or/circuituse.h	/^#define CIRCLAUNCH_NEED_UPTIME /;"	d
CIRCLAUNCH_ONEHOP_TUNNEL	or/circuituse.h	/^#define CIRCLAUNCH_ONEHOP_TUNNEL /;"	d
CIRCUIT_IS_ORIGIN	or/or.h	/^#define CIRCUIT_IS_ORIGIN(/;"	d
CIRCUIT_PRIVATE	or/circuitbuild.c	/^#define CIRCUIT_PRIVATE$/;"	d	file:
CIRCUIT_PRIVATE	test/test.c	/^#define CIRCUIT_PRIVATE$/;"	d	file:
CIRCUIT_PURPOSE_CONTROLLER	or/or.h	/^#define CIRCUIT_PURPOSE_CONTROLLER /;"	d
CIRCUIT_PURPOSE_C_ESTABLISH_REND	or/or.h	/^#define CIRCUIT_PURPOSE_C_ESTABLISH_REND /;"	d
CIRCUIT_PURPOSE_C_GENERAL	or/or.h	/^#define CIRCUIT_PURPOSE_C_GENERAL /;"	d
CIRCUIT_PURPOSE_C_INTRODUCE_ACKED	or/or.h	/^#define CIRCUIT_PURPOSE_C_INTRODUCE_ACKED /;"	d
CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT	or/or.h	/^#define CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT /;"	d
CIRCUIT_PURPOSE_C_INTRODUCING	or/or.h	/^#define CIRCUIT_PURPOSE_C_INTRODUCING /;"	d
CIRCUIT_PURPOSE_C_MEASURE_TIMEOUT	or/or.h	/^#define CIRCUIT_PURPOSE_C_MEASURE_TIMEOUT /;"	d
CIRCUIT_PURPOSE_C_REND_JOINED	or/or.h	/^#define CIRCUIT_PURPOSE_C_REND_JOINED /;"	d
CIRCUIT_PURPOSE_C_REND_READY	or/or.h	/^#define CIRCUIT_PURPOSE_C_REND_READY /;"	d
CIRCUIT_PURPOSE_C_REND_READY_INTRO_ACKED	or/or.h	/^#define CIRCUIT_PURPOSE_C_REND_READY_INTRO_ACKED /;"	d
CIRCUIT_PURPOSE_INTRO_POINT	or/or.h	/^#define CIRCUIT_PURPOSE_INTRO_POINT /;"	d
CIRCUIT_PURPOSE_IS_CLIENT	or/or.h	/^#define CIRCUIT_PURPOSE_IS_CLIENT(/;"	d
CIRCUIT_PURPOSE_IS_ESTABLISHED_REND	or/or.h	/^#define CIRCUIT_PURPOSE_IS_ESTABLISHED_REND(/;"	d
CIRCUIT_PURPOSE_IS_ORIGIN	or/or.h	/^#define CIRCUIT_PURPOSE_IS_ORIGIN(/;"	d
CIRCUIT_PURPOSE_OR	or/or.h	/^#define CIRCUIT_PURPOSE_OR /;"	d
CIRCUIT_PURPOSE_REND_ESTABLISHED	or/or.h	/^#define CIRCUIT_PURPOSE_REND_ESTABLISHED /;"	d
CIRCUIT_PURPOSE_REND_POINT_WAITING	or/or.h	/^#define CIRCUIT_PURPOSE_REND_POINT_WAITING /;"	d
CIRCUIT_PURPOSE_S_CONNECT_REND	or/or.h	/^#define CIRCUIT_PURPOSE_S_CONNECT_REND /;"	d
CIRCUIT_PURPOSE_S_ESTABLISH_INTRO	or/or.h	/^#define CIRCUIT_PURPOSE_S_ESTABLISH_INTRO /;"	d
CIRCUIT_PURPOSE_S_INTRO	or/or.h	/^#define CIRCUIT_PURPOSE_S_INTRO /;"	d
CIRCUIT_PURPOSE_S_REND_JOINED	or/or.h	/^#define CIRCUIT_PURPOSE_S_REND_JOINED /;"	d
CIRCUIT_PURPOSE_TESTING	or/or.h	/^#define CIRCUIT_PURPOSE_TESTING /;"	d
CIRCUIT_PURPOSE_UNKNOWN	or/or.h	/^#define CIRCUIT_PURPOSE_UNKNOWN /;"	d
CIRCUIT_STATE_BUILDING	or/or.h	/^#define CIRCUIT_STATE_BUILDING /;"	d
CIRCUIT_STATE_ONIONSKIN_PENDING	or/or.h	/^#define CIRCUIT_STATE_ONIONSKIN_PENDING /;"	d
CIRCUIT_STATE_OPEN	or/or.h	/^#define CIRCUIT_STATE_OPEN /;"	d
CIRCUIT_STATE_OR_WAIT	or/or.h	/^#define CIRCUIT_STATE_OR_WAIT /;"	d
CIRCWINDOW_INCREMENT	or/or.h	/^#define CIRCWINDOW_INCREMENT /;"	d
CIRCWINDOW_START	or/or.h	/^#define CIRCWINDOW_START /;"	d
CIRCWINDOW_START_MAX	or/or.h	/^#define CIRCWINDOW_START_MAX /;"	d
CIRCWINDOW_START_MIN	or/or.h	/^#define CIRCWINDOW_START_MIN /;"	d
CIRC_EVENT_BUILT	or/or.h	/^  CIRC_EVENT_BUILT    = 1,$/;"	e	enum:circuit_status_event_t
CIRC_EVENT_CLOSED	or/or.h	/^  CIRC_EVENT_CLOSED   = 4,$/;"	e	enum:circuit_status_event_t
CIRC_EVENT_EXTENDED	or/or.h	/^  CIRC_EVENT_EXTENDED = 2,$/;"	e	enum:circuit_status_event_t
CIRC_EVENT_FAILED	or/or.h	/^  CIRC_EVENT_FAILED   = 3,$/;"	e	enum:circuit_status_event_t
CIRC_EVENT_LAUNCHED	or/or.h	/^  CIRC_EVENT_LAUNCHED = 0,$/;"	e	enum:circuit_status_event_t
CIRC_ID_TYPE_HIGHER	or/or.h	/^  CIRC_ID_TYPE_HIGHER=1, \/**< Pick from 1<<15..1<<16-1. *\/$/;"	e	enum:__anon34
CIRC_ID_TYPE_LOWER	or/or.h	/^  CIRC_ID_TYPE_LOWER=0, \/**< Pick from 0..1<<15-1. *\/$/;"	e	enum:__anon34
CIRC_ID_TYPE_NEITHER	or/or.h	/^  CIRC_ID_TYPE_NEITHER=2$/;"	e	enum:__anon34
CIRC_MINOR_EVENT_CANNIBALIZED	or/or.h	/^  CIRC_MINOR_EVENT_CANNIBALIZED,$/;"	e	enum:circuit_status_minor_event_t
CIRC_MINOR_EVENT_PURPOSE_CHANGED	or/or.h	/^  CIRC_MINOR_EVENT_PURPOSE_CHANGED,$/;"	e	enum:circuit_status_minor_event_t
CLASS_INET	or/eventdns.c	/^#define CLASS_INET	/;"	d	file:
CLEAN_CACHES_INTERVAL	or/main.c	/^#define CLEAN_CACHES_INTERVAL /;"	d	file:
CLEAR	or/eventdns.c	/^#define CLEAR(/;"	d	file:
CLIENT_CIPHER_DUMMIES	common/tortls.c	/^static SSL_CIPHER *CLIENT_CIPHER_DUMMIES = NULL;$/;"	v	file:
CLIENT_CIPHER_INFO_LIST	common/tortls.c	/^static const cipher_info_t CLIENT_CIPHER_INFO_LIST[] = {$/;"	v	file:
CLIENT_CIPHER_LIST	common/tortls.c	/^#define CLIENT_CIPHER_LIST /;"	d	file:
CLIENT_CIPHER_LIST	common/tortls.c	/^#undef CLIENT_CIPHER_LIST$/;"	d	file:
CLIENT_CIPHER_LIST	common/tortls.c	/^static const char CLIENT_CIPHER_LIST[] =$/;"	v	file:
CLIENT_IDLE_TIME_FOR_PRIORITY	or/connection.c	/^#define CLIENT_IDLE_TIME_FOR_PRIORITY /;"	d	file:
CLOSE_SOCKET	or/eventdns.c	/^#define CLOSE_SOCKET(/;"	d	file:
CL_PORT_ALLOW_EXTRA_LISTENADDR	or/config.c	/^#define CL_PORT_ALLOW_EXTRA_LISTENADDR /;"	d	file:
CL_PORT_FORBID_NONLOCAL	or/config.c	/^#define CL_PORT_FORBID_NONLOCAL /;"	d	file:
CL_PORT_NO_OPTIONS	or/config.c	/^#define CL_PORT_NO_OPTIONS /;"	d	file:
CL_PORT_SERVER_OPTIONS	or/config.c	/^#define CL_PORT_SERVER_OPTIONS /;"	d	file:
CL_PORT_WARN_NONLOCAL	or/config.c	/^#define CL_PORT_WARN_NONLOCAL /;"	d	file:
CMD_HASH_PASSWORD	or/or.h	/^    CMD_RUN_TOR=0, CMD_LIST_FINGERPRINT, CMD_HASH_PASSWORD,$/;"	e	enum:__anon49::__anon50
CMD_LIST_FINGERPRINT	or/or.h	/^    CMD_RUN_TOR=0, CMD_LIST_FINGERPRINT, CMD_HASH_PASSWORD,$/;"	e	enum:__anon49::__anon50
CMD_RUN_TOR	or/or.h	/^    CMD_RUN_TOR=0, CMD_LIST_FINGERPRINT, CMD_HASH_PASSWORD,$/;"	e	enum:__anon49::__anon50
CMD_RUN_UNITTESTS	or/or.h	/^    CMD_VERIFY_CONFIG, CMD_RUN_UNITTESTS$/;"	e	enum:__anon49::__anon50
CMD_VERIFY_CONFIG	or/or.h	/^    CMD_VERIFY_CONFIG, CMD_RUN_UNITTESTS$/;"	e	enum:__anon49::__anon50
CMP_EXACT	common/address.h	/^  CMP_EXACT,$/;"	e	enum:__anon2
CMP_SEMANTIC	common/address.h	/^  CMP_SEMANTIC,$/;"	e	enum:__anon2
COMPLAIN	or/config.c	/^#define COMPLAIN(/;"	d	file:
COMPLAIN	or/config.c	/^#undef COMPLAIN$/;"	d	file:
CONCAT_ARGS	or/routerparse.c	/^#define CONCAT_ARGS /;"	d	file:
CONDITIONAL_CONSENSUS_FPR_LEN	or/directory.c	/^#define CONDITIONAL_CONSENSUS_FPR_LEN /;"	d	file:
CONFDIR	win32/orconfig.h	/^#define CONFDIR /;"	d
CONFIG_LINE_APPEND	or/or.h	/^#define CONFIG_LINE_APPEND /;"	d
CONFIG_LINE_CLEAR	or/or.h	/^#define CONFIG_LINE_CLEAR /;"	d
CONFIG_LINE_NORMAL	or/or.h	/^#define CONFIG_LINE_NORMAL /;"	d
CONFIG_PRIVATE	or/config.c	/^#define CONFIG_PRIVATE$/;"	d	file:
CONFIG_PRIVATE	test/test.c	/^#define CONFIG_PRIVATE$/;"	d	file:
CONFIG_TEST	test/test_config.c	/^#define CONFIG_TEST(/;"	d	file:
CONFIG_TYPE_AUTOBOOL	or/config.c	/^  CONFIG_TYPE_AUTOBOOL,     \/**< A boolean+auto value, expressed 0 for false,$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_BOOL	or/config.c	/^  CONFIG_TYPE_BOOL,         \/**< A boolean value, expressed as 0 or 1. *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_CSV	or/config.c	/^  CONFIG_TYPE_CSV,          \/**< A list of strings, separated by commas and$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_DOUBLE	or/config.c	/^  CONFIG_TYPE_DOUBLE,       \/**< A floating-point value *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_FILENAME	or/config.c	/^  CONFIG_TYPE_FILENAME,     \/**< A filename: some prefixes get expanded. *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_INTERVAL	or/config.c	/^  CONFIG_TYPE_INTERVAL,     \/**< A number of seconds, with optional units*\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_ISOTIME	or/config.c	/^  CONFIG_TYPE_ISOTIME,      \/**< An ISO-formatted time relative to GMT. *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_LINELIST	or/config.c	/^  CONFIG_TYPE_LINELIST,     \/**< Uninterpreted config lines *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_LINELIST_S	or/config.c	/^  CONFIG_TYPE_LINELIST_S,   \/**< Uninterpreted, context-sensitive config lines,$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_LINELIST_V	or/config.c	/^  CONFIG_TYPE_LINELIST_V,   \/**< Catch-all "virtual" option to summarize$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_MEMUNIT	or/config.c	/^  CONFIG_TYPE_MEMUNIT,      \/**< A number of bytes, with optional units*\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_MSEC_INTERVAL	or/config.c	/^  CONFIG_TYPE_MSEC_INTERVAL,\/**< A number of milliseconds, with optional$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_OBSOLETE	or/config.c	/^  CONFIG_TYPE_OBSOLETE,     \/**< Obsolete (ignored) option. *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_PORT	or/config.c	/^  CONFIG_TYPE_PORT,         \/**< A port from 1...65535, 0 for "not set", or$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_ROUTERSET	or/config.c	/^  CONFIG_TYPE_ROUTERSET,    \/**< A list of router names, addrs, and fps,$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_STRING	or/config.c	/^  CONFIG_TYPE_STRING = 0,   \/**< An arbitrary string. *\/$/;"	e	enum:config_type_t	file:
CONFIG_TYPE_UINT	or/config.c	/^  CONFIG_TYPE_UINT,         \/**< A non-negative integer less than MAX_INT *\/$/;"	e	enum:config_type_t	file:
CONN_IS_CLOSED	or/connection.c	/^#define CONN_IS_CLOSED(/;"	d	file:
CONN_IS_EDGE	or/or.h	/^#define CONN_IS_EDGE(/;"	d
CONN_LOG_PROTECT	or/or.h	/^#define CONN_LOG_PROTECT(/;"	d
CONN_TYPE_AP	or/or.h	/^#define CONN_TYPE_AP /;"	d
CONN_TYPE_AP_DNS_LISTENER	or/or.h	/^#define CONN_TYPE_AP_DNS_LISTENER /;"	d
CONN_TYPE_AP_LISTENER	or/or.h	/^#define CONN_TYPE_AP_LISTENER /;"	d
CONN_TYPE_AP_NATD_LISTENER	or/or.h	/^#define CONN_TYPE_AP_NATD_LISTENER /;"	d
CONN_TYPE_AP_TRANS_LISTENER	or/or.h	/^#define CONN_TYPE_AP_TRANS_LISTENER /;"	d
CONN_TYPE_CONTROL	or/or.h	/^#define CONN_TYPE_CONTROL /;"	d
CONN_TYPE_CONTROL_LISTENER	or/or.h	/^#define CONN_TYPE_CONTROL_LISTENER /;"	d
CONN_TYPE_CPUWORKER	or/or.h	/^#define CONN_TYPE_CPUWORKER /;"	d
CONN_TYPE_DIR	or/or.h	/^#define CONN_TYPE_DIR /;"	d
CONN_TYPE_DIR_LISTENER	or/or.h	/^#define CONN_TYPE_DIR_LISTENER /;"	d
CONN_TYPE_EXIT	or/or.h	/^#define CONN_TYPE_EXIT /;"	d
CONN_TYPE_OR	or/or.h	/^#define CONN_TYPE_OR /;"	d
CONN_TYPE_OR_LISTENER	or/or.h	/^#define CONN_TYPE_OR_LISTENER /;"	d
CONSENSUS_FLAVORED_PREFIX	or/directory.c	/^      #define CONSENSUS_FLAVORED_PREFIX /;"	d	file:
CONSENSUS_MIN_SECONDS_BEFORE_CACHING	or/networkstatus.c	/^#define CONSENSUS_MIN_SECONDS_BEFORE_CACHING /;"	d	file:
CONSENSUS_NETWORKSTATUS_MAX_DL_TRIES	or/networkstatus.c	/^#define CONSENSUS_NETWORKSTATUS_MAX_DL_TRIES /;"	d	file:
CONSENSUS_URL_PREFIX	or/directory.c	/^      #define CONSENSUS_URL_PREFIX /;"	d	file:
CONTAINER_LEGACY	test/test_containers.c	/^#define CONTAINER_LEGACY(/;"	d	file:
CONTENT_LENGTH	or/buffers.c	/^#define CONTENT_LENGTH /;"	d	file:
CONTROL_CONNECTION_MAGIC	or/or.h	/^#define CONTROL_CONNECTION_MAGIC /;"	d
CONTROL_CONN_STATE_NEEDAUTH	or/or.h	/^#define CONTROL_CONN_STATE_NEEDAUTH /;"	d
CONTROL_CONN_STATE_OPEN	or/or.h	/^#define CONTROL_CONN_STATE_OPEN /;"	d
CONTROL_PRIVATE	or/control.c	/^#define CONTROL_PRIVATE$/;"	d	file:
CONTROL_PRIVATE	test/test_util.c	/^#define CONTROL_PRIVATE$/;"	d	file:
COUNTER	common/aes.c	/^#define COUNTER(/;"	d	file:
COUNT_DISTINCT_DIGESTS	or/routerparse.c	/^#undef COUNT_DISTINCT_DIGESTS$/;"	d	file:
CPATH_KEY_MATERIAL_LEN	or/or.h	/^#define CPATH_KEY_MATERIAL_LEN /;"	d
CPATH_STATE_AWAITING_KEYS	or/or.h	/^#define CPATH_STATE_AWAITING_KEYS /;"	d
CPATH_STATE_CLOSED	or/or.h	/^#define CPATH_STATE_CLOSED /;"	d
CPATH_STATE_OPEN	or/or.h	/^#define CPATH_STATE_OPEN /;"	d
CPD_CHECK	common/util.h	/^#define CPD_CHECK /;"	d
CPD_CHECK_MODE_ONLY	common/util.h	/^#define CPD_CHECK_MODE_ONLY /;"	d
CPD_CREATE	common/util.h	/^#define CPD_CREATE /;"	d
CPD_GROUP_OK	common/util.h	/^#define CPD_GROUP_OK /;"	d
CPD_NONE	common/util.h	/^#define CPD_NONE /;"	d
CPUWORKER_BUSY_TIMEOUT	or/cpuworker.c	/^#define CPUWORKER_BUSY_TIMEOUT /;"	d	file:
CPUWORKER_STATE_BUSY_ONION	or/or.h	/^#define CPUWORKER_STATE_BUSY_ONION /;"	d
CPUWORKER_STATE_IDLE	or/or.h	/^#define CPUWORKER_STATE_IDLE /;"	d
CPUWORKER_TASK_ONION	or/or.h	/^#define CPUWORKER_TASK_ONION /;"	d
CREDENTIAL_LOG_LEVEL	common/compat.c	/^#define CREDENTIAL_LOG_LEVEL /;"	d	file:
CRN_ALLOW_INVALID	or/or.h	/^  CRN_ALLOW_INVALID = 1<<3,$/;"	e	enum:__anon66
CRN_NEED_CAPACITY	or/or.h	/^  CRN_NEED_CAPACITY = 1<<1,$/;"	e	enum:__anon66
CRN_NEED_DESC	or/or.h	/^  CRN_NEED_DESC = 1<<6$/;"	e	enum:__anon66
CRN_NEED_GUARD	or/or.h	/^  CRN_NEED_GUARD = 1<<2,$/;"	e	enum:__anon66
CRN_NEED_UPTIME	or/or.h	/^  CRN_NEED_UPTIME = 1<<0,$/;"	e	enum:__anon66
CRN_WEIGHT_AS_EXIT	or/or.h	/^  CRN_WEIGHT_AS_EXIT = 1<<5,$/;"	e	enum:__anon66
CRYPTO_LEGACY	test/test_crypto.c	/^#define CRYPTO_LEGACY(/;"	d	file:
CRYPTO_PRIVATE	common/crypto.c	/^#define CRYPTO_PRIVATE$/;"	d	file:
CRYPTO_PRIVATE	common/tortls.c	/^#define CRYPTO_PRIVATE /;"	d	file:
CRYPTO_PRIVATE	test/test_crypto.c	/^#define CRYPTO_PRIVATE$/;"	d	file:
CRYPTO_PRIVATE	tools/tor-checkkey.c	/^#define CRYPTO_PRIVATE$/;"	d	file:
CRYPTO_PRIVATE	tools/tor-gencert.c	/^#define CRYPTO_PRIVATE$/;"	d	file:
CRYPTO_dynlock_value	common/crypto.c	/^struct CRYPTO_dynlock_value {$/;"	s	file:
CRYPT_INVALID_ARG	common/sha256.c	/^#define CRYPT_INVALID_ARG /;"	d	file:
CRYPT_NOP	common/sha256.c	/^#define CRYPT_NOP /;"	d	file:
CRYPT_OK	common/sha256.c	/^#define CRYPT_OK /;"	d	file:
CRYPT_PATH_MAGIC	or/or.h	/^#define CRYPT_PATH_MAGIC /;"	d
CST_CHECK_AUTHORITY	or/routerparse.c	/^#define CST_CHECK_AUTHORITY /;"	d	file:
CST_NO_CHECK_OBJTYPE	or/routerparse.c	/^#define CST_NO_CHECK_OBJTYPE /;"	d	file:
CULL_CPUWORKERS_INTERVAL	or/cpuworker.c	/^#define CULL_CPUWORKERS_INTERVAL /;"	d	file:
C_CLIENT_KEY	or/routerparse.c	/^  C_CLIENT_KEY,$/;"	e	enum:__anon69	file:
C_CLIENT_NAME	or/routerparse.c	/^  C_CLIENT_NAME,$/;"	e	enum:__anon69	file:
C_DESCRIPTOR_COOKIE	or/routerparse.c	/^  C_DESCRIPTOR_COOKIE,$/;"	e	enum:__anon69	file:
CellStatistics	or/or.h	/^  int CellStatistics;$/;"	m	struct:__anon49
Ch	common/sha256.c	/^#define Ch(/;"	d	file:
ChangeServiceConfig2A_fn	or/ntmain.c	/^  BOOL (WINAPI *ChangeServiceConfig2A_fn)($/;"	m	struct:service_fns	file:
CircuitBuildAbandonedCount	or/or.h	/^  unsigned int CircuitBuildAbandonedCount;$/;"	m	struct:__anon52
CircuitBuildTimeout	or/or.h	/^  int CircuitBuildTimeout; \/**< Cull non-open circuits that were born at$/;"	m	struct:__anon49
CircuitIdleTimeout	or/or.h	/^  int CircuitIdleTimeout; \/**< Cull open clean circuits that were born$/;"	m	struct:__anon49
CircuitPriorityHalflife	or/or.h	/^  double CircuitPriorityHalflife;$/;"	m	struct:__anon49
CircuitStreamTimeout	or/or.h	/^  int CircuitStreamTimeout; \/**< If non-zero, detach streams from circuits$/;"	m	struct:__anon49
ClientDNSRejectInternalAddresses	or/or.h	/^  int ClientDNSRejectInternalAddresses;$/;"	m	struct:__anon49
ClientOnly	or/or.h	/^  int ClientOnly; \/**< Boolean: should we never evolve into a server role? *\/$/;"	m	struct:__anon49
ClientRejectInternalAddresses	or/or.h	/^  int ClientRejectInternalAddresses;$/;"	m	struct:__anon49
ClientTransportPlugin	or/or.h	/^  config_line_t *ClientTransportPlugin; \/**< List of client$/;"	m	struct:__anon49
CloseHSClientCircuitsImmediatelyOnTimeout	or/or.h	/^  int CloseHSClientCircuitsImmediatelyOnTimeout;$/;"	m	struct:__anon49
CloseHSServiceRendCircuitsImmediatelyOnTimeout	or/or.h	/^  int CloseHSServiceRendCircuitsImmediatelyOnTimeout;$/;"	m	struct:__anon49
CloseServiceHandle_fn	or/ntmain.c	/^  BOOL (WINAPI *CloseServiceHandle_fn)($/;"	m	struct:service_fns	file:
ConnDirectionStatistics	or/or.h	/^  int ConnDirectionStatistics;$/;"	m	struct:__anon49
ConnLimit	or/or.h	/^  int ConnLimit; \/**< Demanded minimum number of simultaneous connections. *\/$/;"	m	struct:__anon49
ConsensusParams	or/or.h	/^  char *ConsensusParams;$/;"	m	struct:__anon49
ConstrainedSockSize	or/or.h	/^  uint64_t ConstrainedSockSize; \/**< Size of constrained buffers. *\/$/;"	m	struct:__anon49
ConstrainedSockets	or/or.h	/^  int ConstrainedSockets; \/**< Shrink xmit and recv socket buffers. *\/$/;"	m	struct:__anon49
ContactInfo	or/or.h	/^  char *ContactInfo; \/**< Contact info to be published in the directory. *\/$/;"	m	struct:__anon49
ControlListenAddress	or/or.h	/^  config_line_t *ControlListenAddress;$/;"	m	struct:__anon49
ControlPort	or/or.h	/^  config_line_t *ControlPort; \/**< Port to listen on for control$/;"	m	struct:__anon49
ControlPortFileGroupReadable	or/or.h	/^  int ControlPortFileGroupReadable;$/;"	m	struct:__anon49
ControlPortWriteToFile	or/or.h	/^  char *ControlPortWriteToFile;$/;"	m	struct:__anon49
ControlService_fn	or/ntmain.c	/^  BOOL (WINAPI *ControlService_fn)($/;"	m	struct:service_fns	file:
ControlSocket	or/or.h	/^  config_line_t *ControlSocket; \/**< List of Unix Domain Sockets to listen on$/;"	m	struct:__anon49
ControlSocketsGroupWritable	or/or.h	/^  int ControlSocketsGroupWritable; \/**< Boolean: Are control sockets g+rw? *\/$/;"	m	struct:__anon49
CookieAuthFile	or/or.h	/^  char *CookieAuthFile; \/**< Location of a cookie authentication file. *\/$/;"	m	struct:__anon49
CookieAuthFileGroupReadable	or/or.h	/^  int CookieAuthFileGroupReadable; \/**< Boolean: Is the CookieAuthFile g+r? *\/$/;"	m	struct:__anon49
CookieAuthentication	or/or.h	/^  int CookieAuthentication; \/**< Boolean: do we enable cookie-based auth for$/;"	m	struct:__anon49
CountPrivateBandwidth	or/or.h	/^  int CountPrivateBandwidth;$/;"	m	struct:__anon49
CreateServiceA_fn	or/ntmain.c	/^  SC_HANDLE (WINAPI *CreateServiceA_fn)($/;"	m	struct:service_fns	file:
DBL_TO_U64	common/compat.h	/^#define DBL_TO_U64(/;"	d
DEAD_CERT_LIFETIME	or/routerlist.c	/^#define DEAD_CERT_LIFETIME /;"	d	file:
DEBUG_AREA_ALLOC	or/routerparse.c	/^#undef DEBUG_AREA_ALLOC$/;"	d	file:
DEBUG_ROUTER_DUMP_ROUTER_TO_STRING	or/router.c	/^#define DEBUG_ROUTER_DUMP_ROUTER_TO_STRING$/;"	d	file:
DEBUG_SOCKET_COUNTING	common/compat.c	/^#undef DEBUG_SOCKET_COUNTING$/;"	d	file:
DECLARE_CTYPE_FN	common/compat.h	/^#define DECLARE_CTYPE_FN(/;"	d
DECLARE_MAP_FNS	common/container.h	/^#define DECLARE_MAP_FNS(/;"	d
DECLARE_MAP_FNS	common/container.h	/^#undef DECLARE_MAP_FNS$/;"	d
DECLARE_TYPED_DIGESTMAP_FNS	common/container.h	/^#define DECLARE_TYPED_DIGESTMAP_FNS(/;"	d
DEC_ONIONSKIN	or/or.h	/^  ENC_ONIONSKIN, DEC_ONIONSKIN,$/;"	e	enum:__anon65
DEFAULT_CLIENT_NICKNAME	or/or.h	/^#define DEFAULT_CLIENT_NICKNAME /;"	d
DEFAULT_DNS_TTL	or/or.h	/^#define DEFAULT_DNS_TTL /;"	d
DEFAULT_EXIT_POLICY	or/policies.c	/^#define DEFAULT_EXIT_POLICY /;"	d	file:
DEFAULT_LIFETIME	tools/tor-gencert.c	/^#define DEFAULT_LIFETIME /;"	d	file:
DEFAULT_MAX_BELIEVABLE_BANDWIDTH	or/routerlist.c	/^#define DEFAULT_MAX_BELIEVABLE_BANDWIDTH /;"	d	file:
DEFAULT_MAX_FD	common/util.c	/^#define DEFAULT_MAX_FD /;"	d	file:
DEFAULT_ROUTE_LEN	or/or.h	/^#define DEFAULT_ROUTE_LEN /;"	d
DEFINE_MAP_STRUCTS	common/container.c	/^#define DEFINE_MAP_STRUCTS(/;"	d	file:
DELAY_WHILE_FETCHING_CERTS	or/networkstatus.c	/^#define DELAY_WHILE_FETCHING_CERTS /;"	d	file:
DESCRIPTOR_FAILURE_RESET_INTERVAL	or/main.c	/^#define DESCRIPTOR_FAILURE_RESET_INTERVAL /;"	d	file:
DGV_BY_ID	or/dirvote.h	/^#define DGV_BY_ID /;"	d
DGV_INCLUDE_PENDING	or/dirvote.h	/^#define DGV_INCLUDE_PENDING /;"	d
DGV_INCLUDE_PREVIOUS	or/dirvote.h	/^#define DGV_INCLUDE_PREVIOUS /;"	d
DH_BYTES	common/crypto.h	/^#define DH_BYTES /;"	d
DH_GENERATOR	common/crypto.c	/^#define DH_GENERATOR /;"	d	file:
DH_KEY_LEN	or/or.h	/^#define DH_KEY_LEN /;"	d
DH_PRIVATE_KEY_BITS	common/crypto.c	/^#define DH_PRIVATE_KEY_BITS /;"	d	file:
DH_TYPE_CIRCUIT	common/crypto.h	/^#define DH_TYPE_CIRCUIT /;"	d
DH_TYPE_REND	common/crypto.h	/^#define DH_TYPE_REND /;"	d
DH_TYPE_TLS	common/crypto.h	/^#define DH_TYPE_TLS /;"	d
DIGEST256_LEN	common/crypto.h	/^#define DIGEST256_LEN /;"	d
DIGESTMAP_FOREACH	common/container.h	/^#define DIGESTMAP_FOREACH(/;"	d
DIGESTMAP_FOREACH_END	common/container.h	/^#define DIGESTMAP_FOREACH_END /;"	d
DIGESTMAP_FOREACH_MODIFY	common/container.h	/^#define DIGESTMAP_FOREACH_MODIFY(/;"	d
DIGEST_LEN	common/crypto.h	/^#define DIGEST_LEN /;"	d
DIGEST_SHA1	common/crypto.h	/^  DIGEST_SHA1 = 0,$/;"	e	enum:__anon10
DIGEST_SHA256	common/crypto.h	/^  DIGEST_SHA256 = 1,$/;"	e	enum:__anon10
DIR	test/test_dir.c	/^#define DIR(/;"	d	file:
DIROBJ_MAX_SIG_LEN	or/routerparse.h	/^#define DIROBJ_MAX_SIG_LEN /;"	d
DIRPORTFRONTPAGE_CACHE_LIFETIME	or/directory.c	/^#define DIRPORTFRONTPAGE_CACHE_LIFETIME /;"	d	file:
DIRREQ_CIRC_QUEUE_FLUSHED	or/or.h	/^  DIRREQ_CIRC_QUEUE_FLUSHED = 3,$/;"	e	enum:__anon62
DIRREQ_DIRECT	or/or.h	/^  DIRREQ_DIRECT = 0,$/;"	e	enum:__anon61
DIRREQ_END_CELL_SENT	or/or.h	/^  DIRREQ_END_CELL_SENT = 2,$/;"	e	enum:__anon62
DIRREQ_FLUSHING_DIR_CONN_FINISHED	or/or.h	/^  DIRREQ_FLUSHING_DIR_CONN_FINISHED = 1,$/;"	e	enum:__anon62
DIRREQ_IS_FOR_NETWORK_STATUS	or/or.h	/^  DIRREQ_IS_FOR_NETWORK_STATUS = 0,$/;"	e	enum:__anon62
DIRREQ_OR_CONN_BUFFER_FLUSHED	or/or.h	/^  DIRREQ_OR_CONN_BUFFER_FLUSHED = 4$/;"	e	enum:__anon62
DIRREQ_TIMEOUT	or/geoip.c	/^#define DIRREQ_TIMEOUT /;"	d	file:
DIRREQ_TUNNELED	or/or.h	/^  DIRREQ_TUNNELED = 1,$/;"	e	enum:__anon61
DIRSERV_BUFFER_MIN	or/dirserv.c	/^#define DIRSERV_BUFFER_MIN /;"	d	file:
DIRSERV_PRIVATE	or/dirserv.c	/^#define DIRSERV_PRIVATE$/;"	d	file:
DIRSERV_PRIVATE	test/test_dir.c	/^#define DIRSERV_PRIVATE$/;"	d	file:
DIRVOTE_PRIVATE	or/dirvote.c	/^#define DIRVOTE_PRIVATE$/;"	d	file:
DIRVOTE_PRIVATE	test/test_dir.c	/^#define DIRVOTE_PRIVATE$/;"	d	file:
DIR_503_TIMEOUT	or/routerlist.c	/^#define DIR_503_TIMEOUT /;"	d	file:
DIR_CONNECTION_MAGIC	or/or.h	/^#define DIR_CONNECTION_MAGIC /;"	d
DIR_CONN_IS_SERVER	or/or.h	/^#define DIR_CONN_IS_SERVER(/;"	d
DIR_CONN_MAX_STALL	or/main.c	/^#define DIR_CONN_MAX_STALL /;"	d	file:
DIR_CONN_STATE_CLIENT_FINISHED	or/or.h	/^#define DIR_CONN_STATE_CLIENT_FINISHED /;"	d
DIR_CONN_STATE_CLIENT_READING	or/or.h	/^#define DIR_CONN_STATE_CLIENT_READING /;"	d
DIR_CONN_STATE_CLIENT_SENDING	or/or.h	/^#define DIR_CONN_STATE_CLIENT_SENDING /;"	d
DIR_CONN_STATE_CONNECTING	or/or.h	/^#define DIR_CONN_STATE_CONNECTING /;"	d
DIR_CONN_STATE_SERVER_COMMAND_WAIT	or/or.h	/^#define DIR_CONN_STATE_SERVER_COMMAND_WAIT /;"	d
DIR_CONN_STATE_SERVER_WRITING	or/or.h	/^#define DIR_CONN_STATE_SERVER_WRITING /;"	d
DIR_ENTRY_RECORD_USAGE_RETAIN_IPS	or/or.h	/^#define DIR_ENTRY_RECORD_USAGE_RETAIN_IPS /;"	d
DIR_LEGACY	test/test_dir.c	/^#define DIR_LEGACY(/;"	d	file:
DIR_PURPOSE_FETCH_CERTIFICATE	or/or.h	/^#define DIR_PURPOSE_FETCH_CERTIFICATE /;"	d
DIR_PURPOSE_FETCH_CONSENSUS	or/or.h	/^#define DIR_PURPOSE_FETCH_CONSENSUS /;"	d
DIR_PURPOSE_FETCH_DETACHED_SIGNATURES	or/or.h	/^#define DIR_PURPOSE_FETCH_DETACHED_SIGNATURES /;"	d
DIR_PURPOSE_FETCH_EXTRAINFO	or/or.h	/^#define DIR_PURPOSE_FETCH_EXTRAINFO /;"	d
DIR_PURPOSE_FETCH_MICRODESC	or/or.h	/^#define DIR_PURPOSE_FETCH_MICRODESC /;"	d
DIR_PURPOSE_FETCH_RENDDESC	or/or.h	/^#define DIR_PURPOSE_FETCH_RENDDESC /;"	d
DIR_PURPOSE_FETCH_RENDDESC_V2	or/or.h	/^#define DIR_PURPOSE_FETCH_RENDDESC_V2 /;"	d
DIR_PURPOSE_FETCH_SERVERDESC	or/or.h	/^#define DIR_PURPOSE_FETCH_SERVERDESC /;"	d
DIR_PURPOSE_FETCH_STATUS_VOTE	or/or.h	/^#define DIR_PURPOSE_FETCH_STATUS_VOTE /;"	d
DIR_PURPOSE_FETCH_V2_NETWORKSTATUS	or/or.h	/^#define DIR_PURPOSE_FETCH_V2_NETWORKSTATUS /;"	d
DIR_PURPOSE_HAS_FETCHED_RENDDESC	or/or.h	/^#define DIR_PURPOSE_HAS_FETCHED_RENDDESC /;"	d
DIR_PURPOSE_IS_UPLOAD	or/or.h	/^#define DIR_PURPOSE_IS_UPLOAD(/;"	d
DIR_PURPOSE_SERVER	or/or.h	/^#define DIR_PURPOSE_SERVER /;"	d
DIR_PURPOSE_UPLOAD_DIR	or/or.h	/^#define DIR_PURPOSE_UPLOAD_DIR /;"	d
DIR_PURPOSE_UPLOAD_RENDDESC	or/or.h	/^#define DIR_PURPOSE_UPLOAD_RENDDESC /;"	d
DIR_PURPOSE_UPLOAD_RENDDESC_V2	or/or.h	/^#define DIR_PURPOSE_UPLOAD_RENDDESC_V2 /;"	d
DIR_PURPOSE_UPLOAD_SIGNATURES	or/or.h	/^#define DIR_PURPOSE_UPLOAD_SIGNATURES /;"	d
DIR_PURPOSE_UPLOAD_VOTE	or/or.h	/^#define DIR_PURPOSE_UPLOAD_VOTE /;"	d
DIR_RECORD_USAGE_GRANULARITY	or/or.h	/^#define DIR_RECORD_USAGE_GRANULARITY /;"	d
DIR_RECORD_USAGE_MIN_OBSERVATION_TIME	or/or.h	/^#define DIR_RECORD_USAGE_MIN_OBSERVATION_TIME /;"	d
DIR_REGEN_SLACK_TIME	or/dirserv.c	/^#define DIR_REGEN_SLACK_TIME /;"	d	file:
DIR_REQ_GRANULARITY	or/geoip.c	/^#define DIR_REQ_GRANULARITY /;"	d	file:
DIR_SPOOL_CACHED_DIR	or/or.h	/^    DIR_SPOOL_CACHED_DIR, DIR_SPOOL_NETWORKSTATUS,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_EXTRA_BY_DIGEST	or/or.h	/^    DIR_SPOOL_EXTRA_BY_DIGEST, DIR_SPOOL_EXTRA_BY_FP,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_EXTRA_BY_FP	or/or.h	/^    DIR_SPOOL_EXTRA_BY_DIGEST, DIR_SPOOL_EXTRA_BY_FP,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_MICRODESC	or/or.h	/^    DIR_SPOOL_MICRODESC, \/* NOTE: if we add another entry, add another bit. *\/$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_NETWORKSTATUS	or/or.h	/^    DIR_SPOOL_CACHED_DIR, DIR_SPOOL_NETWORKSTATUS,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_NONE	or/or.h	/^    DIR_SPOOL_NONE=0, DIR_SPOOL_SERVER_BY_DIGEST, DIR_SPOOL_SERVER_BY_FP,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_SERVER_BY_DIGEST	or/or.h	/^    DIR_SPOOL_NONE=0, DIR_SPOOL_SERVER_BY_DIGEST, DIR_SPOOL_SERVER_BY_FP,$/;"	e	enum:dir_connection_t::__anon37
DIR_SPOOL_SERVER_BY_FP	or/or.h	/^    DIR_SPOOL_NONE=0, DIR_SPOOL_SERVER_BY_DIGEST, DIR_SPOOL_SERVER_BY_FP,$/;"	e	enum:dir_connection_t::__anon37
DISABLED	test/test.c	/^#define DISABLED(/;"	d	file:
DISABLE_ENGINES	common/aes.c	/^#define DISABLE_ENGINES$/;"	d	file:
DISABLE_ENGINES	common/crypto.c	/^#define DISABLE_ENGINES$/;"	d	file:
DISABLE_SSL3_HANDSHAKE	common/tortls.c	/^#define DISABLE_SSL3_HANDSHAKE$/;"	d	file:
DL_SCHED_BRIDGE	or/or.h	/^  DL_SCHED_BRIDGE = 2,$/;"	e	enum:__anon40
DL_SCHED_CONSENSUS	or/or.h	/^  DL_SCHED_CONSENSUS = 1,$/;"	e	enum:__anon40
DL_SCHED_GENERIC	or/or.h	/^  DL_SCHED_GENERIC = 0,$/;"	e	enum:__anon40
DMALLOC_ARGS	common/util.h	/^#define DMALLOC_ARGS /;"	d
DMALLOC_ARGS	common/util.h	/^#define DMALLOC_ARGS$/;"	d
DMALLOC_FN_ARGS	common/util.c	/^ #define DMALLOC_FN_ARGS /;"	d	file:
DMALLOC_FN_ARGS	common/util.c	/^ #define DMALLOC_FN_ARGS$/;"	d	file:
DMALLOC_PARAMS	common/util.h	/^#define DMALLOC_PARAMS /;"	d
DMALLOC_PARAMS	common/util.h	/^#define DMALLOC_PARAMS$/;"	d
DNSListenAddress	or/or.h	/^  config_line_t *DNSListenAddress;$/;"	m	struct:__anon49
DNSPort	or/or.h	/^  config_line_t *DNSPort; \/**< Port to listen on for DNS requests. *\/$/;"	m	struct:__anon49
DNS_ERR_FORMAT	or/eventdns.h	/^#define DNS_ERR_FORMAT /;"	d
DNS_ERR_NONE	or/eventdns.h	/^#define DNS_ERR_NONE /;"	d
DNS_ERR_NOTEXIST	or/eventdns.h	/^#define DNS_ERR_NOTEXIST /;"	d
DNS_ERR_NOTIMPL	or/eventdns.h	/^#define DNS_ERR_NOTIMPL /;"	d
DNS_ERR_REFUSED	or/eventdns.h	/^#define DNS_ERR_REFUSED /;"	d
DNS_ERR_SERVERFAILED	or/eventdns.h	/^#define DNS_ERR_SERVERFAILED /;"	d
DNS_ERR_SHUTDOWN	or/eventdns.h	/^#define DNS_ERR_SHUTDOWN /;"	d
DNS_ERR_TIMEOUT	or/eventdns.h	/^#define DNS_ERR_TIMEOUT /;"	d
DNS_ERR_TRUNCATED	or/eventdns.h	/^#define DNS_ERR_TRUNCATED /;"	d
DNS_ERR_UNKNOWN	or/eventdns.h	/^#define DNS_ERR_UNKNOWN /;"	d
DNS_IPv4_A	or/eventdns.h	/^#define DNS_IPv4_A /;"	d
DNS_IPv6_AAAA	or/eventdns.h	/^#define DNS_IPv6_AAAA /;"	d
DNS_NO_SEARCH	or/eventdns.h	/^#define DNS_NO_SEARCH /;"	d
DNS_OPTIONS_ALL	or/eventdns.h	/^#define DNS_OPTIONS_ALL /;"	d
DNS_OPTION_MISC	or/eventdns.h	/^#define DNS_OPTION_MISC /;"	d
DNS_OPTION_NAMESERVERS	or/eventdns.h	/^#define DNS_OPTION_NAMESERVERS /;"	d
DNS_OPTION_SEARCH	or/eventdns.h	/^#define DNS_OPTION_SEARCH /;"	d
DNS_PTR	or/eventdns.h	/^#define DNS_PTR /;"	d
DNS_QUERY_NO_SEARCH	or/eventdns.h	/^#define DNS_QUERY_NO_SEARCH /;"	d
DNS_RESOLVE_FAILED_PERMANENT	or/dns.c	/^#define DNS_RESOLVE_FAILED_PERMANENT /;"	d	file:
DNS_RESOLVE_FAILED_TRANSIENT	or/dns.c	/^#define DNS_RESOLVE_FAILED_TRANSIENT /;"	d	file:
DNS_RESOLVE_SUCCEEDED	or/dns.c	/^#define DNS_RESOLVE_SUCCEEDED /;"	d	file:
DNS_USE_OPENSSL_FOR_ID	or/eventdns_tor.h	/^#define DNS_USE_OPENSSL_FOR_ID$/;"	d
DOC	or/control.c	/^#define DOC(/;"	d	file:
DOWNCAST	or/or.h	/^#define DOWNCAST(/;"	d
DSR_BASE64	or/directory.h	/^#define DSR_BASE64 /;"	d
DSR_DIGEST256	or/directory.h	/^#define DSR_DIGEST256 /;"	d
DSR_HEX	or/directory.h	/^#define DSR_HEX /;"	d
DSR_SORT_UNIQ	or/directory.h	/^#define DSR_SORT_UNIQ /;"	d
DUMMY_DOWNLOAD_INTERVAL	or/routerlist.c	/^#define DUMMY_DOWNLOAD_INTERVAL /;"	d	file:
DUMP_AREA	or/routerparse.c	/^#define DUMP_AREA(/;"	d	file:
DataDirectory	or/or.h	/^  char *DataDirectory; \/**< OR only: where to store long-term data. *\/$/;"	m	struct:__anon49
DebugLogFile	or/or.h	/^  char *DebugLogFile; \/**< Where to send verbose log messages. *\/$/;"	m	struct:__anon49
DeleteService_fn	or/ntmain.c	/^  BOOL (WINAPI *DeleteService_fn)($/;"	m	struct:service_fns	file:
DirAllowPrivateAddresses	or/or.h	/^  int DirAllowPrivateAddresses;$/;"	m	struct:__anon49
DirListenAddress	or/or.h	/^  config_line_t *DirListenAddress;$/;"	m	struct:__anon49
DirPolicy	or/or.h	/^  config_line_t *DirPolicy; \/**< Lists of dir policy components *\/$/;"	m	struct:__anon49
DirPort	or/or.h	/^  config_line_t *DirPort; \/**< Port to listen on for directory connections. *\/$/;"	m	struct:__anon49
DirPortFrontPage	or/or.h	/^  char *DirPortFrontPage; \/**< This is a full path to a file with an html$/;"	m	struct:__anon49
DirReqStatistics	or/or.h	/^  int DirReqStatistics;$/;"	m	struct:__anon49
DirServers	or/or.h	/^  config_line_t *DirServers;$/;"	m	struct:__anon49
DisableAllSwap	or/or.h	/^  int DisableAllSwap; \/**< Boolean: Attempt to call mlockall() on our$/;"	m	struct:__anon49
DisableDebuggerAttachment	or/or.h	/^  int DisableDebuggerAttachment; \/**< Currently Linux only specific attempt to$/;"	m	struct:__anon49
DisableIOCP	or/or.h	/^  int DisableIOCP;$/;"	m	struct:__anon49
DisableNetwork	or/or.h	/^  int DisableNetwork;$/;"	m	struct:__anon49
DisablePredictedCircuits	or/or.h	/^  int DisablePredictedCircuits; \/**< Boolean: does Tor preemptively$/;"	m	struct:__anon49
DownloadExtraInfo	or/or.h	/^  int DownloadExtraInfo;$/;"	m	struct:__anon49
DynamicDHGroups	or/or.h	/^  int DynamicDHGroups; \/**< Dynamic generation of prime moduli for use in DH.*\/$/;"	m	struct:__anon49
E	common/compat.c	/^#define E(/;"	d	file:
EARLY_CONSENSUS_NOTICE_SKEW	or/networkstatus.c	/^#define EARLY_CONSENSUS_NOTICE_SKEW /;"	d	file:
EARLY_WARNING_INTERVAL	or/relay.c	/^#define EARLY_WARNING_INTERVAL /;"	d	file:
EDGE_CONNECTION_MAGIC	or/or.h	/^#define EDGE_CONNECTION_MAGIC /;"	d
EDGE_TO_ENTRY_CONN	or/or.h	/^static INLINE entry_connection_t *EDGE_TO_ENTRY_CONN(edge_connection_t *c)$/;"	f
EIMAP_FOREACH	or/routerlist.c	/^#define EIMAP_FOREACH(/;"	d	file:
ELSE_IF_NO_BUFFEREVENT	or/or.h	/^#define ELSE_IF_NO_BUFFEREVENT /;"	d
ENABLE_THREADS	win32/orconfig.h	/^#define ENABLE_THREADS$/;"	d
ENC_ONIONSKIN	or/or.h	/^  ENC_ONIONSKIN, DEC_ONIONSKIN,$/;"	e	enum:__anon65
END_CIRC_AT_ORIGIN	or/or.h	/^#define END_CIRC_AT_ORIGIN /;"	d
END_CIRC_REASON_CONNECTFAILED	or/or.h	/^#define END_CIRC_REASON_CONNECTFAILED /;"	d
END_CIRC_REASON_DESTROYED	or/or.h	/^#define END_CIRC_REASON_DESTROYED /;"	d
END_CIRC_REASON_FINISHED	or/or.h	/^#define END_CIRC_REASON_FINISHED /;"	d
END_CIRC_REASON_FLAG_REMOTE	or/or.h	/^#define END_CIRC_REASON_FLAG_REMOTE /;"	d
END_CIRC_REASON_HIBERNATING	or/or.h	/^#define END_CIRC_REASON_HIBERNATING /;"	d
END_CIRC_REASON_INTERNAL	or/or.h	/^#define END_CIRC_REASON_INTERNAL /;"	d
END_CIRC_REASON_MEASUREMENT_EXPIRED	or/or.h	/^#define END_CIRC_REASON_MEASUREMENT_EXPIRED /;"	d
END_CIRC_REASON_NONE	or/or.h	/^#define END_CIRC_REASON_NONE /;"	d
END_CIRC_REASON_NOPATH	or/or.h	/^#define END_CIRC_REASON_NOPATH /;"	d
END_CIRC_REASON_NOSUCHSERVICE	or/or.h	/^#define END_CIRC_REASON_NOSUCHSERVICE /;"	d
END_CIRC_REASON_OR_CONN_CLOSED	or/or.h	/^#define END_CIRC_REASON_OR_CONN_CLOSED /;"	d
END_CIRC_REASON_OR_IDENTITY	or/or.h	/^#define END_CIRC_REASON_OR_IDENTITY /;"	d
END_CIRC_REASON_REQUESTED	or/or.h	/^#define END_CIRC_REASON_REQUESTED /;"	d
END_CIRC_REASON_RESOURCELIMIT	or/or.h	/^#define END_CIRC_REASON_RESOURCELIMIT /;"	d
END_CIRC_REASON_TIMEOUT	or/or.h	/^#define END_CIRC_REASON_TIMEOUT /;"	d
END_CIRC_REASON_TORPROTOCOL	or/or.h	/^#define END_CIRC_REASON_TORPROTOCOL /;"	d
END_OF_GROUPS	test/tinytest.h	/^#define END_OF_GROUPS /;"	d
END_OF_TABLE	or/routerparse.c	/^#define END_OF_TABLE /;"	d	file:
END_OF_TESTCASES	test/tinytest.h	/^#define END_OF_TESTCASES /;"	d
END_OR_CONN_REASON_CONNRESET	or/or.h	/^#define END_OR_CONN_REASON_CONNRESET /;"	d
END_OR_CONN_REASON_DONE	or/or.h	/^#define END_OR_CONN_REASON_DONE /;"	d
END_OR_CONN_REASON_IO_ERROR	or/or.h	/^#define END_OR_CONN_REASON_IO_ERROR /;"	d
END_OR_CONN_REASON_MISC	or/or.h	/^#define END_OR_CONN_REASON_MISC /;"	d
END_OR_CONN_REASON_NO_ROUTE	or/or.h	/^#define END_OR_CONN_REASON_NO_ROUTE /;"	d
END_OR_CONN_REASON_OR_IDENTITY	or/or.h	/^#define END_OR_CONN_REASON_OR_IDENTITY /;"	d
END_OR_CONN_REASON_REFUSED	or/or.h	/^#define END_OR_CONN_REASON_REFUSED /;"	d
END_OR_CONN_REASON_RESOURCE_LIMIT	or/or.h	/^#define END_OR_CONN_REASON_RESOURCE_LIMIT /;"	d
END_OR_CONN_REASON_TIMEOUT	or/or.h	/^#define END_OR_CONN_REASON_TIMEOUT /;"	d
END_STREAM_REASON_CANT_ATTACH	or/or.h	/^#define END_STREAM_REASON_CANT_ATTACH /;"	d
END_STREAM_REASON_CANT_FETCH_ORIG_DEST	or/or.h	/^#define END_STREAM_REASON_CANT_FETCH_ORIG_DEST /;"	d
END_STREAM_REASON_CONNECTREFUSED	or/or.h	/^#define END_STREAM_REASON_CONNECTREFUSED /;"	d
END_STREAM_REASON_CONNRESET	or/or.h	/^#define END_STREAM_REASON_CONNRESET /;"	d
END_STREAM_REASON_DESTROY	or/or.h	/^#define END_STREAM_REASON_DESTROY /;"	d
END_STREAM_REASON_DONE	or/or.h	/^#define END_STREAM_REASON_DONE /;"	d
END_STREAM_REASON_ENTRYPOLICY	or/or.h	/^#define END_STREAM_REASON_ENTRYPOLICY /;"	d
END_STREAM_REASON_EXITPOLICY	or/or.h	/^#define END_STREAM_REASON_EXITPOLICY /;"	d
END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED	or/or.h	/^#define END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED /;"	d
END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED	or/or.h	/^#define END_STREAM_REASON_FLAG_ALREADY_SOCKS_REPLIED /;"	d
END_STREAM_REASON_FLAG_REMOTE	or/or.h	/^#define END_STREAM_REASON_FLAG_REMOTE /;"	d
END_STREAM_REASON_HIBERNATING	or/or.h	/^#define END_STREAM_REASON_HIBERNATING /;"	d
END_STREAM_REASON_INTERNAL	or/or.h	/^#define END_STREAM_REASON_INTERNAL /;"	d
END_STREAM_REASON_INVALID_NATD_DEST	or/or.h	/^#define END_STREAM_REASON_INVALID_NATD_DEST /;"	d
END_STREAM_REASON_MASK	or/or.h	/^#define END_STREAM_REASON_MASK /;"	d
END_STREAM_REASON_MISC	or/or.h	/^#define END_STREAM_REASON_MISC /;"	d
END_STREAM_REASON_NET_UNREACHABLE	or/or.h	/^#define END_STREAM_REASON_NET_UNREACHABLE /;"	d
END_STREAM_REASON_NOROUTE	or/or.h	/^#define END_STREAM_REASON_NOROUTE /;"	d
END_STREAM_REASON_NOTDIRECTORY	or/or.h	/^#define END_STREAM_REASON_NOTDIRECTORY /;"	d
END_STREAM_REASON_PRIVATE_ADDR	or/or.h	/^#define END_STREAM_REASON_PRIVATE_ADDR /;"	d
END_STREAM_REASON_RESOLVEFAILED	or/or.h	/^#define END_STREAM_REASON_RESOLVEFAILED /;"	d
END_STREAM_REASON_RESOURCELIMIT	or/or.h	/^#define END_STREAM_REASON_RESOURCELIMIT /;"	d
END_STREAM_REASON_SOCKSPROTOCOL	or/or.h	/^#define END_STREAM_REASON_SOCKSPROTOCOL /;"	d
END_STREAM_REASON_TIMEOUT	or/or.h	/^#define END_STREAM_REASON_TIMEOUT /;"	d
END_STREAM_REASON_TORPROTOCOL	or/or.h	/^#define END_STREAM_REASON_TORPROTOCOL /;"	d
ENT	test/bench.c	/^#define ENT(/;"	d	file:
ENT	test/test.c	/^#define ENT(/;"	d	file:
ENTROPY_INTERVAL	or/main.c	/^#define ENTROPY_INTERVAL /;"	d	file:
ENTRY	test/test_containers.c	/^#define ENTRY(/;"	d	file:
ENTRY_CONNECTION_MAGIC	or/or.h	/^#define ENTRY_CONNECTION_MAGIC /;"	d
ENTRY_GUARD_REMOVE_AFTER	or/circuitbuild.c	/^#define ENTRY_GUARD_REMOVE_AFTER /;"	d	file:
ENTRY_TO_CONN	or/or.h	/^#define ENTRY_TO_CONN(/;"	d
ENTRY_TO_EDGE_CONN	or/or.h	/^#define ENTRY_TO_EDGE_CONN(/;"	d
ENVIRON_SIZE_CLIENT	or/transports.c	/^#define ENVIRON_SIZE_CLIENT /;"	d	file:
ENVIRON_SIZE_SERVER	or/transports.c	/^#define ENVIRON_SIZE_SERVER /;"	d	file:
EPOCH_BIAS	common/compat.c	/^#define EPOCH_BIAS /;"	d	file:
EPSILON	or/relay.c	/^#define EPSILON /;"	d	file:
EQ	or/routerparse.c	/^#define EQ(/;"	d	file:
EQ	test/test_util.c	/^#define EQ /;"	d	file:
ERR	or/command.c	/^#define ERR(/;"	d	file:
ERR	or/command.c	/^#undef ERR$/;"	d	file:
ERRNO_IS_ACCEPT_EAGAIN	common/compat.h	/^#define ERRNO_IS_ACCEPT_EAGAIN(/;"	d
ERRNO_IS_ACCEPT_RESOURCE_LIMIT	common/compat.h	/^#define ERRNO_IS_ACCEPT_RESOURCE_LIMIT(/;"	d
ERRNO_IS_CONN_EINPROGRESS	common/compat.h	/^#define ERRNO_IS_CONN_EINPROGRESS(/;"	d
ERRNO_IS_EADDRINUSE	common/compat.h	/^#define ERRNO_IS_EADDRINUSE(/;"	d
ERRNO_IS_EAGAIN	common/compat.h	/^#define ERRNO_IS_EAGAIN(/;"	d
ERRNO_IS_EINPROGRESS	common/compat.h	/^#define ERRNO_IS_EINPROGRESS(/;"	d
EVDNS_ADDITIONAL_SECTION	or/eventdns.h	/^#define EVDNS_ADDITIONAL_SECTION /;"	d
EVDNS_ANSWER_SECTION	or/eventdns.h	/^#define EVDNS_ANSWER_SECTION /;"	d
EVDNS_AUTHORITY_SECTION	or/eventdns.h	/^#define EVDNS_AUTHORITY_SECTION /;"	d
EVDNS_CLASS_INET	or/eventdns.h	/^#define EVDNS_CLASS_INET /;"	d
EVDNS_LOG_CHECK	or/eventdns.c	/^#define EVDNS_LOG_CHECK	/;"	d	file:
EVDNS_LOG_CHECK	or/eventdns.c	/^#define EVDNS_LOG_CHECK$/;"	d	file:
EVDNS_LOG_DEBUG	or/eventdns.c	/^#define EVDNS_LOG_DEBUG /;"	d	file:
EVDNS_LOG_WARN	or/eventdns.c	/^#define EVDNS_LOG_WARN /;"	d	file:
EVDNS_QTYPE_ALL	or/eventdns.h	/^#define EVDNS_QTYPE_ALL	/;"	d
EVDNS_QTYPE_AXFR	or/eventdns.h	/^#define EVDNS_QTYPE_AXFR /;"	d
EVDNS_TYPE_A	or/eventdns.h	/^#define EVDNS_TYPE_A	/;"	d
EVDNS_TYPE_AAAA	or/eventdns.h	/^#define EVDNS_TYPE_AAAA	/;"	d
EVDNS_TYPE_CNAME	or/eventdns.h	/^#define EVDNS_TYPE_CNAME /;"	d
EVDNS_TYPE_MX	or/eventdns.h	/^#define EVDNS_TYPE_MX	/;"	d
EVDNS_TYPE_NS	or/eventdns.h	/^#define EVDNS_TYPE_NS	/;"	d
EVDNS_TYPE_PTR	or/eventdns.h	/^#define EVDNS_TYPE_PTR	/;"	d
EVDNS_TYPE_SOA	or/eventdns.h	/^#define EVDNS_TYPE_SOA	/;"	d
EVDNS_TYPE_TXT	or/eventdns.h	/^#define EVDNS_TYPE_TXT	/;"	d
EVENT_ADDRMAP	or/control.c	/^#define EVENT_ADDRMAP /;"	d	file:
EVENT_AUTHDIR_NEWDESCS	or/control.h	/^#define EVENT_AUTHDIR_NEWDESCS /;"	d
EVENT_BANDWIDTH_USED	or/control.c	/^#define EVENT_BANDWIDTH_USED /;"	d	file:
EVENT_BUILDTIMEOUT_SET	or/control.c	/^#define EVENT_BUILDTIMEOUT_SET /;"	d	file:
EVENT_CIRCUIT_STATUS	or/control.c	/^#define EVENT_CIRCUIT_STATUS /;"	d	file:
EVENT_CIRCUIT_STATUS_MINOR	or/control.c	/^#define EVENT_CIRCUIT_STATUS_MINOR /;"	d	file:
EVENT_CLIENTS_SEEN	or/control.c	/^#define EVENT_CLIENTS_SEEN /;"	d	file:
EVENT_CONF_CHANGED	or/control.c	/^#define EVENT_CONF_CHANGED /;"	d	file:
EVENT_DEBUG_MSG	or/control.c	/^#define EVENT_DEBUG_MSG /;"	d	file:
EVENT_DESCCHANGED	or/control.c	/^#define EVENT_DESCCHANGED /;"	d	file:
EVENT_ERR_MSG	or/control.c	/^#define EVENT_ERR_MSG /;"	d	file:
EVENT_GUARD	or/control.c	/^#define EVENT_GUARD /;"	d	file:
EVENT_INFO_MSG	or/control.c	/^#define EVENT_INFO_MSG /;"	d	file:
EVENT_IS_INTERESTING	or/control.c	/^#define EVENT_IS_INTERESTING(/;"	d	file:
EVENT_NEWCONSENSUS	or/control.c	/^#define EVENT_NEWCONSENSUS /;"	d	file:
EVENT_NEW_DESC	or/control.c	/^#define EVENT_NEW_DESC /;"	d	file:
EVENT_NOTICE_MSG	or/control.c	/^#define EVENT_NOTICE_MSG /;"	d	file:
EVENT_NS	or/control.h	/^#define EVENT_NS /;"	d
EVENT_OR_CONN_STATUS	or/control.c	/^#define EVENT_OR_CONN_STATUS /;"	d	file:
EVENT_SIGNAL	or/control.c	/^#define EVENT_SIGNAL /;"	d	file:
EVENT_STATUS_CLIENT	or/control.c	/^#define EVENT_STATUS_CLIENT /;"	d	file:
EVENT_STATUS_GENERAL	or/control.c	/^#define EVENT_STATUS_GENERAL /;"	d	file:
EVENT_STATUS_SERVER	or/control.c	/^#define EVENT_STATUS_SERVER /;"	d	file:
EVENT_STREAM_BANDWIDTH_USED	or/control.c	/^#define EVENT_STREAM_BANDWIDTH_USED /;"	d	file:
EVENT_STREAM_STATUS	or/control.c	/^#define EVENT_STREAM_STATUS /;"	d	file:
EVENT_WARN_MSG	or/control.c	/^#define EVENT_WARN_MSG /;"	d	file:
EVUTIL_SOCKET_DEFINED	common/compat_libevent.h	/^#define EVUTIL_SOCKET_DEFINED$/;"	d
EWMA_DEFAULT_HALFLIFE	or/relay.c	/^#define EWMA_DEFAULT_HALFLIFE /;"	d	file:
EWMA_TICK_LEN	or/relay.c	/^#define EWMA_TICK_LEN /;"	d	file:
EXIT_CONN_STATE_CONNECTING	or/or.h	/^#define EXIT_CONN_STATE_CONNECTING /;"	d
EXIT_CONN_STATE_OPEN	or/or.h	/^#define EXIT_CONN_STATE_OPEN /;"	d
EXIT_CONN_STATE_RESOLVEFAILED	or/or.h	/^#define EXIT_CONN_STATE_RESOLVEFAILED /;"	d
EXIT_CONN_STATE_RESOLVING	or/or.h	/^#define EXIT_CONN_STATE_RESOLVING /;"	d
EXIT_HOSTNAME	or/connection_edge.h	/^  NORMAL_HOSTNAME, ONION_HOSTNAME, EXIT_HOSTNAME, BAD_HOSTNAME$/;"	e	enum:hostname_type_t
EXIT_PURPOSE_CONNECT	or/or.h	/^#define EXIT_PURPOSE_CONNECT /;"	d
EXIT_PURPOSE_RESOLVE	or/or.h	/^#define EXIT_PURPOSE_RESOLVE /;"	d
EXIT_STATS_NUM_PORTS	or/rephist.c	/^#define EXIT_STATS_NUM_PORTS /;"	d	file:
EXIT_STATS_ROUND_UP_BYTES	or/rephist.c	/^#define EXIT_STATS_ROUND_UP_BYTES /;"	d	file:
EXIT_STATS_ROUND_UP_STREAMS	or/rephist.c	/^#define EXIT_STATS_ROUND_UP_STREAMS /;"	d	file:
EXIT_STATS_TOP_N_PORTS	or/rephist.c	/^#define EXIT_STATS_TOP_N_PORTS /;"	d	file:
EXPBIAS	common/crypto.c	/^#define EXPBIAS /;"	d	file:
EXPBIAS	common/crypto.c	/^#undef EXPBIAS$/;"	d	file:
EXTRAINFO_DIRINFO	or/or.h	/^  EXTRAINFO_DIRINFO=1 << 5,$/;"	e	enum:__anon45
EXTRAINFO_STORE	or/or.h	/^  EXTRAINFO_STORE = 1$/;"	e	enum:store_type_t
E_CASE	or/reasons.c	/^#define E_CASE(/;"	d	file:
EnforceDistinctSubnets	or/or.h	/^  int EnforceDistinctSubnets; \/**< If true, don't allow multiple routers in the$/;"	m	struct:__anon49
EntryGuards	or/or.h	/^  config_line_t *EntryGuards;$/;"	m	struct:__anon52
EntryNodes	or/or.h	/^  routerset_t *EntryNodes;\/**< Structure containing nicknames, digests,$/;"	m	struct:__anon49
EntryStatistics	or/or.h	/^  int EntryStatistics;$/;"	m	struct:__anon49
ExcludeExitNodes	or/or.h	/^  routerset_t *ExcludeExitNodes;\/**< Structure containing nicknames, digests,$/;"	m	struct:__anon49
ExcludeNodes	or/or.h	/^  routerset_t *ExcludeNodes;\/**< Structure containing nicknames, digests,$/;"	m	struct:__anon49
ExcludeSingleHopRelays	or/or.h	/^  int ExcludeSingleHopRelays;$/;"	m	struct:__anon49
ExitNodes	or/or.h	/^  routerset_t *ExitNodes; \/**< Structure containing nicknames, digests,$/;"	m	struct:__anon49
ExitPolicy	or/or.h	/^  config_line_t *ExitPolicy; \/**< Lists of exit policy components. *\/$/;"	m	struct:__anon49
ExitPolicyRejectPrivate	or/or.h	/^  int ExitPolicyRejectPrivate; \/**< Should we not exit to local addresses? *\/$/;"	m	struct:__anon49
ExitPortStatistics	or/or.h	/^  int ExitPortStatistics;$/;"	m	struct:__anon49
ExtraInfoStatistics	or/or.h	/^  int ExtraInfoStatistics;$/;"	m	struct:__anon49
ExtraLines	or/or.h	/^  config_line_t *ExtraLines;$/;"	m	struct:__anon52
FAIL	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
FAST_RETRY_DESCRIPTOR_INTERVAL	or/router.c	/^#define FAST_RETRY_DESCRIPTOR_INTERVAL /;"	d	file:
FINGERPRINT_LEN	common/crypto.h	/^#define FINGERPRINT_LEN /;"	d
FL	or/buffers.c	/^#define FL(/;"	d	file:
FL	or/buffers.c	/^#undef FL$/;"	d	file:
FLAV_MICRODESC	or/or.h	/^  FLAV_MICRODESC = 1,$/;"	e	enum:__anon43
FLAV_NS	or/or.h	/^  FLAV_NS = 0,$/;"	e	enum:__anon43
FLEXIBLE_ARRAY_MEMBER	win32/orconfig.h	/^#define FLEXIBLE_ARRAY_MEMBER /;"	d
FN_DIR	common/util.h	/^typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR } file_status_t;$/;"	e	enum:__anon17
FN_ERROR	common/util.h	/^typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR } file_status_t;$/;"	e	enum:__anon17
FN_FILE	common/util.h	/^typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR } file_status_t;$/;"	e	enum:__anon17
FN_NOENT	common/util.h	/^typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR } file_status_t;$/;"	e	enum:__anon17
FORCE_REGENERATE_DESCRIPTOR_INTERVAL	or/router.c	/^#define FORCE_REGENERATE_DESCRIPTOR_INTERVAL /;"	d	file:
FORK	test/test.c	/^#define FORK(/;"	d	file:
FP_BADDIR	or/dirserv.c	/^#define FP_BADDIR /;"	d	file:
FP_BADEXIT	or/dirserv.c	/^#define FP_BADEXIT /;"	d	file:
FP_INVALID	or/dirserv.c	/^#define FP_INVALID /;"	d	file:
FP_NAMED	or/dirserv.c	/^#define FP_NAMED /;"	d	file:
FP_REJECT	or/dirserv.c	/^#define FP_REJECT /;"	d	file:
FP_UNNAMED	or/dirserv.c	/^#define FP_UNNAMED /;"	d	file:
FREE	common/mempool.c	/^#define FREE(/;"	d	file:
FULL_DIR_CACHE_LIFETIME	or/directory.c	/^#define FULL_DIR_CACHE_LIFETIME /;"	d	file:
FallbackNetworkstatusFile	or/or.h	/^  char *FallbackNetworkstatusFile;$/;"	m	struct:__anon49
FascistFirewall	or/or.h	/^  int FascistFirewall; \/**< Whether to prefer ORs reachable on open ports. *\/$/;"	m	struct:__anon49
FastFirstHopPK	or/or.h	/^  int FastFirstHopPK; \/**< If Tor believes it is safe, should we save a third$/;"	m	struct:__anon49
FetchDirInfoEarly	or/or.h	/^  int FetchDirInfoEarly;$/;"	m	struct:__anon49
FetchDirInfoExtraEarly	or/or.h	/^  int FetchDirInfoExtraEarly;$/;"	m	struct:__anon49
FetchHidServDescriptors	or/or.h	/^  int FetchHidServDescriptors; \/**< and hidden service descriptors? *\/$/;"	m	struct:__anon49
FetchServerDescriptors	or/or.h	/^  int FetchServerDescriptors; \/**< Do we fetch server descriptors as normal? *\/$/;"	m	struct:__anon49
FetchUselessDescriptors	or/or.h	/^  int FetchUselessDescriptors; \/**< Do we fetch non-running descriptors too? *\/$/;"	m	struct:__anon49
FetchV2Networkstatus	or/or.h	/^  int FetchV2Networkstatus; \/**< Do we fetch v2 networkstatus documents when$/;"	m	struct:__anon49
FirewallPorts	or/or.h	/^  smartlist_t *FirewallPorts; \/**< Which ports our firewall allows$/;"	m	struct:__anon49
GE	or/routerparse.c	/^#define GE(/;"	d	file:
GENERATED_FILE_COMMENT	or/config.c	/^#define GENERATED_FILE_COMMENT /;"	d	file:
GENERATED_FILE_PREFIX	or/config.c	/^#define GENERATED_FILE_PREFIX /;"	d	file:
GENSRV_DESCRIPTION	or/ntmain.c	/^#define GENSRV_DESCRIPTION /;"	d	file:
GENSRV_DISPLAYNAME	or/ntmain.c	/^#define GENSRV_DISPLAYNAME /;"	d	file:
GENSRV_SERVICENAME	or/ntmain.c	/^#define GENSRV_SERVICENAME /;"	d	file:
GENSRV_USERACCT	or/ntmain.c	/^#define GENSRV_USERACCT /;"	d	file:
GEOIP_CLIENT_CONNECT	or/or.h	/^  GEOIP_CLIENT_CONNECT = 0,$/;"	e	enum:__anon59
GEOIP_CLIENT_NETWORKSTATUS	or/or.h	/^  GEOIP_CLIENT_NETWORKSTATUS = 1,$/;"	e	enum:__anon59
GEOIP_CLIENT_NETWORKSTATUS_V2	or/or.h	/^  GEOIP_CLIENT_NETWORKSTATUS_V2 = 2,$/;"	e	enum:__anon59
GEOIP_NS_RESPONSE_NUM	or/or.h	/^#define GEOIP_NS_RESPONSE_NUM /;"	d
GEOIP_PRIVATE	or/geoip.c	/^#define GEOIP_PRIVATE$/;"	d	file:
GEOIP_PRIVATE	test/test.c	/^#define GEOIP_PRIVATE$/;"	d	file:
GEOIP_REJECT_BUSY	or/or.h	/^  GEOIP_REJECT_BUSY = 5,$/;"	e	enum:__anon60
GEOIP_REJECT_NOT_ENOUGH_SIGS	or/or.h	/^  GEOIP_REJECT_NOT_ENOUGH_SIGS = 1,$/;"	e	enum:__anon60
GEOIP_REJECT_NOT_FOUND	or/or.h	/^  GEOIP_REJECT_NOT_FOUND = 3,$/;"	e	enum:__anon60
GEOIP_REJECT_NOT_MODIFIED	or/or.h	/^  GEOIP_REJECT_NOT_MODIFIED = 4,$/;"	e	enum:__anon60
GEOIP_REJECT_UNAVAILABLE	or/or.h	/^  GEOIP_REJECT_UNAVAILABLE = 2,$/;"	e	enum:__anon60
GEOIP_SUCCESS	or/or.h	/^  GEOIP_SUCCESS = 0,$/;"	e	enum:__anon60
GET16	or/eventdns.c	/^#define GET16(/;"	d	file:
GET16	or/eventdns.c	/^#undef GET16$/;"	d	file:
GET32	or/eventdns.c	/^#define GET32(/;"	d	file:
GET32	or/eventdns.c	/^#undef GET32$/;"	d	file:
GET8	or/eventdns.c	/^#define GET8(/;"	d	file:
GET8	or/eventdns.c	/^#undef GET8$/;"	d	file:
GET_NAME	or/eventdns.c	/^#define GET_NAME /;"	d	file:
GREEDY_DESCRIPTOR_RETRY_INTERVAL	or/main.c	/^#define GREEDY_DESCRIPTOR_RETRY_INTERVAL /;"	d	file:
GT	test/test_util.c	/^#define GT /;"	d	file:
GUESS_TIME_TO_USE_BANDWIDTH	or/hibernate.c	/^#define GUESS_TIME_TO_USE_BANDWIDTH /;"	d	file:
GZIP_METHOD	common/torgzip.h	/^  NO_METHOD=0, GZIP_METHOD=1, ZLIB_METHOD=2, UNKNOWN_METHOD=3$/;"	e	enum:__anon14
Gamma0	common/sha256.c	/^#define Gamma0(/;"	d	file:
Gamma1	common/sha256.c	/^#define Gamma1(/;"	d	file:
GeoIPFile	or/or.h	/^  char *GeoIPFile;$/;"	m	struct:__anon49
GetAdaptersAddresses_fn_t	common/address.c	/^typedef ULONG (WINAPI *GetAdaptersAddresses_fn_t)($/;"	t	file:
GetNetworkParams_fn_t	or/eventdns.c	/^typedef DWORD(WINAPI *GetNetworkParams_fn_t)(FIXED_INFO *, DWORD*);$/;"	t	file:
GiveGuardFlagTo_CVE_2011_2768_VulnerableRelays	or/or.h	/^  int GiveGuardFlagTo_CVE_2011_2768_VulnerableRelays;$/;"	m	struct:__anon49
Group	or/or.h	/^  char *Group; \/**< Name of group to run Tor as. *\/$/;"	m	struct:__anon49
HAS_BUFFEREVENT	or/or.h	/^#define HAS_BUFFEREVENT(/;"	d
HAVE_ARPA_INET_H	win32/orconfig.h	/^#undef HAVE_ARPA_INET_H$/;"	d
HAVE_ASSERT_H	win32/orconfig.h	/^#define HAVE_ASSERT_H$/;"	d
HAVE_CTYPE_H	win32/orconfig.h	/^#define HAVE_CTYPE_H$/;"	d
HAVE_ERRNO_H	win32/orconfig.h	/^#define HAVE_ERRNO_H$/;"	d
HAVE_EVDNS_SET_DEFAULT_OUTGOING_BIND_ADDRESS	or/dns.c	/^#define HAVE_EVDNS_SET_DEFAULT_OUTGOING_BIND_ADDRESS$/;"	d	file:
HAVE_EVENT2_EVENT_H	win32/orconfig.h	/^#define HAVE_EVENT2_EVENT_H$/;"	d
HAVE_EVENT_GET_METHOD	win32/orconfig.h	/^#define HAVE_EVENT_GET_METHOD /;"	d
HAVE_EVENT_GET_VERSION	win32/orconfig.h	/^#define HAVE_EVENT_GET_VERSION /;"	d
HAVE_EVENT_H	win32/orconfig.h	/^#define HAVE_EVENT_H$/;"	d
HAVE_EVENT_SET_LOG_CALLBACK	win32/orconfig.h	/^#define HAVE_EVENT_SET_LOG_CALLBACK /;"	d
HAVE_FCNTL_H	win32/orconfig.h	/^#define HAVE_FCNTL_H$/;"	d
HAVE_FTIME	win32/orconfig.h	/^#define HAVE_FTIME$/;"	d
HAVE_GETTIMEOFDAY	win32/orconfig.h	/^#undef HAVE_GETTIMEOFDAY$/;"	d
HAVE_GRP_H	win32/orconfig.h	/^#undef HAVE_GRP_H$/;"	d
HAVE_INET_ATON	win32/orconfig.h	/^#undef HAVE_INET_ATON$/;"	d
HAVE_INT16_T	common/torint.h	/^#define HAVE_INT16_T$/;"	d
HAVE_INT32_T	common/torint.h	/^#define HAVE_INT32_T$/;"	d
HAVE_INT64_T	common/torint.h	/^#define HAVE_INT64_T$/;"	d
HAVE_INT8_T	common/torint.h	/^#define HAVE_INT8_T$/;"	d
HAVE_INTPTR_T	common/torint.h	/^#define HAVE_INTPTR_T$/;"	d
HAVE_LIMITS_H	win32/orconfig.h	/^#define HAVE_LIMITS_H$/;"	d
HAVE_MACHINE_LIMITS_H	win32/orconfig.h	/^#undef HAVE_MACHINE_LIMITS_H$/;"	d
HAVE_MEMORY_H	win32/orconfig.h	/^#define HAVE_MEMORY_H$/;"	d
HAVE_NETDB_H	win32/orconfig.h	/^#undef HAVE_NETDB_H$/;"	d
HAVE_NETINET_IN_H	win32/orconfig.h	/^#undef HAVE_NETINET_IN_H$/;"	d
HAVE_PERIODIC	common/compat_libevent.c	/^#define HAVE_PERIODIC$/;"	d	file:
HAVE_POLL_H	win32/orconfig.h	/^#undef HAVE_POLL_H$/;"	d
HAVE_PWD_H	win32/orconfig.h	/^#undef HAVE_PWD_H$/;"	d
HAVE_SIGNAL_H	win32/orconfig.h	/^#define HAVE_SIGNAL_H$/;"	d
HAVE_SOCKETPAIR	win32/orconfig.h	/^#undef HAVE_SOCKETPAIR$/;"	d
HAVE_STDINT_H	win32/orconfig.h	/^#undef HAVE_STDINT_H$/;"	d
HAVE_STDLIB_H	win32/orconfig.h	/^#define HAVE_STDLIB_H$/;"	d
HAVE_STRINGS_H	win32/orconfig.h	/^#undef HAVE_STRINGS_H$/;"	d
HAVE_STRING_H	win32/orconfig.h	/^#define HAVE_STRING_H$/;"	d
HAVE_STRLCAT	win32/orconfig.h	/^#define HAVE_STRLCAT$/;"	d
HAVE_STRLCAT	win32/orconfig.h	/^#undef HAVE_STRLCAT$/;"	d
HAVE_STRLCPY	win32/orconfig.h	/^#define HAVE_STRLCPY$/;"	d
HAVE_STRLCPY	win32/orconfig.h	/^#undef HAVE_STRLCPY$/;"	d
HAVE_STRPTIME	win32/orconfig.h	/^#undef HAVE_STRPTIME$/;"	d
HAVE_STRUCT_IN6_ADDR	win32/orconfig.h	/^#define HAVE_STRUCT_IN6_ADDR$/;"	d
HAVE_STRUCT_SOCKADDR_IN6	win32/orconfig.h	/^#define HAVE_STRUCT_SOCKADDR_IN6$/;"	d
HAVE_STRUCT_TIMEVAL_TV_SEC	win32/orconfig.h	/^#define HAVE_STRUCT_TIMEVAL_TV_SEC$/;"	d
HAVE_SYS_FCNTL_H	win32/orconfig.h	/^#undef HAVE_SYS_FCNTL_H$/;"	d
HAVE_SYS_IOCTL_H	win32/orconfig.h	/^#undef HAVE_SYS_IOCTL_H$/;"	d
HAVE_SYS_LIMITS_H	win32/orconfig.h	/^#undef HAVE_SYS_LIMITS_H$/;"	d
HAVE_SYS_POLL_H	win32/orconfig.h	/^#undef HAVE_SYS_POLL_H$/;"	d
HAVE_SYS_SOCKET_H	win32/orconfig.h	/^#undef HAVE_SYS_SOCKET_H$/;"	d
HAVE_SYS_STAT_H	win32/orconfig.h	/^#define HAVE_SYS_STAT_H$/;"	d
HAVE_SYS_TIME_H	win32/orconfig.h	/^#undef HAVE_SYS_TIME_H$/;"	d
HAVE_SYS_TYPES_H	win32/orconfig.h	/^#define HAVE_SYS_TYPES_H$/;"	d
HAVE_SYS_UTIME_H	win32/orconfig.h	/^#define HAVE_SYS_UTIME_H$/;"	d
HAVE_SYS_WAIT_H	win32/orconfig.h	/^#undef HAVE_SYS_WAIT_H$/;"	d
HAVE_TIME_H	win32/orconfig.h	/^#define HAVE_TIME_H$/;"	d
HAVE_UINT16_T	common/torint.h	/^#define HAVE_UINT16_T$/;"	d
HAVE_UINT32_T	common/torint.h	/^#define HAVE_UINT32_T$/;"	d
HAVE_UINT64_T	common/torint.h	/^#define HAVE_UINT64_T$/;"	d
HAVE_UINT8_T	common/torint.h	/^#define HAVE_UINT8_T$/;"	d
HAVE_UINTPTR_T	common/torint.h	/^#define HAVE_UINTPTR_T$/;"	d
HAVE_UNAME	win32/orconfig.h	/^#undef HAVE_UNAME$/;"	d
HAVE_UNISTD_H	win32/orconfig.h	/^#undef HAVE_UNISTD_H$/;"	d
HAVE_VASPRINTF	common/compat.h	/^#define HAVE_VASPRINTF$/;"	d
HEADER_VERSION	common/compat_libevent.c	/^#define HEADER_VERSION /;"	d	file:
HEX1	test/test_dir.c	/^#define HEX1 /;"	d	file:
HEX2	test/test_dir.c	/^#define HEX2 /;"	d	file:
HEX256_1	test/test_dir.c	/^#define HEX256_1 /;"	d	file:
HEX256_2	test/test_dir.c	/^#define HEX256_2 /;"	d	file:
HEX256_3	test/test_dir.c	/^#define HEX256_3 /;"	d	file:
HEX3	test/test_dir.c	/^#define HEX3 /;"	d	file:
HEX_CHARACTERS	common/util.h	/^#define HEX_CHARACTERS /;"	d
HEX_DIGEST256_LEN	common/crypto.h	/^#define HEX_DIGEST256_LEN /;"	d
HEX_DIGEST_LEN	common/crypto.h	/^#define HEX_DIGEST_LEN /;"	d
HEX_ERRNO_SIZE	common/util.h	/^#define HEX_ERRNO_SIZE /;"	d
HIBERNATE_PRIVATE	or/hibernate.c	/^#define HIBERNATE_PRIVATE$/;"	d	file:
HIBERNATE_PRIVATE	test/test_dir.c	/^#define HIBERNATE_PRIVATE$/;"	d	file:
HIBERNATE_STATE_DORMANT	or/hibernate.h	/^  HIBERNATE_STATE_DORMANT=4,$/;"	e	enum:__anon33
HIBERNATE_STATE_EXITING	or/hibernate.h	/^  HIBERNATE_STATE_EXITING=2,$/;"	e	enum:__anon33
HIBERNATE_STATE_INITIAL	or/hibernate.h	/^  HIBERNATE_STATE_INITIAL=5$/;"	e	enum:__anon33
HIBERNATE_STATE_LIVE	or/hibernate.h	/^  HIBERNATE_STATE_LIVE=1,$/;"	e	enum:__anon33
HIBERNATE_STATE_LOWBANDWIDTH	or/hibernate.h	/^  HIBERNATE_STATE_LOWBANDWIDTH=3,$/;"	e	enum:__anon33
HIBERNATION_PUBLICATION_SKEW	or/dirserv.c	/^#define HIBERNATION_PUBLICATION_SKEW /;"	d	file:
HIDSERV_DIRINFO	or/or.h	/^  HIDSERV_DIRINFO = 1 << 3,$/;"	e	enum:__anon45
HOST_NAME_MAX	or/eventdns.c	/^#define HOST_NAME_MAX /;"	d	file:
HSAuthoritativeDir	or/or.h	/^  int HSAuthoritativeDir; \/**< Boolean: does this an authoritative directory$/;"	m	struct:__anon49
HTTPProxy	or/or.h	/^  char *HTTPProxy; \/**< hostname[:port] to use as http proxy, if any. *\/$/;"	m	struct:__anon49
HTTPProxyAddr	or/or.h	/^  tor_addr_t HTTPProxyAddr; \/**< Parsed IPv4 addr for http proxy, if any. *\/$/;"	m	struct:__anon49
HTTPProxyAuthenticator	or/or.h	/^  char *HTTPProxyAuthenticator; \/**< username:password string, if any. *\/$/;"	m	struct:__anon49
HTTPProxyPort	or/or.h	/^  uint16_t HTTPProxyPort; \/**< Parsed port for http proxy, if any. *\/$/;"	m	struct:__anon49
HTTPSProxy	or/or.h	/^  char *HTTPSProxy; \/**< hostname[:port] to use as https proxy, if any. *\/$/;"	m	struct:__anon49
HTTPSProxyAddr	or/or.h	/^  tor_addr_t HTTPSProxyAddr; \/**< Parsed addr for https proxy, if any. *\/$/;"	m	struct:__anon49
HTTPSProxyAuthenticator	or/or.h	/^  char *HTTPSProxyAuthenticator; \/**< username:password string, if any. *\/$/;"	m	struct:__anon49
HTTPSProxyPort	or/or.h	/^  uint16_t HTTPSProxyPort; \/**< Parsed port for https proxy, if any. *\/$/;"	m	struct:__anon49
HT_BUCKET_	common/ht.h	/^#define HT_BUCKET_(/;"	d
HT_CLEAR	common/ht.h	/^#define HT_CLEAR(/;"	d
HT_ELT_HASH_	common/ht.h	/^#define HT_ELT_HASH_(/;"	d
HT_EMPTY	common/ht.h	/^#define HT_EMPTY(/;"	d
HT_ENTRY	common/ht.h	/^#define HT_ENTRY(/;"	d
HT_FIND	common/ht.h	/^#define HT_FIND(/;"	d
HT_FIND_OR_INSERT_	common/ht.h	/^#define HT_FIND_OR_INSERT_(/;"	d
HT_FOI_INSERT_	common/ht.h	/^#define HT_FOI_INSERT_(/;"	d
HT_FOREACH	common/ht.h	/^#define HT_FOREACH(/;"	d
HT_GENERATE	common/ht.h	/^#define HT_GENERATE(/;"	d
HT_HEAD	common/ht.h	/^#define HT_HEAD(/;"	d
HT_INIT	common/ht.h	/^#define HT_INIT(/;"	d
HT_INITIALIZER	common/ht.h	/^#define HT_INITIALIZER(/;"	d
HT_INSERT	common/ht.h	/^#define HT_INSERT(/;"	d
HT_MEM_USAGE	common/ht.h	/^#define HT_MEM_USAGE(/;"	d
HT_NEXT	common/ht.h	/^#define HT_NEXT(/;"	d
HT_NEXT_RMV	common/ht.h	/^#define HT_NEXT_RMV(/;"	d
HT_PROTOTYPE	common/container.c	/^HT_PROTOTYPE(strmap_impl, strmap_entry_t, node, strmap_entry_hash,$/;"	f
HT_PROTOTYPE	common/ht.h	/^#define HT_PROTOTYPE(/;"	d
HT_PROTOTYPE	or/policies.c	/^HT_PROTOTYPE(policy_map, policy_map_ent_t, node, policy_hash,$/;"	f
HT_REMOVE	common/ht.h	/^#define HT_REMOVE(/;"	d
HT_REPLACE	common/ht.h	/^#define HT_REPLACE(/;"	d
HT_SET_HASHVAL_	common/ht.h	/^#define HT_SET_HASHVAL_(/;"	d
HT_SET_HASH_	common/ht.h	/^#define HT_SET_HASH_(/;"	d
HT_SIZE	common/ht.h	/^#define HT_SIZE(/;"	d
HT_START	common/ht.h	/^#define HT_START(/;"	d
HardwareAccel	or/or.h	/^  int HardwareAccel; \/**< Boolean: Should we enable OpenSSL hardware$/;"	m	struct:__anon49
HashedControlPassword	or/or.h	/^  config_line_t *HashedControlPassword;$/;"	m	struct:__anon49
HashedControlSessionPassword	or/or.h	/^  config_line_t *HashedControlSessionPassword;$/;"	m	struct:__anon49
HeartbeatPeriod	or/or.h	/^  int HeartbeatPeriod; \/**< Log heartbeat messages after this many seconds$/;"	m	struct:__anon49
HidServAuth	or/or.h	/^  config_line_t *HidServAuth; \/**< List of configuration lines for client-side$/;"	m	struct:__anon49
HidServDirectoryV2	or/or.h	/^  int HidServDirectoryV2; \/**< Do we participate in the HS DHT? *\/$/;"	m	struct:__anon49
I64_FORMAT	common/compat.h	/^#define I64_FORMAT /;"	d
I64_LITERAL	common/compat.h	/^#define I64_LITERAL(/;"	d
I64_PRINTF_ARG	common/compat.h	/^#define I64_PRINTF_ARG(/;"	d
I64_SCANF_ARG	common/compat.h	/^#define I64_SCANF_ARG(/;"	d
IDENTITY_CERT_LIFETIME	common/tortls.c	/^#define IDENTITY_CERT_LIFETIME /;"	d	file:
IDENTITY_KEY_BITS	tools/tor-gencert.c	/^#define IDENTITY_KEY_BITS /;"	d	file:
IDLE_ONE_HOP_CIRC_TIMEOUT	or/circuituse.c	/^#define IDLE_ONE_HOP_CIRC_TIMEOUT /;"	d	file:
IDLE_OR_CONN_TIMEOUT	or/main.c	/^#define IDLE_OR_CONN_TIMEOUT /;"	d	file:
IDLE_TIMEOUT_WHILE_LEARNING	or/circuituse.c	/^#define IDLE_TIMEOUT_WHILE_LEARNING /;"	d	file:
IDXP	common/container.c	/^#define IDXP(/;"	d	file:
IDX_OF_ITEM	common/container.c	/^#define IDX_OF_ITEM(/;"	d	file:
IF_HAS_BUFFEREVENT	or/or.h	/^#define IF_HAS_BUFFEREVENT(/;"	d
IF_HAS_NO_BUFFEREVENT	or/or.h	/^#define IF_HAS_NO_BUFFEREVENT(/;"	d
IMPLEMENT_ORDER_FUNC	common/container.c	/^#define IMPLEMENT_ORDER_FUNC(/;"	d	file:
IMPLEMENT_ORDER_FUNC	common/container.c	/^IMPLEMENT_ORDER_FUNC(find_nth_time, time_t)$/;"	f
IMPOSSIBLE_TO_DOWNLOAD	or/or.h	/^#define IMPOSSIBLE_TO_DOWNLOAD /;"	d
INET_NTOA_BUF_LEN	common/address.h	/^#define INET_NTOA_BUF_LEN /;"	d
INLINE	common/compat.h	/^#define INLINE /;"	d
INSTRUMENT_DOWNLOADS	or/or.h	/^#define INSTRUMENT_DOWNLOADS /;"	d
INT16_MAX	common/torint.h	/^#define INT16_MAX /;"	d
INT16_MIN	common/torint.h	/^#define INT16_MIN /;"	d
INT32_MAX	common/torint.h	/^#define INT32_MAX /;"	d
INT32_MIN	common/torint.h	/^#define INT32_MIN /;"	d
INT64_MAX	common/torint.h	/^#define INT64_MAX /;"	d
INTRO_CIRC_RETRY_PERIOD	or/rendservice.c	/^#define INTRO_CIRC_RETRY_PERIOD /;"	d	file:
INTRO_POINT_EXPIRATION_GRACE_PERIOD	or/rendservice.c	/^#define INTRO_POINT_EXPIRATION_GRACE_PERIOD /;"	d	file:
INTRO_POINT_FAILURE_GENERIC	or/rendclient.h	/^#define INTRO_POINT_FAILURE_GENERIC /;"	d
INTRO_POINT_FAILURE_TIMEOUT	or/rendclient.h	/^#define INTRO_POINT_FAILURE_TIMEOUT /;"	d
INTRO_POINT_FAILURE_UNREACHABLE	or/rendclient.h	/^#define INTRO_POINT_FAILURE_UNREACHABLE /;"	d
INTRO_POINT_LIFETIME_INTRODUCTIONS	or/or.h	/^#define INTRO_POINT_LIFETIME_INTRODUCTIONS /;"	d
INTRO_POINT_LIFETIME_MAX_SECONDS	or/or.h	/^#define INTRO_POINT_LIFETIME_MAX_SECONDS /;"	d
INTRO_POINT_LIFETIME_MIN_SECONDS	or/or.h	/^#define INTRO_POINT_LIFETIME_MIN_SECONDS /;"	d
INT_MAX	common/torint.h	/^#define INT_MAX /;"	d
IO_STREAM_CLOSED	common/util.h	/^  IO_STREAM_CLOSED$/;"	e	enum:stream_status
IO_STREAM_EAGAIN	common/util.h	/^  IO_STREAM_EAGAIN,$/;"	e	enum:stream_status
IO_STREAM_OKAY	common/util.h	/^  IO_STREAM_OKAY,$/;"	e	enum:stream_status
IO_STREAM_TERM	common/util.h	/^  IO_STREAM_TERM,$/;"	e	enum:stream_status
IP_GRANULARITY	or/geoip.c	/^#define IP_GRANULARITY /;"	d	file:
ISALPHA	or/eventdns.c	/^#define ISALPHA(/;"	d	file:
ISDIGIT	or/eventdns.c	/^#define ISDIGIT(/;"	d	file:
ISO_CLIENTADDR	or/or.h	/^#define ISO_CLIENTADDR /;"	d
ISO_CLIENTPROTO	or/or.h	/^#define ISO_CLIENTPROTO /;"	d
ISO_DEFAULT	or/or.h	/^#define ISO_DEFAULT /;"	d
ISO_DESTADDR	or/or.h	/^#define ISO_DESTADDR /;"	d
ISO_DESTPORT	or/or.h	/^#define ISO_DESTPORT /;"	d
ISO_NYM_EPOCH	or/or.h	/^#define ISO_NYM_EPOCH /;"	d
ISO_SESSIONGRP	or/or.h	/^#define ISO_SESSIONGRP /;"	d
ISO_SOCKSAUTH	or/or.h	/^#define ISO_SOCKSAUTH /;"	d
ISO_STREAM	or/or.h	/^#define ISO_STREAM /;"	d
ISO_TIME_LEN	common/util.h	/^#define ISO_TIME_LEN /;"	d
ISO_TIME_USEC_LEN	common/util.h	/^#define ISO_TIME_USEC_LEN /;"	d
ISSPACE	or/eventdns.c	/^#define ISSPACE(/;"	d	file:
IS_LEAPYEAR	common/util.c	/^#define IS_LEAPYEAR(/;"	d	file:
ITEM	or/control.c	/^#define ITEM(/;"	d	file:
K	common/sha256.c	/^static const uint32_t K[64] = {$/;"	v	file:
K_ACCEPT	or/routerparse.c	/^  K_ACCEPT = 0,$/;"	e	enum:__anon69	file:
K_ACCEPT6	or/routerparse.c	/^  K_ACCEPT6,$/;"	e	enum:__anon69	file:
K_ADDITIONAL_DIGEST	or/routerparse.c	/^  K_ADDITIONAL_DIGEST,$/;"	e	enum:__anon69	file:
K_ADDITIONAL_SIGNATURE	or/routerparse.c	/^  K_ADDITIONAL_SIGNATURE,$/;"	e	enum:__anon69	file:
K_ALLOW_SINGLE_HOP_EXITS	or/routerparse.c	/^  K_ALLOW_SINGLE_HOP_EXITS,$/;"	e	enum:__anon69	file:
K_BANDWIDTH	or/routerparse.c	/^  K_BANDWIDTH,$/;"	e	enum:__anon69	file:
K_BW_WEIGHTS	or/routerparse.c	/^  K_BW_WEIGHTS,$/;"	e	enum:__anon69	file:
K_CACHES_EXTRA_INFO	or/routerparse.c	/^  K_CACHES_EXTRA_INFO,$/;"	e	enum:__anon69	file:
K_CELL_CIRCS	or/routerparse.c	/^  K_CELL_CIRCS,$/;"	e	enum:__anon69	file:
K_CELL_END	or/routerparse.c	/^  K_CELL_END,$/;"	e	enum:__anon69	file:
K_CELL_PROCESSED	or/routerparse.c	/^  K_CELL_PROCESSED,$/;"	e	enum:__anon69	file:
K_CELL_QUEUED	or/routerparse.c	/^  K_CELL_QUEUED,$/;"	e	enum:__anon69	file:
K_CELL_TIME	or/routerparse.c	/^  K_CELL_TIME,$/;"	e	enum:__anon69	file:
K_CLIENT_VERSIONS	or/routerparse.c	/^  K_CLIENT_VERSIONS,$/;"	e	enum:__anon69	file:
K_CONSENSUS_DIGEST	or/routerparse.c	/^  K_CONSENSUS_DIGEST,$/;"	e	enum:__anon69	file:
K_CONSENSUS_METHOD	or/routerparse.c	/^  K_CONSENSUS_METHOD,$/;"	e	enum:__anon69	file:
K_CONSENSUS_METHODS	or/routerparse.c	/^  K_CONSENSUS_METHODS,$/;"	e	enum:__anon69	file:
K_CONTACT	or/routerparse.c	/^  K_CONTACT,$/;"	e	enum:__anon69	file:
K_DIRECTORY_FOOTER	or/routerparse.c	/^  K_DIRECTORY_FOOTER,$/;"	e	enum:__anon69	file:
K_DIRECTORY_SIGNATURE	or/routerparse.c	/^  K_DIRECTORY_SIGNATURE,$/;"	e	enum:__anon69	file:
K_DIRREQ_END	or/routerparse.c	/^  K_DIRREQ_END,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_DIR	or/routerparse.c	/^  K_DIRREQ_V2_DIR,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_IPS	or/routerparse.c	/^  K_DIRREQ_V2_IPS,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_REQS	or/routerparse.c	/^  K_DIRREQ_V2_REQS,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_RESP	or/routerparse.c	/^  K_DIRREQ_V2_RESP,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_SHARE	or/routerparse.c	/^  K_DIRREQ_V2_SHARE,$/;"	e	enum:__anon69	file:
K_DIRREQ_V2_TUN	or/routerparse.c	/^  K_DIRREQ_V2_TUN,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_DIR	or/routerparse.c	/^  K_DIRREQ_V3_DIR,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_IPS	or/routerparse.c	/^  K_DIRREQ_V3_IPS,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_REQS	or/routerparse.c	/^  K_DIRREQ_V3_REQS,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_RESP	or/routerparse.c	/^  K_DIRREQ_V3_RESP,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_SHARE	or/routerparse.c	/^  K_DIRREQ_V3_SHARE,$/;"	e	enum:__anon69	file:
K_DIRREQ_V3_TUN	or/routerparse.c	/^  K_DIRREQ_V3_TUN,$/;"	e	enum:__anon69	file:
K_DIR_ADDRESS	or/routerparse.c	/^  K_DIR_ADDRESS,$/;"	e	enum:__anon69	file:
K_DIR_IDENTITY_KEY	or/routerparse.c	/^  K_DIR_IDENTITY_KEY,$/;"	e	enum:__anon69	file:
K_DIR_KEY_CERTIFICATE_VERSION	or/routerparse.c	/^  K_DIR_KEY_CERTIFICATE_VERSION,$/;"	e	enum:__anon69	file:
K_DIR_KEY_CERTIFICATION	or/routerparse.c	/^  K_DIR_KEY_CERTIFICATION,$/;"	e	enum:__anon69	file:
K_DIR_KEY_CROSSCERT	or/routerparse.c	/^  K_DIR_KEY_CROSSCERT,$/;"	e	enum:__anon69	file:
K_DIR_KEY_EXPIRES	or/routerparse.c	/^  K_DIR_KEY_EXPIRES,$/;"	e	enum:__anon69	file:
K_DIR_KEY_PUBLISHED	or/routerparse.c	/^  K_DIR_KEY_PUBLISHED,$/;"	e	enum:__anon69	file:
K_DIR_OPTIONS	or/routerparse.c	/^  K_DIR_OPTIONS,$/;"	e	enum:__anon69	file:
K_DIR_SIGNING_KEY	or/routerparse.c	/^  K_DIR_SIGNING_KEY,$/;"	e	enum:__anon69	file:
K_DIR_SOURCE	or/routerparse.c	/^  K_DIR_SOURCE,$/;"	e	enum:__anon69	file:
K_ENTRY_END	or/routerparse.c	/^  K_ENTRY_END,$/;"	e	enum:__anon69	file:
K_ENTRY_IPS	or/routerparse.c	/^  K_ENTRY_IPS,$/;"	e	enum:__anon69	file:
K_EXIT_END	or/routerparse.c	/^  K_EXIT_END,$/;"	e	enum:__anon69	file:
K_EXIT_OPENED	or/routerparse.c	/^  K_EXIT_OPENED,$/;"	e	enum:__anon69	file:
K_EXIT_READ	or/routerparse.c	/^  K_EXIT_READ,$/;"	e	enum:__anon69	file:
K_EXIT_WRITTEN	or/routerparse.c	/^  K_EXIT_WRITTEN,$/;"	e	enum:__anon69	file:
K_EXTRA_INFO	or/routerparse.c	/^  K_EXTRA_INFO,$/;"	e	enum:__anon69	file:
K_EXTRA_INFO_DIGEST	or/routerparse.c	/^  K_EXTRA_INFO_DIGEST,$/;"	e	enum:__anon69	file:
K_FAMILY	or/routerparse.c	/^  K_FAMILY,$/;"	e	enum:__anon69	file:
K_FINGERPRINT	or/routerparse.c	/^  K_FINGERPRINT,$/;"	e	enum:__anon69	file:
K_FRESH_UNTIL	or/routerparse.c	/^  K_FRESH_UNTIL,$/;"	e	enum:__anon69	file:
K_HIBERNATING	or/routerparse.c	/^  K_HIBERNATING,$/;"	e	enum:__anon69	file:
K_HIDDEN_SERVICE_DIR	or/routerparse.c	/^  K_HIDDEN_SERVICE_DIR,$/;"	e	enum:__anon69	file:
K_KNOWN_FLAGS	or/routerparse.c	/^  K_KNOWN_FLAGS,$/;"	e	enum:__anon69	file:
K_LEGACY_DIR_KEY	or/routerparse.c	/^  K_LEGACY_DIR_KEY,$/;"	e	enum:__anon69	file:
K_M	or/routerparse.c	/^  K_M,$/;"	e	enum:__anon69	file:
K_NETWORK_STATUS	or/routerparse.c	/^  K_NETWORK_STATUS,$/;"	e	enum:__anon69	file:
K_NETWORK_STATUS_VERSION	or/routerparse.c	/^  K_NETWORK_STATUS_VERSION,$/;"	e	enum:__anon69	file:
K_ONION_KEY	or/routerparse.c	/^  K_ONION_KEY,$/;"	e	enum:__anon69	file:
K_OPT	or/routerparse.c	/^  K_OPT,$/;"	e	enum:__anon69	file:
K_OR_ADDRESS	or/routerparse.c	/^  K_OR_ADDRESS,$/;"	e	enum:__anon69	file:
K_P	or/routerparse.c	/^  K_P,$/;"	e	enum:__anon69	file:
K_PARAMS	or/routerparse.c	/^  K_PARAMS,$/;"	e	enum:__anon69	file:
K_PLATFORM	or/routerparse.c	/^  K_PLATFORM,$/;"	e	enum:__anon69	file:
K_PUBLISHED	or/routerparse.c	/^  K_PUBLISHED,$/;"	e	enum:__anon69	file:
K_R	or/routerparse.c	/^  K_R,$/;"	e	enum:__anon69	file:
K_READ_HISTORY	or/routerparse.c	/^  K_READ_HISTORY,$/;"	e	enum:__anon69	file:
K_RECOMMENDED_SOFTWARE	or/routerparse.c	/^  K_RECOMMENDED_SOFTWARE,$/;"	e	enum:__anon69	file:
K_REJECT	or/routerparse.c	/^  K_REJECT,$/;"	e	enum:__anon69	file:
K_REJECT6	or/routerparse.c	/^  K_REJECT6,$/;"	e	enum:__anon69	file:
K_ROUTER	or/routerparse.c	/^  K_ROUTER,$/;"	e	enum:__anon69	file:
K_ROUTER_SIGNATURE	or/routerparse.c	/^  K_ROUTER_SIGNATURE,$/;"	e	enum:__anon69	file:
K_ROUTER_STATUS	or/routerparse.c	/^  K_ROUTER_STATUS,$/;"	e	enum:__anon69	file:
K_RUNNING_ROUTERS	or/routerparse.c	/^  K_RUNNING_ROUTERS,$/;"	e	enum:__anon69	file:
K_S	or/routerparse.c	/^  K_S,$/;"	e	enum:__anon69	file:
K_SERVER_VERSIONS	or/routerparse.c	/^  K_SERVER_VERSIONS,$/;"	e	enum:__anon69	file:
K_SIGNED_DIRECTORY	or/routerparse.c	/^  K_SIGNED_DIRECTORY,$/;"	e	enum:__anon69	file:
K_SIGNING_KEY	or/routerparse.c	/^  K_SIGNING_KEY,$/;"	e	enum:__anon69	file:
K_UPTIME	or/routerparse.c	/^  K_UPTIME,$/;"	e	enum:__anon69	file:
K_V	or/routerparse.c	/^  K_V,$/;"	e	enum:__anon69	file:
K_VALID_AFTER	or/routerparse.c	/^  K_VALID_AFTER,$/;"	e	enum:__anon69	file:
K_VALID_UNTIL	or/routerparse.c	/^  K_VALID_UNTIL,$/;"	e	enum:__anon69	file:
K_VOTE_DIGEST	or/routerparse.c	/^  K_VOTE_DIGEST,$/;"	e	enum:__anon69	file:
K_VOTE_STATUS	or/routerparse.c	/^  K_VOTE_STATUS,$/;"	e	enum:__anon69	file:
K_VOTING_DELAY	or/routerparse.c	/^  K_VOTING_DELAY,$/;"	e	enum:__anon69	file:
K_W	or/routerparse.c	/^  K_W,$/;"	e	enum:__anon69	file:
K_WRITE_HISTORY	or/routerparse.c	/^  K_WRITE_HISTORY,$/;"	e	enum:__anon69	file:
KeepalivePeriod	or/or.h	/^  int KeepalivePeriod; \/**< How often do we send padding cells to keep$/;"	m	struct:__anon49
LAST_HID_SERV_REQUEST_KEY_LEN	or/rendclient.c	/^#define LAST_HID_SERV_REQUEST_KEY_LEN /;"	d	file:
LAZY_DESCRIPTOR_RETRY_INTERVAL	or/main.c	/^#define LAZY_DESCRIPTOR_RETRY_INTERVAL /;"	d	file:
LD_ACCT	common/torlog.h	/^#define LD_ACCT /;"	d
LD_APP	common/torlog.h	/^#define LD_APP /;"	d
LD_BUG	common/torlog.h	/^#define LD_BUG /;"	d
LD_CIRC	common/torlog.h	/^#define LD_CIRC /;"	d
LD_CONFIG	common/torlog.h	/^#define LD_CONFIG /;"	d
LD_CONTROL	common/torlog.h	/^#define LD_CONTROL /;"	d
LD_CRYPTO	common/torlog.h	/^#define LD_CRYPTO /;"	d
LD_DIR	common/torlog.h	/^#define LD_DIR /;"	d
LD_DIRSERV	common/torlog.h	/^#define LD_DIRSERV /;"	d
LD_EDGE	common/torlog.h	/^#define LD_EDGE /;"	d
LD_EXIT	common/torlog.h	/^#define LD_EXIT /;"	d
LD_FS	common/torlog.h	/^#define LD_FS /;"	d
LD_GENERAL	common/torlog.h	/^#define LD_GENERAL /;"	d
LD_HANDSHAKE	common/torlog.h	/^#define LD_HANDSHAKE /;"	d
LD_HEARTBEAT	common/torlog.h	/^#define LD_HEARTBEAT /;"	d
LD_HIST	common/torlog.h	/^#define LD_HIST /;"	d
LD_HTTP	common/torlog.h	/^#define LD_HTTP /;"	d
LD_MM	common/torlog.h	/^#define LD_MM /;"	d
LD_NET	common/torlog.h	/^#define LD_NET /;"	d
LD_NOCB	common/torlog.h	/^#define LD_NOCB /;"	d
LD_OR	common/torlog.h	/^#define LD_OR /;"	d
LD_PROTOCOL	common/torlog.h	/^#define LD_PROTOCOL /;"	d
LD_REND	common/torlog.h	/^#define LD_REND /;"	d
LEFT_CHILD	common/container.c	/^#define LEFT_CHILD(/;"	d	file:
LEGAL_NICKNAME_CHARACTERS	common/tortls.c	/^#define LEGAL_NICKNAME_CHARACTERS /;"	d	file:
LEGAL_NICKNAME_CHARACTERS	or/or.h	/^#define LEGAL_NICKNAME_CHARACTERS /;"	d
LEN_ONION_RESPONSE	or/cpuworker.c	/^#define LEN_ONION_RESPONSE /;"	d	file:
LE_OLD	common/compat_libevent.c	/^#define LE_OLD /;"	d	file:
LE_OTHER	common/compat_libevent.c	/^#define LE_OTHER /;"	d	file:
LINUX_CLOEXEC_ACCEPT	common/compat.c	/^#define LINUX_CLOEXEC_ACCEPT$/;"	d	file:
LINUX_CLOEXEC_OPEN_SOCKET	common/compat.c	/^#define LINUX_CLOEXEC_OPEN_SOCKET$/;"	d	file:
LISTENER_CONNECTION_MAGIC	or/or.h	/^#define LISTENER_CONNECTION_MAGIC /;"	d
LISTENER_STATE_READY	or/or.h	/^#define LISTENER_STATE_READY /;"	d
LOAD	or/ntmain.c	/^#define LOAD(/;"	d	file:
LOAD	or/rephist.c	/^#define LOAD(/;"	d	file:
LOAD	or/rephist.c	/^#undef LOAD$/;"	d	file:
LOAD32H	common/sha256.c	/^#define LOAD32H(/;"	d	file:
LOCK_LOGS	common/log.c	/^#define LOCK_LOGS(/;"	d	file:
LOG_DEBUG	common/torlog.h	/^#define LOG_DEBUG /;"	d
LOG_ERR	common/torlog.h	/^#define LOG_ERR /;"	d
LOG_FN_CONN	or/control.h	/^#define LOG_FN_CONN(/;"	d
LOG_INFO	common/torlog.h	/^#define LOG_INFO /;"	d
LOG_NOTICE	common/torlog.h	/^#define LOG_NOTICE /;"	d
LOG_ONEHALF	or/relay.c	/^#define LOG_ONEHALF /;"	d	file:
LOG_PRIVATE	common/log.c	/^#define LOG_PRIVATE$/;"	d	file:
LOG_PROTOCOL_WARN	or/or.h	/^#define LOG_PROTOCOL_WARN /;"	d
LOG_WARN	common/torlog.h	/^#define LOG_WARN /;"	d
LONGEST_TEST_NAME	test/tinytest.c	/^#define LONGEST_TEST_NAME /;"	d	file:
LONG_MAX	common/torint.h	/^#define LONG_MAX /;"	d
LOREMIPSUM	test/test_util.c	/^#define LOREMIPSUM /;"	d	file:
LT	test/test_util.c	/^#define LT /;"	d	file:
LTC_ARGCHK	common/crypto.c	/^#define LTC_ARGCHK(/;"	d	file:
LastRotatedOnionKey	or/or.h	/^  time_t LastRotatedOnionKey;$/;"	m	struct:__anon52
LastWritten	or/or.h	/^  time_t LastWritten;$/;"	m	struct:__anon52
LearnCircuitBuildTimeout	or/or.h	/^  int LearnCircuitBuildTimeout; \/**< If non-zero, we attempt to learn a value$/;"	m	struct:__anon49
LeaveStreamsUnattached	or/or.h	/^  int LeaveStreamsUnattached; \/**< Boolean: Does Tor attach new streams to$/;"	m	struct:__anon49
LogMessageDomains	or/or.h	/^  int LogMessageDomains; \/**< Boolean: Should we log the domain(s) in which$/;"	m	struct:__anon49
LogTimeGranularity	or/or.h	/^  int LogTimeGranularity; \/**< Log resolution in milliseconds. *\/$/;"	m	struct:__anon49
Logs	or/or.h	/^  config_line_t *Logs; \/**< New-style list of configuration lines$/;"	m	struct:__anon49
LongLivedPorts	or/or.h	/^  smartlist_t *LongLivedPorts;$/;"	m	struct:__anon49
LookupAccountNameA_fn	or/ntmain.c	/^  BOOL (WINAPI *LookupAccountNameA_fn)($/;"	m	struct:service_fns	file:
M2A	common/mempool.c	/^#define M2A(/;"	d	file:
MACOSX_KQUEUE_IS_BROKEN	common/compat_libevent.c	/^#define MACOSX_KQUEUE_IS_BROKEN /;"	d	file:
MADV_FREE	common/OpenBSD_malloc_Linux.c	/^#define MADV_FREE /;"	d	file:
MAGIC_EXITCODE	test/tinytest.c	/^#define MAGIC_EXITCODE /;"	d	file:
MAIN_PRIVATE	or/main.c	/^#define MAIN_PRIVATE$/;"	d	file:
MAIN_PRIVATE	or/ntmain.c	/^#define MAIN_PRIVATE$/;"	d	file:
MALLOC_BITS	common/OpenBSD_malloc_Linux.c	/^#define	MALLOC_BITS	/;"	d	file:
MALLOC_EXTRA_SANITY	common/OpenBSD_malloc_Linux.c	/^#undef	MALLOC_EXTRA_SANITY$/;"	d	file:
MALLOC_FIRST	common/OpenBSD_malloc_Linux.c	/^#define MALLOC_FIRST	/;"	d	file:
MALLOC_FOLLOW	common/OpenBSD_malloc_Linux.c	/^#define MALLOC_FOLLOW	/;"	d	file:
MALLOC_FREE	common/OpenBSD_malloc_Linux.c	/^#define MALLOC_FREE	/;"	d	file:
MALLOC_MAGIC	common/OpenBSD_malloc_Linux.c	/^#define MALLOC_MAGIC	/;"	d	file:
MALLOC_NOT_MINE	common/OpenBSD_malloc_Linux.c	/^#define MALLOC_NOT_MINE	/;"	d	file:
MALLOC_STATS	common/OpenBSD_malloc_Linux.c	/^#undef	MALLOC_STATS$/;"	d	file:
MAP_DEL_CURRENT	common/container.h	/^#define MAP_DEL_CURRENT(/;"	d
MAP_FOREACH	common/container.h	/^#define MAP_FOREACH(/;"	d
MAP_FOREACH_END	common/container.h	/^#define MAP_FOREACH_END /;"	d
MAP_FOREACH_MODIFY	common/container.h	/^#define MAP_FOREACH_MODIFY(/;"	d
MAX	common/compat.h	/^#define MAX(/;"	d
MAX_ADDRESSLEN	or/dns.c	/^#define MAX_ADDRESSLEN /;"	d	file:
MAX_ADDRESS_LENGTH	common/address.c	/^#define MAX_ADDRESS_LENGTH /;"	d	file:
MAX_ADDRS	or/eventdns.c	/^#define MAX_ADDRS /;"	d	file:
MAX_ANNOTATION	or/routerparse.c	/^#define MAX_ANNOTATION /;"	d	file:
MAX_ARGS	or/routerparse.c	/^#define MAX_ARGS /;"	d	file:
MAX_ARGS	or/routerparse.c	/^#undef MAX_ARGS$/;"	d	file:
MAX_BACKENDS	tools/tor-fw-helper/tor-fw-helper.h	/^#define MAX_BACKENDS /;"	d
MAX_BANDWIDTH_CHANGE_FREQ	or/router.c	/^#define MAX_BANDWIDTH_CHANGE_FREQ /;"	d	file:
MAX_BUF_SIZE	or/or.h	/^#define MAX_BUF_SIZE /;"	d
MAX_CAPACITY	common/container.c	/^#define MAX_CAPACITY /;"	d	file:
MAX_CERT_DL_FAILURES	or/routerlist.c	/^#define MAX_CERT_DL_FAILURES /;"	d	file:
MAX_CERT_SIZE	or/routerparse.c	/^#define MAX_CERT_SIZE /;"	d	file:
MAX_CHUNK	common/mempool.c	/^#define MAX_CHUNK /;"	d	file:
MAX_CHUNK_ALLOC	or/buffers.c	/^#define MAX_CHUNK_ALLOC /;"	d	file:
MAX_CIRCUIT_FAILURES	or/circuituse.c	/^#define MAX_CIRCUIT_FAILURES /;"	d	file:
MAX_CLIENT_INTERVAL_WITHOUT_REQUEST	or/routerlist.c	/^#define MAX_CLIENT_INTERVAL_WITHOUT_REQUEST /;"	d	file:
MAX_COMMAND_LINE_LENGTH	or/control.c	/^#define MAX_COMMAND_LINE_LENGTH /;"	d	file:
MAX_CONSTRAINED_TCP_BUFFER	or/or.h	/^#define MAX_CONSTRAINED_TCP_BUFFER /;"	d
MAX_CPUWORKERS	or/cpuworker.c	/^#define MAX_CPUWORKERS /;"	d	file:
MAX_DESCRIPTOR_UPLOAD_SIZE	or/or.h	/^#define MAX_DESCRIPTOR_UPLOAD_SIZE /;"	d
MAX_DETECTABLE_CPUS	common/compat.c	/^#define MAX_DETECTABLE_CPUS /;"	d	file:
MAX_DIRECTORY_OBJECT_SIZE	or/directory.c	/^#define MAX_DIRECTORY_OBJECT_SIZE /;"	d	file:
MAX_DIR_DL_SIZE	or/or.h	/^#define MAX_DIR_DL_SIZE /;"	d
MAX_DIR_PERIOD	or/config.c	/^#define MAX_DIR_PERIOD /;"	d	file:
MAX_DIR_UL_SIZE	or/or.h	/^#define MAX_DIR_UL_SIZE /;"	d
MAX_DL_PER_REQUEST	or/routerlist.c	/^#define MAX_DL_PER_REQUEST /;"	d	file:
MAX_DL_TO_DELAY	or/routerlist.c	/^#define MAX_DL_TO_DELAY /;"	d	file:
MAX_DNS_ENTRY_AGE	or/or.h	/^#define MAX_DNS_ENTRY_AGE /;"	d
MAX_DNS_LABEL_SIZE	common/crypto.c	/^#define MAX_DNS_LABEL_SIZE /;"	d	file:
MAX_DNS_TTL	or/or.h	/^#define MAX_DNS_TTL /;"	d
MAX_EXITPOLICY_SUMMARY_LEN	or/dirserv.h	/^#define MAX_EXITPOLICY_SUMMARY_LEN /;"	d
MAX_EXTRAINFO_UPLOAD_SIZE	or/or.h	/^#define MAX_EXTRAINFO_UPLOAD_SIZE /;"	d
MAX_FLAG_LINE_LEN	or/dirserv.h	/^#define MAX_FLAG_LINE_LEN /;"	d
MAX_FREELIST_LEN	common/memarea.c	/^#define MAX_FREELIST_LEN /;"	d	file:
MAX_HEADERS_SIZE	or/or.h	/^#define MAX_HEADERS_SIZE /;"	d
MAX_HEX_NICKNAME_LEN	or/or.h	/^#define MAX_HEX_NICKNAME_LEN /;"	d
MAX_HIST_VALUE_LEN	or/rephist.c	/^#define MAX_HIST_VALUE_LEN /;"	d	file:
MAX_INTRO_CIRCS_PER_PERIOD	or/rendservice.c	/^#define MAX_INTRO_CIRCS_PER_PERIOD /;"	d	file:
MAX_INTRO_POINT_REACHABILITY_FAILURES	or/or.h	/^#define MAX_INTRO_POINT_REACHABILITY_FAILURES /;"	d
MAX_LABELS	or/eventdns.c	/^#define MAX_LABELS /;"	d	file:
MAX_LAST_SEEN_IN_MINUTES	or/geoip.c	/^#define MAX_LAST_SEEN_IN_MINUTES /;"	d	file:
MAX_LINE_LENGTH	or/routerparse.c	/^#define MAX_LINE_LENGTH /;"	d	file:
MAX_MAX_CLIENT_CIRCUITS_PENDING	or/or.h	/^#define MAX_MAX_CLIENT_CIRCUITS_PENDING /;"	d
MAX_MEASUREMENT_AGE	or/dirserv.c	/^#define MAX_MEASUREMENT_AGE /;"	d	file:
MAX_MICRODESC_DL_PER_REQUEST	or/routerlist.c	/^#define MAX_MICRODESC_DL_PER_REQUEST /;"	d	file:
MAX_MICRODESC_DOWNLOAD_FAILURES	or/or.h	/^#define MAX_MICRODESC_DOWNLOAD_FAILURES /;"	d
MAX_NETWORKSTATUS_AGE	or/networkstatus.h	/^#define MAX_NETWORKSTATUS_AGE /;"	d
MAX_NICKNAME_LEN	or/or.h	/^#define MAX_NICKNAME_LEN /;"	d
MAX_POLICY_LINE_LEN	or/dirserv.h	/^#define MAX_POLICY_LINE_LEN /;"	d
MAX_REASONS_TO_REPORT	or/connection_or.c	/^#define MAX_REASONS_TO_REPORT /;"	d	file:
MAX_RELAY_EARLY_CELLS_PER_CIRCUIT	or/or.h	/^#define MAX_RELAY_EARLY_CELLS_PER_CIRCUIT /;"	d
MAX_REND_FAILURES	or/rendservice.c	/^#define MAX_REND_FAILURES /;"	d	file:
MAX_REND_TIMEOUT	or/rendservice.c	/^#define MAX_REND_TIMEOUT /;"	d	file:
MAX_RESOLVE_FAILURES	or/relay.c	/^#define MAX_RESOLVE_FAILURES /;"	d	file:
MAX_ROUTERDESC_DOWNLOAD_FAILURES	or/or.h	/^#define MAX_ROUTERDESC_DOWNLOAD_FAILURES /;"	d
MAX_SCANF_WIDTH	common/util.c	/^#define MAX_SCANF_WIDTH /;"	d	file:
MAX_SERVICE_WAIT_TIME	or/ntmain.c	/^#define MAX_SERVICE_WAIT_TIME /;"	d	file:
MAX_SIGNEWNYM_RATE	or/main.c	/^#define MAX_SIGNEWNYM_RATE /;"	d	file:
MAX_SOCKS_ADDR_LEN	or/or.h	/^#define MAX_SOCKS_ADDR_LEN /;"	d
MAX_SOCKS_MESSAGE_LEN	or/buffers.c	/^#define MAX_SOCKS_MESSAGE_LEN /;"	d	file:
MAX_SOCKS_REPLY_LEN	or/or.h	/^#define MAX_SOCKS_REPLY_LEN /;"	d
MAX_SPLIT_LINE_COUNT	test/test_util.c	/^#define MAX_SPLIT_LINE_COUNT /;"	d	file:
MAX_SSL_KEY_LIFETIME_ADVERTISED	or/or.h	/^#define MAX_SSL_KEY_LIFETIME_ADVERTISED /;"	d
MAX_SSL_KEY_LIFETIME_INTERNAL	or/or.h	/^#define MAX_SSL_KEY_LIFETIME_INTERNAL /;"	d
MAX_STABILITY_DOC_BUILD_RATE	or/rephist.c	/^#define MAX_STABILITY_DOC_BUILD_RATE /;"	d	file:
MAX_STATUS_TAG_LEN	or/or.h	/^#define MAX_STATUS_TAG_LEN /;"	d
MAX_SUPPORTED_CONSENSUS_METHOD	or/dirvote.c	/^#define MAX_SUPPORTED_CONSENSUS_METHOD /;"	d	file:
MAX_UNCOMPRESSION_FACTOR	common/torgzip.c	/^#define MAX_UNCOMPRESSION_FACTOR /;"	d	file:
MAX_UNPARSED_OBJECT_SIZE	or/routerparse.c	/^#define MAX_UNPARSED_OBJECT_SIZE /;"	d	file:
MAX_UNTRUSTED_NETWORKSTATUSES	or/dirserv.c	/^#define MAX_UNTRUSTED_NETWORKSTATUSES /;"	d	file:
MAX_UNUSED_OPEN_CIRCUITS	or/circuituse.c	/^#define MAX_UNUSED_OPEN_CIRCUITS /;"	d	file:
MAX_V1_DIRECTORY_AGE	or/dirserv.c	/^#define MAX_V1_DIRECTORY_AGE /;"	d	file:
MAX_V1_RR_AGE	or/dirserv.c	/^#define MAX_V1_RR_AGE /;"	d	file:
MAX_VERBOSE_NICKNAME_LEN	or/or.h	/^#define MAX_VERBOSE_NICKNAME_LEN /;"	d
MAX_V_LINE_LEN	or/dirserv.h	/^#define MAX_V_LINE_LEN /;"	d
MAX_WEIGHT_LINE_LEN	or/dirserv.h	/^#define MAX_WEIGHT_LINE_LEN /;"	d
MEMAREA_ALIGN	common/memarea.c	/^#define MEMAREA_ALIGN /;"	d	file:
MEMAREA_ALIGN_MASK	common/memarea.c	/^#define MEMAREA_ALIGN_MASK /;"	d	file:
MEMPOOL_PRIVATE	common/mempool.c	/^#define MEMPOOL_PRIVATE$/;"	d	file:
MEMPOOL_PRIVATE	test/test_util.c	/^#define MEMPOOL_PRIVATE$/;"	d	file:
MEMPOOL_STATS	common/mempool.h	/^#define MEMPOOL_STATS$/;"	d
MEM_SHRINK_INTERVAL	or/main.c	/^#define MEM_SHRINK_INTERVAL /;"	d	file:
MICRODESC_CACHE_LIFETIME	or/directory.c	/^#define MICRODESC_CACHE_LIFETIME /;"	d	file:
MICRODESC_DIRINFO	or/or.h	/^  MICRODESC_DIRINFO=1 << 6,$/;"	e	enum:__anon45
MICRODESC_LINE_LEN	or/dirvote.c	/^#define MICRODESC_LINE_LEN /;"	d	file:
MIN	common/compat.h	/^#define MIN(/;"	d
MIN	common/crypto.c	/^#define MIN(/;"	d	file:
MIN	common/crypto.c	/^#undef MIN$/;"	d	file:
MIN	common/sha256.c	/^   #define MIN(/;"	d	file:
MIN	or/circuitbuild.c	/^#define MIN(/;"	d	file:
MIN	or/eventdns.c	/^#define MIN(/;"	d	file:
MIN	or/eventdns.c	/^#undef MIN$/;"	d	file:
MIN_ANNOTATION	or/routerparse.c	/^#define MIN_ANNOTATION /;"	d	file:
MIN_BW_TO_ADVERTISE_DIRPORT	or/router.c	/^#define MIN_BW_TO_ADVERTISE_DIRPORT /;"	d	file:
MIN_CHUNK	common/mempool.c	/^#define MIN_CHUNK /;"	d	file:
MIN_CHUNK_ALLOC	or/buffers.c	/^#define MIN_CHUNK_ALLOC /;"	d	file:
MIN_CIRCUITS_HANDLING_STREAM	or/or.h	/^#define MIN_CIRCUITS_HANDLING_STREAM /;"	d
MIN_CIRCUIT_STREAM_TIMEOUT	or/config.c	/^#define MIN_CIRCUIT_STREAM_TIMEOUT /;"	d	file:
MIN_CONSTRAINED_TCP_BUFFER	or/or.h	/^#define MIN_CONSTRAINED_TCP_BUFFER /;"	d
MIN_CPUWORKERS	or/cpuworker.c	/^#define MIN_CPUWORKERS /;"	d	file:
MIN_DIR_REQ_RESPONSES	or/geoip.c	/^#define MIN_DIR_REQ_RESPONSES /;"	d	file:
MIN_DIST_SECONDS	or/dirvote.h	/^#define MIN_DIST_SECONDS /;"	d
MIN_DL_PER_REQUEST	or/routerlist.c	/^#define MIN_DL_PER_REQUEST /;"	d	file:
MIN_DNS_TTL	or/or.h	/^#define MIN_DNS_TTL /;"	d
MIN_HEARTBEAT_PERIOD	or/config.c	/^#define MIN_HEARTBEAT_PERIOD /;"	d	file:
MIN_IPS_TO_NOTE_ANYTHING	or/geoip.c	/^#define MIN_IPS_TO_NOTE_ANYTHING /;"	d	file:
MIN_IPS_TO_NOTE_COUNTRY	or/geoip.c	/^#define MIN_IPS_TO_NOTE_COUNTRY /;"	d	file:
MIN_MAX_CIRCUIT_DIRTINESS	or/config.c	/^#define MIN_MAX_CIRCUIT_DIRTINESS /;"	d	file:
MIN_METHOD_FOR_BW_WEIGHTS	or/dirvote.c	/^#define MIN_METHOD_FOR_BW_WEIGHTS /;"	d	file:
MIN_METHOD_FOR_FOOTER	or/dirvote.c	/^#define MIN_METHOD_FOR_FOOTER /;"	d	file:
MIN_METHOD_FOR_MAJORITY_PARAMS	or/dirvote.c	/^#define MIN_METHOD_FOR_MAJORITY_PARAMS /;"	d	file:
MIN_METHOD_FOR_MICRODESC	or/dirvote.c	/^#define MIN_METHOD_FOR_MICRODESC /;"	d	file:
MIN_METHOD_FOR_PARAMS	or/dirvote.c	/^#define MIN_METHOD_FOR_PARAMS /;"	d	file:
MIN_ONION_KEY_LIFETIME	or/or.h	/^#define MIN_ONION_KEY_LIFETIME /;"	d
MIN_READ_LEN	or/buffers.c	/^#define MIN_READ_LEN /;"	d	file:
MIN_REND_POST_PERIOD	or/config.c	/^#define MIN_REND_POST_PERIOD /;"	d	file:
MIN_REQUESTS	or/routerlist.c	/^#define MIN_REQUESTS /;"	d	file:
MIN_TIME_FOR_MEASUREMENT	or/hibernate.c	/^#define MIN_TIME_FOR_MEASUREMENT /;"	d	file:
MIN_TLS_FLUSHLEN	or/connection.c	/^#define MIN_TLS_FLUSHLEN /;"	d	file:
MIN_VOTES_FOR_PARAM	or/dirvote.c	/^#define MIN_VOTES_FOR_PARAM /;"	d	file:
MIN_VOTE_INTERVAL	or/dirvote.h	/^#define MIN_VOTE_INTERVAL /;"	d
MIN_VOTE_SECONDS	or/dirvote.h	/^#define MIN_VOTE_SECONDS /;"	d
MMAP	common/OpenBSD_malloc_Linux.c	/^#define MMAP(/;"	d	file:
MMAP_A	common/OpenBSD_malloc_Linux.c	/^static void *MMAP_A(size_t pages, size_t alignment)$/;"	f	file:
MONTH_NAMES	common/util.c	/^static const char *MONTH_NAMES[] =$/;"	v	file:
MP_CHUNK_MAGIC	common/mempool.c	/^#define MP_CHUNK_MAGIC /;"	d	file:
MTBF_TO_GUARANTEE_STABLE	or/dirserv.c	/^#define MTBF_TO_GUARANTEE_STABLE /;"	d	file:
Maj	common/sha256.c	/^#define Maj(/;"	d	file:
MaxAdvertisedBandwidth	or/or.h	/^  uint64_t MaxAdvertisedBandwidth; \/**< How much bandwidth are we willing to$/;"	m	struct:__anon49
MaxCircuitDirtiness	or/or.h	/^  int MaxCircuitDirtiness; \/**< Never use circs that were first used more than$/;"	m	struct:__anon49
MaxClientCircuitsPending	or/or.h	/^  int MaxClientCircuitsPending;$/;"	m	struct:__anon49
MaxOnionsPending	or/or.h	/^  int MaxOnionsPending; \/**< How many circuit CREATE requests do we allow$/;"	m	struct:__anon49
MinUptimeHidServDirectoryV2	or/or.h	/^  int MinUptimeHidServDirectoryV2; \/**< As directory authority, accept hidden$/;"	m	struct:__anon49
MyFamily	or/or.h	/^  char *MyFamily; \/**< Declared family for this OR. *\/$/;"	m	struct:__anon49
NAMEFOR	test/test.c	/^#define NAMEFOR(/;"	d	file:
NAMEFOR	test/test.c	/^#undef NAMEFOR$/;"	d	file:
NANOCOUNT	test/bench.c	/^#define NANOCOUNT(/;"	d	file:
NATDListenAddress	or/or.h	/^  config_line_t *NATDListenAddress;$/;"	m	struct:__anon49
NATDPort	or/or.h	/^  config_line_t *NATDPort; \/**< Ports to listen on for transparent natd$/;"	m	struct:__anon49
NATPMP_DEFAULT_LEASE	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^#define NATPMP_DEFAULT_LEASE /;"	d
NATPMP_SUCCESS	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^#define NATPMP_SUCCESS /;"	d
NEED_KEY	or/routerparse.c	/^  NEED_KEY,      \/**< Object is required, and must be a public key. *\/$/;"	e	enum:__anon70	file:
NEED_KEY_1024	or/routerparse.c	/^  NEED_KEY_1024, \/**< Object is required, and must be a 1024 bit public key *\/$/;"	e	enum:__anon70	file:
NEED_OBJ	or/routerparse.c	/^  NEED_OBJ,      \/**< Object is required. *\/$/;"	e	enum:__anon70	file:
NEED_SKEY_1024	or/routerparse.c	/^  NEED_SKEY_1024,\/**< Object is required, and must be a 1024 bit private key *\/$/;"	e	enum:__anon70	file:
NETINFO_NOTICE_SKEW	or/command.c	/^#define NETINFO_NOTICE_SKEW /;"	d	file:
NETWORKSTATUS_ALLOW_SKEW	or/networkstatus.c	/^#define NETWORKSTATUS_ALLOW_SKEW /;"	d	file:
NETWORKSTATUS_CACHE_LIFETIME	or/directory.c	/^#define NETWORKSTATUS_CACHE_LIFETIME /;"	d	file:
NEW_CONN_GRACE_PERIOD	or/connection_or.c	/^#define NEW_CONN_GRACE_PERIOD /;"	d	file:
NEXT_LINE	or/routerparse.c	/^#define NEXT_LINE(/;"	d	file:
NEXT_LINE	or/routerparse.c	/^#undef NEXT_LINE$/;"	d	file:
NEXT_TOKEN	or/eventdns.c	/^#define NEXT_TOKEN /;"	d	file:
NEXT_TOKEN	or/eventdns.c	/^#undef NEXT_TOKEN$/;"	d	file:
NODE_DESC_BUF_LEN	or/router.h	/^#define NODE_DESC_BUF_LEN /;"	d
NONAUTHORITY_NS_CACHE_INTERVAL	or/networkstatus.c	/^#define NONAUTHORITY_NS_CACHE_INTERVAL /;"	d	file:
NON_ANONYMOUS_MODE_ENABLED	or/or.h	/^#define NON_ANONYMOUS_MODE_ENABLED /;"	d
NORMAL_HOSTNAME	or/connection_edge.h	/^  NORMAL_HOSTNAME, ONION_HOSTNAME, EXIT_HOSTNAME, BAD_HOSTNAME$/;"	e	enum:hostname_type_t
NOTE_BYTES	or/hibernate.c	/^#define NOTE_BYTES /;"	d	file:
NOTE_INTERVAL	or/hibernate.c	/^#define NOTE_INTERVAL /;"	d	file:
NO_ARGS	or/routerparse.c	/^#define NO_ARGS /;"	d	file:
NO_DIRINFO	or/or.h	/^  NO_DIRINFO      = 0,$/;"	e	enum:__anon45
NO_METHOD	common/torgzip.h	/^  NO_METHOD=0, GZIP_METHOD=1, ZLIB_METHOD=2, UNKNOWN_METHOD=3$/;"	e	enum:__anon14
NO_OBJ	or/routerparse.c	/^  NO_OBJ,        \/**< No object, ever. *\/$/;"	e	enum:__anon70	file:
NO_WEIGHTING	or/or.h	/^  NO_WEIGHTING, WEIGHT_FOR_EXIT, WEIGHT_FOR_MID, WEIGHT_FOR_GUARD,$/;"	e	enum:bandwidth_weight_rule_t
NSSET_ACCEPT_OBSOLETE	or/networkstatus.h	/^#define NSSET_ACCEPT_OBSOLETE /;"	d
NSSET_DONT_DOWNLOAD_CERTS	or/networkstatus.h	/^#define NSSET_DONT_DOWNLOAD_CERTS /;"	d
NSSET_FROM_CACHE	or/networkstatus.h	/^#define NSSET_FROM_CACHE /;"	d
NSSET_REQUIRE_FLAVOR	or/networkstatus.h	/^#define NSSET_REQUIRE_FLAVOR /;"	d
NSSET_WAS_WAITING_FOR_CERTS	or/networkstatus.h	/^#define NSSET_WAS_WAITING_FOR_CERTS /;"	d
NS_CONTROL_PORT	or/or.h	/^  NS_CONTROL_PORT,$/;"	e	enum:__anon58
NS_EXPIRY_SLOP	or/main.c	/^#define NS_EXPIRY_SLOP /;"	d	file:
NS_FROM_CACHE	or/or.h	/^  NS_FROM_CACHE, NS_FROM_DIR_BY_FP, NS_FROM_DIR_ALL, NS_GENERATED$/;"	e	enum:__anon63
NS_FROM_DIR_ALL	or/or.h	/^  NS_FROM_CACHE, NS_FROM_DIR_BY_FP, NS_FROM_DIR_ALL, NS_GENERATED$/;"	e	enum:__anon63
NS_FROM_DIR_BY_FP	or/or.h	/^  NS_FROM_CACHE, NS_FROM_DIR_BY_FP, NS_FROM_DIR_ALL, NS_GENERATED$/;"	e	enum:__anon63
NS_GENERATED	or/or.h	/^  NS_FROM_CACHE, NS_FROM_DIR_BY_FP, NS_FROM_DIR_ALL, NS_GENERATED$/;"	e	enum:__anon63
NS_TYPE_CONSENSUS	or/or.h	/^  NS_TYPE_CONSENSUS,$/;"	e	enum:__anon42
NS_TYPE_OPINION	or/or.h	/^  NS_TYPE_OPINION,$/;"	e	enum:__anon42
NS_TYPE_VOTE	or/or.h	/^  NS_TYPE_VOTE,$/;"	e	enum:__anon42
NS_V2	or/or.h	/^  NS_V2,$/;"	e	enum:__anon58
NS_V3_CONSENSUS	or/or.h	/^  NS_V3_CONSENSUS,$/;"	e	enum:__anon58
NS_V3_CONSENSUS_MICRODESC	or/or.h	/^  NS_V3_CONSENSUS_MICRODESC$/;"	e	enum:__anon58
NS_V3_VOTE	or/or.h	/^  NS_V3_VOTE,$/;"	e	enum:__anon58
NT_SERVICE	common/compat.h	/^#undef NT_SERVICE$/;"	d
NT_SERVICE	or/ntmain.h	/^#define NT_SERVICE$/;"	d
NT_SERVICE_ERROR_TORINIT_FAILED	or/ntmain.c	/^#define NT_SERVICE_ERROR_TORINIT_FAILED /;"	d	file:
NULL_REP_IS_ZERO_BYTES	win32/orconfig.h	/^#define NULL_REP_IS_ZERO_BYTES /;"	d
NUM_CIRCUITS_LAUNCHED_THRESHOLD	or/or.h	/^#define NUM_CIRCUITS_LAUNCHED_THRESHOLD /;"	d
NUM_INTRO_POINTS_DEFAULT	or/rendservice.c	/^#define NUM_INTRO_POINTS_DEFAULT /;"	d	file:
NUM_INTRO_POINTS_MAX	or/rendservice.c	/^#define NUM_INTRO_POINTS_MAX /;"	d	file:
NUM_JUMPED_SECONDS_BEFORE_WARN	or/main.c	/^#define NUM_JUMPED_SECONDS_BEFORE_WARN /;"	d	file:
NUM_PARALLEL_TESTING_CIRCS	or/circuituse.c	/^#define NUM_PARALLEL_TESTING_CIRCS /;"	d	file:
NUM_SECS_BW_SUM_INTERVAL	or/rephist.c	/^#define NUM_SECS_BW_SUM_INTERVAL /;"	d	file:
NUM_SECS_BW_SUM_IS_VALID	or/rephist.c	/^#define NUM_SECS_BW_SUM_IS_VALID /;"	d	file:
NUM_SECS_ROLLING_MEASURE	or/rephist.c	/^#define NUM_SECS_ROLLING_MEASURE /;"	d	file:
NUM_TOTALS	or/rephist.c	/^#define NUM_TOTALS /;"	d	file:
N_AUTH_CERT_DL_FAILURES_TO_BUG_USER	or/routerlist.c	/^#define N_AUTH_CERT_DL_FAILURES_TO_BUG_USER /;"	d	file:
N_CLIENT_CIPHERS	common/tortls.c	/^static const int N_CLIENT_CIPHERS =$/;"	v	file:
N_CONSENSUS_FLAVORS	or/or.h	/^#define N_CONSENSUS_FLAVORS /;"	d
N_DIGEST_ALGORITHMS	common/crypto.h	/^#define  N_DIGEST_ALGORITHMS /;"	d
N_LOGGING_DOMAINS	common/torlog.h	/^#define N_LOGGING_DOMAINS /;"	d
N_PREGEN_KEYS	test/test.c	/^#define N_PREGEN_KEYS /;"	d	file:
N_WILDCARD_CHECKS	or/dns.c	/^#define N_WILDCARD_CHECKS /;"	d	file:
NamingAuthoritativeDir	or/or.h	/^  int NamingAuthoritativeDir; \/**< Boolean: is this an authoritative directory$/;"	m	struct:__anon49
NewCircuitPeriod	or/or.h	/^  int NewCircuitPeriod; \/**< How long do we use a circuit before building$/;"	m	struct:__anon49
Nickname	or/or.h	/^  char *Nickname; \/**< OR only: nickname of this onion router. *\/$/;"	m	struct:__anon49
NodeFamilies	or/or.h	/^  config_line_t *NodeFamilies; \/**< List of config lines for$/;"	m	struct:__anon49
NodeFamilySets	or/or.h	/^  smartlist_t *NodeFamilySets; \/**< List of parsed NodeFamilies values. *\/$/;"	m	struct:__anon49
NumCPUs	or/or.h	/^  int NumCPUs; \/**< How many CPUs should we try to use? *\/$/;"	m	struct:__anon49
NumEntryGuards	or/or.h	/^  int NumEntryGuards; \/**< How many entry guards do we try to establish? *\/$/;"	m	struct:__anon49
OBJ_OK	or/routerparse.c	/^  OBJ_OK,        \/**< Object is optional. *\/$/;"	e	enum:__anon70	file:
OBSOLETE	or/config.c	/^#define OBSOLETE(/;"	d	file:
OBSOLETE	or/config.c	/^#undef OBSOLETE$/;"	d	file:
OCSP_RESPONSE	common/crypto.c	/^#undef OCSP_RESPONSE$/;"	d	file:
OFFSET_OF	or/eventdns.c	/^#define OFFSET_OF(/;"	d	file:
OK	test/test_containers.c	/^#define OK(/;"	d	file:
OK	test/test_containers.c	/^#undef OK$/;"	d	file:
OK	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
OLD_CERT_LIFETIME	or/routerlist.c	/^#define OLD_CERT_LIFETIME /;"	d	file:
OLD_CERT_LIFETIME	or/routerlist.c	/^#undef OLD_CERT_LIFETIME$/;"	d	file:
OLD_ROUTER_DESC_MAX_AGE	or/or.h	/^#define OLD_ROUTER_DESC_MAX_AGE /;"	d
ONIONQUEUE_WAIT_CUTOFF	or/onion.c	/^#define ONIONQUEUE_WAIT_CUTOFF /;"	d	file:
ONIONSKIN_CHALLENGE_LEN	or/or.h	/^#define ONIONSKIN_CHALLENGE_LEN /;"	d
ONIONSKIN_REPLY_LEN	or/or.h	/^#define ONIONSKIN_REPLY_LEN /;"	d
ONION_HOSTNAME	or/connection_edge.h	/^  NORMAL_HOSTNAME, ONION_HOSTNAME, EXIT_HOSTNAME, BAD_HOSTNAME$/;"	e	enum:hostname_type_t
OPENSSL_V	common/crypto.h	/^#define OPENSSL_V(/;"	d
OPENSSL_VER	common/crypto.h	/^#define OPENSSL_VER(/;"	d
OPENSSL_V_NOPATCH	common/crypto.h	/^#define OPENSSL_V_NOPATCH(/;"	d
OPENSSL_V_SERIES	common/crypto.h	/^#define OPENSSL_V_SERIES(/;"	d
OPEN_FLAGS_APPEND	common/util.h	/^#define OPEN_FLAGS_APPEND /;"	d
OPEN_FLAGS_DONT_REPLACE	common/util.h	/^#define OPEN_FLAGS_DONT_REPLACE /;"	d
OPEN_FLAGS_REPLACE	common/util.h	/^#define OPEN_FLAGS_REPLACE /;"	d
OPTIMIZED_DIGESTMAP_SET	common/container.c	/^#define OPTIMIZED_DIGESTMAP_SET$/;"	d	file:
ORIGIN_CIRCUIT_MAGIC	or/or.h	/^#define ORIGIN_CIRCUIT_MAGIC /;"	d
ORListenAddress	or/or.h	/^  config_line_t *ORListenAddress;$/;"	m	struct:__anon49
ORPort	or/or.h	/^  config_line_t *ORPort; \/**< Ports to listen on for OR connections. *\/$/;"	m	struct:__anon49
OR_AUTH_CHALLENGE_LEN	or/or.h	/^#define OR_AUTH_CHALLENGE_LEN /;"	d
OR_CERT_TYPE_AUTH_1024	or/or.h	/^#define OR_CERT_TYPE_AUTH_1024 /;"	d
OR_CERT_TYPE_ID_1024	or/or.h	/^#define OR_CERT_TYPE_ID_1024 /;"	d
OR_CERT_TYPE_TLS_LINK	or/or.h	/^#define OR_CERT_TYPE_TLS_LINK /;"	d
OR_CIRCUIT_MAGIC	or/or.h	/^#define OR_CIRCUIT_MAGIC /;"	d
OR_CONNECTION_MAGIC	or/or.h	/^#define OR_CONNECTION_MAGIC /;"	d
OR_CONN_EVENT_CLOSED	or/or.h	/^  OR_CONN_EVENT_CLOSED       = 3,$/;"	e	enum:or_conn_status_event_t
OR_CONN_EVENT_CONNECTED	or/or.h	/^  OR_CONN_EVENT_CONNECTED    = 1,$/;"	e	enum:or_conn_status_event_t
OR_CONN_EVENT_FAILED	or/or.h	/^  OR_CONN_EVENT_FAILED       = 2,$/;"	e	enum:or_conn_status_event_t
OR_CONN_EVENT_LAUNCHED	or/or.h	/^  OR_CONN_EVENT_LAUNCHED     = 0,$/;"	e	enum:or_conn_status_event_t
OR_CONN_EVENT_NEW	or/or.h	/^  OR_CONN_EVENT_NEW          = 4,$/;"	e	enum:or_conn_status_event_t
OR_CONN_HIGHWATER	or/connection_or.c	/^#define OR_CONN_HIGHWATER /;"	d	file:
OR_CONN_LOWWATER	or/connection_or.c	/^#define OR_CONN_LOWWATER /;"	d	file:
OR_CONN_STATE_CONNECTING	or/or.h	/^#define OR_CONN_STATE_CONNECTING /;"	d
OR_CONN_STATE_OPEN	or/or.h	/^#define OR_CONN_STATE_OPEN /;"	d
OR_CONN_STATE_OR_HANDSHAKING_V2	or/or.h	/^#define OR_CONN_STATE_OR_HANDSHAKING_V2 /;"	d
OR_CONN_STATE_OR_HANDSHAKING_V3	or/or.h	/^#define OR_CONN_STATE_OR_HANDSHAKING_V3 /;"	d
OR_CONN_STATE_PROXY_HANDSHAKING	or/or.h	/^#define OR_CONN_STATE_PROXY_HANDSHAKING /;"	d
OR_CONN_STATE_TLS_CLIENT_RENEGOTIATING	or/or.h	/^#define OR_CONN_STATE_TLS_CLIENT_RENEGOTIATING /;"	d
OR_CONN_STATE_TLS_HANDSHAKING	or/or.h	/^#define OR_CONN_STATE_TLS_HANDSHAKING /;"	d
OR_CONN_STATE_TLS_SERVER_RENEGOTIATING	or/or.h	/^#define OR_CONN_STATE_TLS_SERVER_RENEGOTIATING /;"	d
OR_OPTIONS_MAGIC	or/config.c	/^#define OR_OPTIONS_MAGIC /;"	d	file:
OR_STATE_MAGIC	or/config.c	/^#define OR_STATE_MAGIC /;"	d	file:
O_BINARY	common/util.h	/^#define O_BINARY /;"	d
O_TEXT	common/util.h	/^#define O_TEXT /;"	d
OpenSCManagerA_fn	or/ntmain.c	/^  SC_HANDLE (WINAPI *OpenSCManagerA_fn)($/;"	m	struct:service_fns	file:
OpenServiceA_fn	or/ntmain.c	/^  SC_HANDLE (WINAPI *OpenServiceA_fn)($/;"	m	struct:service_fns	file:
OptimisticData	or/or.h	/^  int OptimisticData;$/;"	m	struct:__anon49
OutboundBindAddress	or/or.h	/^  char *OutboundBindAddress;$/;"	m	struct:__anon49
OwningControllerProcess	or/or.h	/^  char *OwningControllerProcess;$/;"	m	struct:__anon49
PACKAGE	win32/orconfig.h	/^#define PACKAGE /;"	d
PACKAGE_BUGREPORT	win32/orconfig.h	/^#undef PACKAGE_BUGREPORT$/;"	d
PACKAGE_NAME	win32/orconfig.h	/^#undef PACKAGE_NAME$/;"	d
PACKAGE_STRING	win32/orconfig.h	/^#undef PACKAGE_STRING$/;"	d
PACKAGE_TARNAME	win32/orconfig.h	/^#undef PACKAGE_TARNAME$/;"	d
PACKAGE_VERSION	win32/orconfig.h	/^#undef PACKAGE_VERSION$/;"	d
PAD	common/crypto.c	/^#define PAD /;"	d	file:
PAD	common/crypto.c	/^#undef PAD$/;"	d	file:
PARENT	common/container.c	/^#define PARENT(/;"	d	file:
PATH_SEPARATOR	common/compat.h	/^#define PATH_SEPARATOR /;"	d
PDS_ALLOW_SELF	or/or.h	/^#define PDS_ALLOW_SELF /;"	d
PDS_IGNORE_FASCISTFIREWALL	or/or.h	/^#define PDS_IGNORE_FASCISTFIREWALL /;"	d
PDS_NO_EXISTING_MICRODESC_FETCH	or/or.h	/^#define PDS_NO_EXISTING_MICRODESC_FETCH /;"	d
PDS_NO_EXISTING_SERVERDESC_FETCH	or/or.h	/^#define PDS_NO_EXISTING_SERVERDESC_FETCH /;"	d
PDS_RETRY_IF_NO_SERVERS	or/or.h	/^#define PDS_RETRY_IF_NO_SERVERS /;"	d
PD_IDX	common/OpenBSD_malloc_Linux.c	/^#define	PD_IDX(/;"	d	file:
PD_OFF	common/OpenBSD_malloc_Linux.c	/^#define	PD_OFF(/;"	d	file:
PERIODIC_FLAGS	common/compat_libevent.c	/^#define PERIODIC_FLAGS /;"	d	file:
PERIODIC_TIMER_FLAGS	common/procmon.c	/^#define PERIODIC_TIMER_FLAGS /;"	d	file:
PGSHIFT	common/OpenBSD_malloc_Linux.c	/^#define PGSHIFT /;"	d	file:
PI_IDX	common/OpenBSD_malloc_Linux.c	/^#define	PI_IDX(/;"	d	file:
PI_OFF	common/OpenBSD_malloc_Linux.c	/^#define	PI_OFF(/;"	d	file:
PKCS1_OAEP_PADDING_OVERHEAD	common/crypto.h	/^#define PKCS1_OAEP_PADDING_OVERHEAD /;"	d
PKCS1_PADDING_OVERHEAD	common/crypto.h	/^#define PKCS1_PADDING_OVERHEAD /;"	d
PK_BYTES	common/crypto.h	/^#define PK_BYTES /;"	d
PK_PKCS1_OAEP_PADDING	common/crypto.h	/^#define PK_PKCS1_OAEP_PADDING /;"	d
PK_PKCS1_PADDING	common/crypto.h	/^#define PK_PKCS1_PADDING /;"	d
PLURAL	or/config.c	/^#define PLURAL(/;"	d	file:
PLURAL	or/config.c	/^#undef PLURAL$/;"	d	file:
POLICY_BUF_LEN	or/policies.h	/^#define POLICY_BUF_LEN /;"	d
PORT_FORWARDING_CHECK_INTERVAL	or/main.c	/^#define PORT_FORWARDING_CHECK_INTERVAL /;"	d	file:
PREDICTED_CIRCS_RELEVANCE_TIME	or/rephist.c	/^#define PREDICTED_CIRCS_RELEVANCE_TIME /;"	d	file:
PREDICT_LIKELY	common/compat.h	/^#define PREDICT_LIKELY(/;"	d
PREDICT_LIKELY	common/mempool.c	/^#define PREDICT_LIKELY(/;"	d	file:
PREDICT_UNLIKELY	common/compat.h	/^#define PREDICT_UNLIKELY(/;"	d
PREDICT_UNLIKELY	common/mempool.c	/^#define PREDICT_UNLIKELY(/;"	d	file:
PREFIX	or/control.c	/^#define PREFIX(/;"	d	file:
PRETTY_FUNCTION	test/test.h	/^#define PRETTY_FUNCTION /;"	d
PRINTF	or/rephist.c	/^#define PRINTF(/;"	d	file:
PRINTF	or/rephist.c	/^#undef PRINTF$/;"	d	file:
PRIVATE_KEY_OK	common/crypto.c	/^#define PRIVATE_KEY_OK(/;"	d	file:
PROCESS_CELL	or/command.c	/^#define PROCESS_CELL(/;"	d	file:
PROCESS_EXIT_ERROR	common/util.h	/^#define PROCESS_EXIT_ERROR /;"	d
PROCESS_EXIT_EXITED	common/util.h	/^#define PROCESS_EXIT_EXITED /;"	d
PROCESS_EXIT_RUNNING	common/util.h	/^#define PROCESS_EXIT_RUNNING /;"	d
PROCESS_STATUS_ERROR	common/util.h	/^#define PROCESS_STATUS_ERROR /;"	d
PROCESS_STATUS_NOTRUNNING	common/util.h	/^#define PROCESS_STATUS_NOTRUNNING /;"	d
PROCESS_STATUS_RUNNING	common/util.h	/^#define PROCESS_STATUS_RUNNING /;"	d
PROCMON_POLLS	common/procmon.c	/^#define PROCMON_POLLS /;"	d	file:
PROTO_CMETHOD	or/transports.c	/^#define PROTO_CMETHOD /;"	d	file:
PROTO_CMETHODS_DONE	or/transports.c	/^#define PROTO_CMETHODS_DONE /;"	d	file:
PROTO_CMETHOD_ERROR	or/transports.c	/^#define PROTO_CMETHOD_ERROR /;"	d	file:
PROTO_ENV_ERROR	or/transports.c	/^#define PROTO_ENV_ERROR /;"	d	file:
PROTO_NEG_FAIL	or/transports.c	/^#define PROTO_NEG_FAIL /;"	d	file:
PROTO_NEG_SUCCESS	or/transports.c	/^#define PROTO_NEG_SUCCESS /;"	d	file:
PROTO_SMETHOD	or/transports.c	/^#define PROTO_SMETHOD /;"	d	file:
PROTO_SMETHODS_DONE	or/transports.c	/^#define PROTO_SMETHODS_DONE /;"	d	file:
PROTO_SMETHOD_ERROR	or/transports.c	/^#define PROTO_SMETHOD_ERROR /;"	d	file:
PROTO_VERSION_ONE	or/transports.c	/^#define PROTO_VERSION_ONE /;"	d	file:
PROXY_CONNECT	or/or.h	/^#define PROXY_CONNECT /;"	d
PROXY_CONNECTED	or/or.h	/^#define PROXY_CONNECTED /;"	d
PROXY_HTTPS_WANT_CONNECT_OK	or/or.h	/^#define PROXY_HTTPS_WANT_CONNECT_OK /;"	d
PROXY_INFANT	or/or.h	/^#define PROXY_INFANT /;"	d
PROXY_NONE	or/or.h	/^#define PROXY_NONE /;"	d
PROXY_PLUGGABLE	or/or.h	/^#define PROXY_PLUGGABLE /;"	d
PROXY_SOCKS4	or/or.h	/^#define PROXY_SOCKS4 /;"	d
PROXY_SOCKS4_WANT_CONNECT_OK	or/or.h	/^#define PROXY_SOCKS4_WANT_CONNECT_OK /;"	d
PROXY_SOCKS5	or/or.h	/^#define PROXY_SOCKS5 /;"	d
PROXY_SOCKS5_WANT_AUTH_METHOD_NONE	or/or.h	/^#define PROXY_SOCKS5_WANT_AUTH_METHOD_NONE /;"	d
PROXY_SOCKS5_WANT_AUTH_METHOD_RFC1929	or/or.h	/^#define PROXY_SOCKS5_WANT_AUTH_METHOD_RFC1929 /;"	d
PROXY_SOCKS5_WANT_AUTH_RFC1929_OK	or/or.h	/^#define PROXY_SOCKS5_WANT_AUTH_RFC1929_OK /;"	d
PROXY_SOCKS5_WANT_CONNECT_OK	or/or.h	/^#define PROXY_SOCKS5_WANT_CONNECT_OK /;"	d
PTR_ALIGNED	common/OpenBSD_malloc_Linux.c	/^#define	PTR_ALIGNED(/;"	d	file:
PTR_GAP	common/OpenBSD_malloc_Linux.c	/^#define	PTR_GAP	/;"	d	file:
PTR_SIZE	common/OpenBSD_malloc_Linux.c	/^#define	PTR_SIZE	/;"	d	file:
PT_LEGACY	test/test_pt.c	/^#define PT_LEGACY(/;"	d	file:
PT_PRIVATE	or/transports.c	/^#define PT_PRIVATE$/;"	d	file:
PT_PRIVATE	test/test_pt.c	/^#define PT_PRIVATE$/;"	d	file:
PT_PROTO_ACCEPTING_METHODS	or/transports.h	/^  PT_PROTO_ACCEPTING_METHODS, \/* accepting methods *\/$/;"	e	enum:pt_proto_state
PT_PROTO_BROKEN	or/transports.h	/^  PT_PROTO_BROKEN, \/* broke during the protocol *\/$/;"	e	enum:pt_proto_state
PT_PROTO_COMPLETED	or/transports.h	/^  PT_PROTO_COMPLETED, \/* configure and registered its transports *\/$/;"	e	enum:pt_proto_state
PT_PROTO_CONFIGURED	or/transports.h	/^  PT_PROTO_CONFIGURED, \/* configured successfully *\/$/;"	e	enum:pt_proto_state
PT_PROTO_FAILED_LAUNCH	or/transports.h	/^  PT_PROTO_FAILED_LAUNCH \/* failed while launching *\/$/;"	e	enum:pt_proto_state
PT_PROTO_INFANT	or/transports.h	/^  PT_PROTO_INFANT, \/* was just born *\/$/;"	e	enum:pt_proto_state
PT_PROTO_LAUNCHED	or/transports.h	/^  PT_PROTO_LAUNCHED, \/* was just launched *\/$/;"	e	enum:pt_proto_state
PUBLIC_KEY_OK	common/crypto.c	/^#define PUBLIC_KEY_OK(/;"	d	file:
PUT	or/rephist.c	/^#define PUT(/;"	d	file:
PUT	or/rephist.c	/^#undef PUT$/;"	d	file:
PerConnBWBurst	or/or.h	/^  uint64_t PerConnBWBurst; \/**< Allowed burst on a single TLS conn, if set. *\/$/;"	m	struct:__anon49
PerConnBWRate	or/or.h	/^  uint64_t PerConnBWRate; \/**< Long-term bw on a single TLS conn, if set. *\/$/;"	m	struct:__anon49
PidFile	or/or.h	/^  char *PidFile; \/**< Where to store PID of Tor process. *\/$/;"	m	struct:__anon49
PortForwarding	or/or.h	/^  int PortForwarding; \/**< If true, use NAT-PMP or UPnP to automatically$/;"	m	struct:__anon49
PortForwardingHelper	or/or.h	/^  char *PortForwardingHelper; \/** < Filename or full path of the port$/;"	m	struct:__anon49
PreferTunneledDirConns	or/or.h	/^  int PreferTunneledDirConns; \/**< If true, avoid dirservers that don't$/;"	m	struct:__anon49
ProtocolWarnings	or/or.h	/^  int ProtocolWarnings; \/**< Boolean: when other parties screw up the Tor$/;"	m	struct:__anon49
PublishHidServDescriptors	or/or.h	/^  int PublishHidServDescriptors;$/;"	m	struct:__anon49
PublishServerDescriptor	or/or.h	/^  smartlist_t *PublishServerDescriptor;$/;"	m	struct:__anon49
QueryServiceStatus_fn	or/ntmain.c	/^  BOOL (WINAPI *QueryServiceStatus_fn)($/;"	m	struct:service_fns	file:
R	common/sha256.c	/^#define R(/;"	d	file:
RAND_POLL_IS_SAFE	common/crypto.c	/^#define RAND_POLL_IS_SAFE /;"	d	file:
RANGE_CHECK	or/dirvote.c	/^#define RANGE_CHECK(/;"	d	file:
RATELIM_INIT	common/util.h	/^#define RATELIM_INIT(/;"	d
REACHABILITY_MODULO_PER_TEST	or/dirserv.h	/^#define REACHABILITY_MODULO_PER_TEST /;"	d
REACHABILITY_TEST_CYCLE_PERIOD	or/dirserv.h	/^#define REACHABILITY_TEST_CYCLE_PERIOD /;"	d
REACHABILITY_TEST_INTERVAL	or/dirserv.h	/^#define REACHABILITY_TEST_INTERVAL /;"	d
REACHABLE_TIMEOUT	or/dirserv.c	/^#define REACHABLE_TIMEOUT /;"	d	file:
READ_EVENT	or/main.h	/^  READ_EVENT=0x02, \/**< We want to know when a connection is readable *\/$/;"	e	enum:watchable_events
REASONABLY_LIVE_TIME	or/networkstatus.c	/^#define REASONABLY_LIVE_TIME /;"	d	file:
REJECT	or/config.c	/^#define REJECT(/;"	d	file:
REJECT	or/config.c	/^#undef REJECT$/;"	d	file:
REJECT	or/policies.c	/^#define REJECT(/;"	d	file:
REJECT	or/policies.c	/^#undef REJECT$/;"	d	file:
REJECT_CUTOFF_COUNT	or/policies.c	/^#define REJECT_CUTOFF_COUNT /;"	d	file:
RELAY_BRIDGE_STATS_DELAY	or/config.c	/^#define RELAY_BRIDGE_STATS_DELAY /;"	d	file:
RELAY_COMMAND_BEGIN	or/or.h	/^#define RELAY_COMMAND_BEGIN /;"	d
RELAY_COMMAND_BEGIN_DIR	or/or.h	/^#define RELAY_COMMAND_BEGIN_DIR /;"	d
RELAY_COMMAND_CONNECTED	or/or.h	/^#define RELAY_COMMAND_CONNECTED /;"	d
RELAY_COMMAND_DATA	or/or.h	/^#define RELAY_COMMAND_DATA /;"	d
RELAY_COMMAND_DROP	or/or.h	/^#define RELAY_COMMAND_DROP /;"	d
RELAY_COMMAND_END	or/or.h	/^#define RELAY_COMMAND_END /;"	d
RELAY_COMMAND_ESTABLISH_INTRO	or/or.h	/^#define RELAY_COMMAND_ESTABLISH_INTRO /;"	d
RELAY_COMMAND_ESTABLISH_RENDEZVOUS	or/or.h	/^#define RELAY_COMMAND_ESTABLISH_RENDEZVOUS /;"	d
RELAY_COMMAND_EXTEND	or/or.h	/^#define RELAY_COMMAND_EXTEND /;"	d
RELAY_COMMAND_EXTENDED	or/or.h	/^#define RELAY_COMMAND_EXTENDED /;"	d
RELAY_COMMAND_INTRODUCE1	or/or.h	/^#define RELAY_COMMAND_INTRODUCE1 /;"	d
RELAY_COMMAND_INTRODUCE2	or/or.h	/^#define RELAY_COMMAND_INTRODUCE2 /;"	d
RELAY_COMMAND_INTRODUCE_ACK	or/or.h	/^#define RELAY_COMMAND_INTRODUCE_ACK /;"	d
RELAY_COMMAND_INTRO_ESTABLISHED	or/or.h	/^#define RELAY_COMMAND_INTRO_ESTABLISHED /;"	d
RELAY_COMMAND_RENDEZVOUS1	or/or.h	/^#define RELAY_COMMAND_RENDEZVOUS1 /;"	d
RELAY_COMMAND_RENDEZVOUS2	or/or.h	/^#define RELAY_COMMAND_RENDEZVOUS2 /;"	d
RELAY_COMMAND_RENDEZVOUS_ESTABLISHED	or/or.h	/^#define RELAY_COMMAND_RENDEZVOUS_ESTABLISHED /;"	d
RELAY_COMMAND_RESOLVE	or/or.h	/^#define RELAY_COMMAND_RESOLVE /;"	d
RELAY_COMMAND_RESOLVED	or/or.h	/^#define RELAY_COMMAND_RESOLVED /;"	d
RELAY_COMMAND_SENDME	or/or.h	/^#define RELAY_COMMAND_SENDME /;"	d
RELAY_COMMAND_TRUNCATE	or/or.h	/^#define RELAY_COMMAND_TRUNCATE /;"	d
RELAY_COMMAND_TRUNCATED	or/or.h	/^#define RELAY_COMMAND_TRUNCATED /;"	d
RELAY_HEADER_SIZE	or/or.h	/^#define RELAY_HEADER_SIZE /;"	d
RELAY_PAYLOAD_SIZE	or/or.h	/^#define RELAY_PAYLOAD_SIZE /;"	d
RELAY_PRIVATE	or/relay.c	/^#define RELAY_PRIVATE$/;"	d	file:
RELAY_PRIVATE	test/bench.c	/^#define RELAY_PRIVATE$/;"	d	file:
REMAP_STREAM_SOURCE_CACHE	or/or.h	/^#define REMAP_STREAM_SOURCE_CACHE /;"	d
REMAP_STREAM_SOURCE_EXIT	or/or.h	/^#define REMAP_STREAM_SOURCE_EXIT /;"	d
REND_BASIC_AUTH	or/or.h	/^  REND_BASIC_AUTH   = 1,$/;"	e	enum:rend_auth_type_t
REND_BASIC_AUTH_CLIENT_ENTRY_LEN	or/or.h	/^#define REND_BASIC_AUTH_CLIENT_ENTRY_LEN /;"	d
REND_BASIC_AUTH_CLIENT_ID_LEN	or/or.h	/^#define REND_BASIC_AUTH_CLIENT_ID_LEN /;"	d
REND_BASIC_AUTH_CLIENT_MULTIPLE	or/or.h	/^#define REND_BASIC_AUTH_CLIENT_MULTIPLE /;"	d
REND_CACHE_MAX_AGE	or/rendcommon.c	/^#define REND_CACHE_MAX_AGE /;"	d	file:
REND_CACHE_MAX_SKEW	or/rendcommon.c	/^#define REND_CACHE_MAX_SKEW /;"	d	file:
REND_CLIENT	or/or.h	/^  REND_CLIENT, REND_MID, REND_SERVER,$/;"	e	enum:__anon65
REND_CLIENTNAME_MAX_LEN	or/or.h	/^#define REND_CLIENTNAME_MAX_LEN /;"	d
REND_COOKIE_LEN	or/or.h	/^#define REND_COOKIE_LEN /;"	d
REND_DESC_COOKIE_LEN	or/or.h	/^#define REND_DESC_COOKIE_LEN /;"	d
REND_DESC_COOKIE_LEN	or/rendcommon.c	/^#define REND_DESC_COOKIE_LEN /;"	d	file:
REND_DESC_COOKIE_LEN_BASE64	or/or.h	/^#define REND_DESC_COOKIE_LEN_BASE64 /;"	d
REND_DESC_ID_V2_LEN_BASE32	or/or.h	/^#define REND_DESC_ID_V2_LEN_BASE32 /;"	d
REND_DESC_MAX_SIZE	or/or.h	/^#define REND_DESC_MAX_SIZE /;"	d
REND_HID_SERV_DIR_REQUERY_PERIOD	or/rendclient.c	/^#define REND_HID_SERV_DIR_REQUERY_PERIOD /;"	d	file:
REND_INTRO_POINT_ID_LEN_BASE32	or/or.h	/^#define REND_INTRO_POINT_ID_LEN_BASE32 /;"	d
REND_LEGAL_CLIENTNAME_CHARACTERS	or/or.h	/^#define REND_LEGAL_CLIENTNAME_CHARACTERS /;"	d
REND_MID	or/or.h	/^  REND_CLIENT, REND_MID, REND_SERVER,$/;"	e	enum:__anon65
REND_NO_AUTH	or/or.h	/^  REND_NO_AUTH      = 0,$/;"	e	enum:rend_auth_type_t
REND_NUMBER_OF_CONSECUTIVE_REPLICAS	or/or.h	/^#define REND_NUMBER_OF_CONSECUTIVE_REPLICAS /;"	d
REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS	or/or.h	/^#define REND_NUMBER_OF_NON_CONSECUTIVE_REPLICAS /;"	d
REND_REPLAY_TIME_INTERVAL	or/or.h	/^#define REND_REPLAY_TIME_INTERVAL /;"	d
REND_REPLICA_LEN	or/rendcommon.c	/^#define REND_REPLICA_LEN /;"	d	file:
REND_SECRET_ID_PART_LEN_BASE32	or/or.h	/^#define REND_SECRET_ID_PART_LEN_BASE32 /;"	d
REND_SERVER	or/or.h	/^  REND_CLIENT, REND_MID, REND_SERVER,$/;"	e	enum:__anon65
REND_SERVICE_ADDRESS_LEN	or/or.h	/^#define REND_SERVICE_ADDRESS_LEN /;"	d
REND_SERVICE_ID_LEN	or/or.h	/^#define REND_SERVICE_ID_LEN /;"	d
REND_SERVICE_ID_LEN_BASE32	or/or.h	/^#define REND_SERVICE_ID_LEN_BASE32 /;"	d
REND_STEALTH_AUTH	or/or.h	/^  REND_STEALTH_AUTH = 2,$/;"	e	enum:rend_auth_type_t
REND_TIME_PERIOD_OVERLAPPING_V2_DESCS	or/or.h	/^#define REND_TIME_PERIOD_OVERLAPPING_V2_DESCS /;"	d
REND_TIME_PERIOD_V2_DESC_VALIDITY	or/or.h	/^#define REND_TIME_PERIOD_V2_DESC_VALIDITY /;"	d
REND_TOKEN_LEN	or/or.h	/^#define REND_TOKEN_LEN /;"	d
REQUEST_SHARE_INTERVAL	or/geoip.c	/^#define REQUEST_SHARE_INTERVAL /;"	d	file:
RESOLVED_TYPE_ERROR	or/or.h	/^#define RESOLVED_TYPE_ERROR /;"	d
RESOLVED_TYPE_ERROR_TRANSIENT	or/or.h	/^#define RESOLVED_TYPE_ERROR_TRANSIENT /;"	d
RESOLVED_TYPE_HOSTNAME	or/or.h	/^#define RESOLVED_TYPE_HOSTNAME /;"	d
RESOLVED_TYPE_IPV4	or/or.h	/^#define RESOLVED_TYPE_IPV4 /;"	d
RESOLVED_TYPE_IPV6	or/or.h	/^#define RESOLVED_TYPE_IPV6 /;"	d
RESOLVE_MAX_TIMEOUT	or/dns.c	/^#define RESOLVE_MAX_TIMEOUT /;"	d	file:
RESPONSE_GRANULARITY	or/geoip.c	/^#define RESPONSE_GRANULARITY /;"	d	file:
RESPONSE_GRANULARITY	or/geoip.c	/^#undef RESPONSE_GRANULARITY$/;"	d	file:
RESPONSE_LEN_4	tools/tor-resolve.c	/^#define RESPONSE_LEN_4 /;"	d	file:
RETRY_DNS_INTERVAL	or/main.c	/^#define RETRY_DNS_INTERVAL /;"	d	file:
RET_ERR	or/routerparse.c	/^#define RET_ERR(/;"	d	file:
RET_ERR	or/routerparse.c	/^#undef RET_ERR$/;"	d	file:
REVERSE_LOOKUP_NAME_BUF_LEN	common/address.h	/^#define REVERSE_LOOKUP_NAME_BUF_LEN /;"	d
RFC1123_TIME_LEN	common/util.h	/^#define RFC1123_TIME_LEN /;"	d
RFTS_BIN	common/util.h	/^#define RFTS_BIN /;"	d
RFTS_IGNORE_MISSING	common/util.h	/^#define RFTS_IGNORE_MISSING /;"	d
RIGHT_CHILD	common/container.c	/^#define RIGHT_CHILD(/;"	d	file:
RIMAP_FOREACH	or/routerlist.c	/^#define RIMAP_FOREACH(/;"	d	file:
RND	common/sha256.c	/^#define RND(/;"	d	file:
ROBOTS_CACHE_LIFETIME	or/directory.c	/^#define ROBOTS_CACHE_LIFETIME /;"	d	file:
RORc	common/sha256.c	/^#define RORc(/;"	d	file:
ROUND_UP	or/hibernate.c	/^#define ROUND_UP(/;"	d	file:
ROUND_UP	or/hibernate.c	/^#undef ROUND_UP$/;"	d	file:
ROUTERDESC_BY_DIGEST_CACHE_LIFETIME	or/directory.c	/^#define ROUTERDESC_BY_DIGEST_CACHE_LIFETIME /;"	d	file:
ROUTERDESC_CACHE_LIFETIME	or/directory.c	/^#define ROUTERDESC_CACHE_LIFETIME /;"	d	file:
ROUTER_ADDED_NOTIFY_GENERATOR	or/or.h	/^  ROUTER_ADDED_NOTIFY_GENERATOR = 0,$/;"	e	enum:was_router_added_t
ROUTER_ADDED_SUCCESSFULLY	or/or.h	/^  ROUTER_ADDED_SUCCESSFULLY = 1,$/;"	e	enum:was_router_added_t
ROUTER_ALLOW_SKEW	or/dirserv.c	/^#define ROUTER_ALLOW_SKEW /;"	d	file:
ROUTER_ALLOW_UPTIME_DRIFT	or/routerlist.c	/^#define ROUTER_ALLOW_UPTIME_DRIFT /;"	d	file:
ROUTER_ANNOTATION_BUF_LEN	or/or.h	/^#define ROUTER_ANNOTATION_BUF_LEN /;"	d
ROUTER_AUTHDIR_REJECTS	or/or.h	/^  ROUTER_AUTHDIR_REJECTS = -5,$/;"	e	enum:was_router_added_t
ROUTER_BAD_EI	or/or.h	/^  ROUTER_BAD_EI = -1,$/;"	e	enum:was_router_added_t
ROUTER_MAX_AGE	or/or.h	/^#define ROUTER_MAX_AGE /;"	d
ROUTER_MAX_AGE_TO_PUBLISH	or/or.h	/^#define ROUTER_MAX_AGE_TO_PUBLISH /;"	d
ROUTER_MAX_COSMETIC_TIME_DIFFERENCE	or/routerlist.c	/^#define ROUTER_MAX_COSMETIC_TIME_DIFFERENCE /;"	d	file:
ROUTER_MAX_DECLARED_BANDWIDTH	or/or.h	/^#define ROUTER_MAX_DECLARED_BANDWIDTH /;"	d
ROUTER_NOT_IN_CONSENSUS	or/or.h	/^  ROUTER_NOT_IN_CONSENSUS = -3,$/;"	e	enum:was_router_added_t
ROUTER_NOT_IN_CONSENSUS_OR_NETWORKSTATUS	or/or.h	/^  ROUTER_NOT_IN_CONSENSUS_OR_NETWORKSTATUS = -4,$/;"	e	enum:was_router_added_t
ROUTER_PRIVATE	or/router.c	/^#define ROUTER_PRIVATE$/;"	d	file:
ROUTER_PRIVATE	test/test.c	/^#define ROUTER_PRIVATE$/;"	d	file:
ROUTER_PRIVATE	test/test_dir.c	/^#define ROUTER_PRIVATE$/;"	d	file:
ROUTER_PURPOSE_BRIDGE	or/or.h	/^#define ROUTER_PURPOSE_BRIDGE /;"	d
ROUTER_PURPOSE_CONTROLLER	or/or.h	/^#define ROUTER_PURPOSE_CONTROLLER /;"	d
ROUTER_PURPOSE_GENERAL	or/or.h	/^#define ROUTER_PURPOSE_GENERAL /;"	d
ROUTER_PURPOSE_UNKNOWN	or/or.h	/^#define ROUTER_PURPOSE_UNKNOWN /;"	d
ROUTER_REQUIRED_MIN_BANDWIDTH	or/or.h	/^#define ROUTER_REQUIRED_MIN_BANDWIDTH /;"	d
ROUTER_STORE	or/or.h	/^  ROUTER_STORE = 0,$/;"	e	enum:store_type_t
ROUTER_WAS_NOT_NEW	or/or.h	/^  ROUTER_WAS_NOT_NEW = -2,$/;"	e	enum:was_router_added_t
ROUTER_WAS_NOT_WANTED	or/or.h	/^  ROUTER_WAS_NOT_WANTED = -6$/;"	e	enum:was_router_added_t
RRS_DONT_REMOVE_OLD	or/routerlist.c	/^#define RRS_DONT_REMOVE_OLD /;"	d	file:
RRS_FORCE	or/routerlist.c	/^#define RRS_FORCE /;"	d	file:
RSHIFT_DOES_SIGN_EXTEND	win32/orconfig.h	/^#define RSHIFT_DOES_SIGN_EXTEND$/;"	d
RS_ENTRY_LEN	or/dirserv.h	/^#define RS_ENTRY_LEN /;"	d
RUNNINGROUTERS_CACHE_LIFETIME	or/directory.c	/^#define RUNNINGROUTERS_CACHE_LIFETIME /;"	d	file:
R_INTRODUCTION_POINTS	or/routerparse.c	/^  R_INTRODUCTION_POINTS,$/;"	e	enum:__anon69	file:
R_IPO_IDENTIFIER	or/routerparse.c	/^  R_IPO_IDENTIFIER,$/;"	e	enum:__anon69	file:
R_IPO_IP_ADDRESS	or/routerparse.c	/^  R_IPO_IP_ADDRESS,$/;"	e	enum:__anon69	file:
R_IPO_ONION_KEY	or/routerparse.c	/^  R_IPO_ONION_KEY,$/;"	e	enum:__anon69	file:
R_IPO_ONION_PORT	or/routerparse.c	/^  R_IPO_ONION_PORT,$/;"	e	enum:__anon69	file:
R_IPO_SERVICE_KEY	or/routerparse.c	/^  R_IPO_SERVICE_KEY,$/;"	e	enum:__anon69	file:
R_PERMANENT_KEY	or/routerparse.c	/^  R_PERMANENT_KEY,$/;"	e	enum:__anon69	file:
R_PROTOCOL_VERSIONS	or/routerparse.c	/^  R_PROTOCOL_VERSIONS,$/;"	e	enum:__anon69	file:
R_PUBLICATION_TIME	or/routerparse.c	/^  R_PUBLICATION_TIME,$/;"	e	enum:__anon69	file:
R_RENDEZVOUS_SERVICE_DESCRIPTOR	or/routerparse.c	/^  R_RENDEZVOUS_SERVICE_DESCRIPTOR,$/;"	e	enum:__anon69	file:
R_SECRET_ID_PART	or/routerparse.c	/^  R_SECRET_ID_PART,$/;"	e	enum:__anon69	file:
R_SIGNATURE	or/routerparse.c	/^  R_SIGNATURE,$/;"	e	enum:__anon69	file:
R_VERSION	or/routerparse.c	/^  R_VERSION,$/;"	e	enum:__anon69	file:
ReachableAddresses	or/or.h	/^  config_line_t *ReachableAddresses; \/**< IP:ports our firewall allows. *\/$/;"	m	struct:__anon49
ReachableDirAddresses	or/or.h	/^  config_line_t *ReachableDirAddresses; \/**< IP:ports for Dir conns. *\/$/;"	m	struct:__anon49
ReachableORAddresses	or/or.h	/^  config_line_t *ReachableORAddresses; \/**< IP:ports for OR conns. *\/$/;"	m	struct:__anon49
RecommendedClientVersions	or/or.h	/^  config_line_t *RecommendedClientVersions;$/;"	m	struct:__anon49
RecommendedServerVersions	or/or.h	/^  config_line_t *RecommendedServerVersions;$/;"	m	struct:__anon49
RecommendedVersions	or/or.h	/^  config_line_t *RecommendedVersions;$/;"	m	struct:__anon49
RefuseUnknownExits	or/or.h	/^  int RefuseUnknownExits;$/;"	m	struct:__anon49
RegisterServiceCtrlHandlerA_fn	or/ntmain.c	/^  SERVICE_STATUS_HANDLE (WINAPI *RegisterServiceCtrlHandlerA_fn)($/;"	m	struct:service_fns	file:
RejectPlaintextPorts	or/or.h	/^  smartlist_t *RejectPlaintextPorts;$/;"	m	struct:__anon49
RelayBandwidthBurst	or/or.h	/^  uint64_t RelayBandwidthBurst; \/**< How much bandwidth, at maximum, will we$/;"	m	struct:__anon49
RelayBandwidthRate	or/or.h	/^  uint64_t RelayBandwidthRate; \/**< How much bandwidth, on average, are we$/;"	m	struct:__anon49
ReloadTorrcOnSIGHUP	or/or.h	/^  int ReloadTorrcOnSIGHUP;$/;"	m	struct:__anon49
RendConfigLines	or/or.h	/^  config_line_t *RendConfigLines; \/**< List of configuration lines$/;"	m	struct:__anon49
RendPostPeriod	or/or.h	/^  int RendPostPeriod; \/**< How often do we post each rendezvous service$/;"	m	struct:__anon49
RephistTrackTime	or/or.h	/^  int RephistTrackTime; \/**< How many seconds do we keep rephist info? *\/$/;"	m	struct:__anon49
RunAsDaemon	or/or.h	/^  int RunAsDaemon; \/**< If true, run in the background. (Unix only) *\/$/;"	m	struct:__anon49
S	common/sha256.c	/^#define S(/;"	d	file:
S1	test/test_util.c	/^#define S1(/;"	d	file:
S2	test/test_util.c	/^#define S2(/;"	d	file:
S2K_SPECIFIER_LEN	common/crypto.h	/^#define S2K_SPECIFIER_LEN /;"	d
S6_ADDR16	common/compat.h	/^#define S6_ADDR16(/;"	d
S6_ADDR32	common/compat.h	/^#define S6_ADDR32(/;"	d
SAFECOOKIE_CONTROLLER_TO_SERVER_CONSTANT	or/control.c	/^#define SAFECOOKIE_CONTROLLER_TO_SERVER_CONSTANT /;"	d	file:
SAFECOOKIE_SERVER_NONCE_LEN	or/control.c	/^#define SAFECOOKIE_SERVER_NONCE_LEN /;"	d	file:
SAFECOOKIE_SERVER_TO_CONTROLLER_CONSTANT	or/control.c	/^#define SAFECOOKIE_SERVER_TO_CONTROLLER_CONSTANT /;"	d	file:
SAFELOG_SCRUB_ALL	or/or.h	/^    SAFELOG_SCRUB_ALL, SAFELOG_SCRUB_RELAY, SAFELOG_SCRUB_NONE$/;"	e	enum:__anon49::__anon51
SAFELOG_SCRUB_NONE	or/or.h	/^    SAFELOG_SCRUB_ALL, SAFELOG_SCRUB_RELAY, SAFELOG_SCRUB_NONE$/;"	e	enum:__anon49::__anon51
SAFELOG_SCRUB_RELAY	or/or.h	/^    SAFELOG_SCRUB_ALL, SAFELOG_SCRUB_RELAY, SAFELOG_SCRUB_NONE$/;"	e	enum:__anon49::__anon51
SAVED_IN_CACHE	or/or.h	/^  SAVED_IN_CACHE,$/;"	e	enum:__anon39
SAVED_IN_JOURNAL	or/or.h	/^  SAVED_IN_JOURNAL$/;"	e	enum:__anon39
SAVED_NOWHERE	or/or.h	/^  SAVED_NOWHERE=0,$/;"	e	enum:__anon39
SAVE_STABILITY_INTERVAL	or/main.c	/^#define SAVE_STABILITY_INTERVAL /;"	d	file:
SDMAP_FOREACH	or/routerlist.c	/^#define SDMAP_FOREACH(/;"	d	file:
SECONDS_IN_A_DAY	or/relay.c	/^#define SECONDS_IN_A_DAY /;"	d	file:
SECONDS_IN_A_DAY	or/relay.c	/^#undef SECONDS_IN_A_DAY$/;"	d	file:
SEEK_CUR	common/compat.c	/^#define SEEK_CUR /;"	d	file:
SEEK_END	common/compat.c	/^#define SEEK_END /;"	d	file:
SELF_EXCLUDED_WARN_INTERVAL	or/router.c	/^#define SELF_EXCLUDED_WARN_INTERVAL /;"	d	file:
SENTINEL_LEN	common/memarea.c	/^#define SENTINEL_LEN /;"	d	file:
SENTINEL_VAL	common/memarea.c	/^#define SENTINEL_VAL /;"	d	file:
SERIAL_NUMBER_SIZE	common/tortls.c	/^#define SERIAL_NUMBER_SIZE /;"	d	file:
SERIAL_NUMBER_SIZE	common/tortls.c	/^#undef SERIAL_NUMBER_SIZE$/;"	d	file:
SERVER_CIPHER_LIST	common/tortls.c	/^#define SERVER_CIPHER_LIST /;"	d	file:
SERVICES_KEY	or/eventdns.c	/^#define SERVICES_KEY /;"	d	file:
SESSION_GROUP_CONTROL_RESOLVE	or/or.h	/^#define SESSION_GROUP_CONTROL_RESOLVE /;"	d
SESSION_GROUP_DIRCONN	or/or.h	/^#define SESSION_GROUP_DIRCONN /;"	d
SESSION_GROUP_FIRST_AUTO	or/or.h	/^#define SESSION_GROUP_FIRST_AUTO /;"	d
SESSION_GROUP_UNSET	or/or.h	/^#define SESSION_GROUP_UNSET /;"	d
SET	or/dns.c	/^#define SET(/;"	d	file:
SET	or/dns.c	/^#undef SET$/;"	d	file:
SETOPT_ERR_MISC	or/or.h	/^  SETOPT_ERR_MISC = -1,$/;"	e	enum:setopt_err_t
SETOPT_ERR_PARSE	or/or.h	/^  SETOPT_ERR_PARSE = -2,$/;"	e	enum:setopt_err_t
SETOPT_ERR_SETTING	or/or.h	/^  SETOPT_ERR_SETTING = -4,$/;"	e	enum:setopt_err_t
SETOPT_ERR_TRANSITION	or/or.h	/^  SETOPT_ERR_TRANSITION = -3,$/;"	e	enum:setopt_err_t
SETOPT_OK	or/or.h	/^  SETOPT_OK = 0,$/;"	e	enum:setopt_err_t
SET_CUTOFF	or/circuituse.c	/^#define SET_CUTOFF(/;"	d	file:
SET_SENTINEL	common/memarea.c	/^#define SET_SENTINEL(/;"	d	file:
SEVERITY_MASK_IDX	common/torlog.h	/^#define SEVERITY_MASK_IDX(/;"	d
SHA256	common/crypto.c	/^SHA256(const unsigned char *m, size_t len, unsigned char *d)$/;"	f	file:
SHA256_CTX	common/crypto.c	/^#define SHA256_CTX /;"	d	file:
SHA256_Final	common/crypto.c	/^#define SHA256_Final(/;"	d	file:
SHA256_Init	common/crypto.c	/^#define SHA256_Init /;"	d	file:
SHA256_Update	common/crypto.c	/^#define SHA256_Update /;"	d	file:
SHARES	or/rephist.c	/^#define SHARES /;"	d	file:
SHARES	or/rephist.c	/^#undef SHARES$/;"	d	file:
SHARE_DATADIR	win32/orconfig.h	/^#define SHARE_DATADIR /;"	d
SHGetPathFromIDListW	common/compat.h	/^#define SHGetPathFromIDListW /;"	d
SHORT_MAX	common/torint.h	/^#define SHORT_MAX /;"	d
SIGCLEARDNSCACHE	or/or.h	/^#define SIGCLEARDNSCACHE /;"	d
SIGHUP	or/or.h	/^#define SIGHUP /;"	d
SIGINT	or/or.h	/^#define SIGINT /;"	d
SIGNEWNYM	or/or.h	/^#define SIGNEWNYM /;"	d
SIGNING_KEY_BITS	tools/tor-gencert.c	/^#define SIGNING_KEY_BITS /;"	d	file:
SIGN_DIR	or/or.h	/^  SIGN_DIR, SIGN_RTR,$/;"	e	enum:__anon65
SIGN_RTR	or/or.h	/^  SIGN_DIR, SIGN_RTR,$/;"	e	enum:__anon65
SIGTERM	or/or.h	/^#define SIGTERM /;"	d
SIGUSR1	or/or.h	/^#define SIGUSR1 /;"	d
SIGUSR2	or/or.h	/^#define SIGUSR2 /;"	d
SIZEOF_CHAR	win32/orconfig.h	/^#define SIZEOF_CHAR /;"	d
SIZEOF_INT	win32/orconfig.h	/^#define SIZEOF_INT /;"	d
SIZEOF_INT16_T	win32/orconfig.h	/^#undef SIZEOF_INT16_T$/;"	d
SIZEOF_INT32_T	win32/orconfig.h	/^#undef SIZEOF_INT32_T$/;"	d
SIZEOF_INT64_T	win32/orconfig.h	/^#undef SIZEOF_INT64_T$/;"	d
SIZEOF_INT8_T	win32/orconfig.h	/^#undef SIZEOF_INT8_T$/;"	d
SIZEOF_LONG	win32/orconfig.h	/^#define SIZEOF_LONG /;"	d
SIZEOF_LONG_LONG	win32/orconfig.h	/^#undef SIZEOF_LONG_LONG$/;"	d
SIZEOF_SHORT	win32/orconfig.h	/^#define SIZEOF_SHORT /;"	d
SIZEOF_SIZE_T	win32/orconfig.h	/^#define SIZEOF_SIZE_T /;"	d
SIZEOF_TIME_T	win32/orconfig.h	/^#define SIZEOF_TIME_T /;"	d
SIZEOF_UINT16_T	win32/orconfig.h	/^#undef SIZEOF_UINT16_T$/;"	d
SIZEOF_UINT32_T	win32/orconfig.h	/^#undef SIZEOF_UINT32_T$/;"	d
SIZEOF_UINT64_T	win32/orconfig.h	/^#undef SIZEOF_UINT64_T$/;"	d
SIZEOF_UINT8_T	win32/orconfig.h	/^#undef SIZEOF_UINT8_T$/;"	d
SIZEOF_VOID_P	win32/orconfig.h	/^#define SIZEOF_VOID_P /;"	d
SIZEOF___INT64	win32/orconfig.h	/^#define SIZEOF___INT64 /;"	d
SIZE_MAX	common/OpenBSD_malloc_Linux.c	/^#define SIZE_MAX /;"	d	file:
SIZE_T_CEILING	common/torint.h	/^#define SIZE_T_CEILING /;"	d
SIZE_T_MAX	common/torint.h	/^#define SIZE_T_MAX /;"	d
SKIP	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	e	enum:outcome	file:
SKIP_NAME	or/eventdns.c	/^#undef SKIP_NAME$/;"	d	file:
SMALLEST_MANAGED_LINE_SIZE	or/transports.c	/^#define SMALLEST_MANAGED_LINE_SIZE /;"	d	file:
SMARTLIST_DEFAULT_CAPACITY	common/container.c	/^#define SMARTLIST_DEFAULT_CAPACITY /;"	d	file:
SMARTLIST_DEL_CURRENT	common/container.h	/^#define SMARTLIST_DEL_CURRENT(/;"	d
SMARTLIST_FOREACH	common/container.h	/^#define SMARTLIST_FOREACH(/;"	d
SMARTLIST_FOREACH_BEGIN	common/container.h	/^#define SMARTLIST_FOREACH_BEGIN(/;"	d
SMARTLIST_FOREACH_END	common/container.h	/^#define SMARTLIST_FOREACH_END(/;"	d
SMARTLIST_FOREACH_JOIN	common/container.h	/^#define SMARTLIST_FOREACH_JOIN(/;"	d
SMARTLIST_FOREACH_JOIN_END	common/container.h	/^#define SMARTLIST_FOREACH_JOIN_END(/;"	d
SMARTLIST_REPLACE_CURRENT	common/container.h	/^#define SMARTLIST_REPLACE_CURRENT(/;"	d
SOCKET_OK	common/compat.h	/^#define SOCKET_OK(/;"	d
SOCKS4_GRANTED	or/connection_edge.c	/^#define SOCKS4_GRANTED /;"	d	file:
SOCKS4_NETWORK_LEN	or/or.h	/^#define SOCKS4_NETWORK_LEN /;"	d
SOCKS4_REJECT	or/connection_edge.c	/^#define SOCKS4_REJECT /;"	d	file:
SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED	common/compat.h	/^  SOCKS5_ADDRESS_TYPE_NOT_SUPPORTED = 0x08,$/;"	e	enum:__anon7
SOCKS5_COMMAND_NOT_SUPPORTED	common/compat.h	/^  SOCKS5_COMMAND_NOT_SUPPORTED      = 0x07,$/;"	e	enum:__anon7
SOCKS5_CONNECTION_REFUSED	common/compat.h	/^  SOCKS5_CONNECTION_REFUSED         = 0x05,$/;"	e	enum:__anon7
SOCKS5_GENERAL_ERROR	common/compat.h	/^  SOCKS5_GENERAL_ERROR              = 0x01,$/;"	e	enum:__anon7
SOCKS5_HOST_UNREACHABLE	common/compat.h	/^  SOCKS5_HOST_UNREACHABLE           = 0x04,$/;"	e	enum:__anon7
SOCKS5_NET_UNREACHABLE	common/compat.h	/^  SOCKS5_NET_UNREACHABLE            = 0x03,$/;"	e	enum:__anon7
SOCKS5_NOT_ALLOWED	common/compat.h	/^  SOCKS5_NOT_ALLOWED                = 0x02,$/;"	e	enum:__anon7
SOCKS5_SUCCEEDED	common/compat.h	/^  SOCKS5_SUCCEEDED                  = 0x00,$/;"	e	enum:__anon7
SOCKS5_TTL_EXPIRED	common/compat.h	/^  SOCKS5_TTL_EXPIRED                = 0x06,$/;"	e	enum:__anon7
SOCKSENT	test/test.c	/^#define SOCKSENT(/;"	d	file:
SOCKS_COMMAND_CONNECT	or/or.h	/^#define SOCKS_COMMAND_CONNECT /;"	d
SOCKS_COMMAND_IS_CONNECT	or/or.h	/^#define SOCKS_COMMAND_IS_CONNECT(/;"	d
SOCKS_COMMAND_IS_RESOLVE	or/or.h	/^#define SOCKS_COMMAND_IS_RESOLVE(/;"	d
SOCKS_COMMAND_RESOLVE	or/or.h	/^#define SOCKS_COMMAND_RESOLVE /;"	d
SOCKS_COMMAND_RESOLVE_PTR	or/or.h	/^#define SOCKS_COMMAND_RESOLVE_PTR /;"	d
SOCKS_NO_AUTH	or/or.h	/^#define SOCKS_NO_AUTH /;"	d
SOCKS_TEST_INIT	test/test.c	/^#define SOCKS_TEST_INIT(/;"	d	file:
SOCKS_USER_PASS	or/or.h	/^#define SOCKS_USER_PASS /;"	d
SOCKS_WARN_INTERVAL	or/buffers.c	/^#define SOCKS_WARN_INTERVAL /;"	d	file:
SOFT_LIM_BYTES	or/hibernate.c	/^#define SOFT_LIM_BYTES /;"	d	file:
SOFT_LIM_MINUTES	or/hibernate.c	/^#define SOFT_LIM_MINUTES /;"	d	file:
SOFT_LIM_PCT	or/hibernate.c	/^#define SOFT_LIM_PCT /;"	d	file:
SOME_JUNK	common/OpenBSD_malloc_Linux.c	/^#define SOME_JUNK	/;"	d	file:
SP	common/crypto.c	/^#define SP /;"	d	file:
SP	common/crypto.c	/^#undef SP$/;"	d	file:
SPAWN_ERROR_MESSAGE	common/util.h	/^#define SPAWN_ERROR_MESSAGE /;"	d
SPLIT_IGNORE_BLANK	common/container.h	/^#define SPLIT_IGNORE_BLANK /;"	d
SPLIT_SKIP_SPACE	common/container.h	/^#define SPLIT_SKIP_SPACE /;"	d
SPLIT_STRIP_SPACE	common/container.h	/^#define SPLIT_STRIP_SPACE /;"	d
SSIZE_T_CEILING	common/torint.h	/^#define SSIZE_T_CEILING /;"	d
SSIZE_T_MAX	common/torint.h	/^#define SSIZE_T_MAX /;"	d
SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	common/tortls.c	/^#define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION /;"	d	file:
SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION	common/tortls.c	/^#define SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION /;"	d	file:
STABILITY_ALPHA	or/rephist.c	/^#define STABILITY_ALPHA /;"	d	file:
STABILITY_EPSILON	or/rephist.c	/^#define STABILITY_EPSILON /;"	d	file:
STABILITY_INTERVAL	or/rephist.c	/^#define STABILITY_INTERVAL /;"	d	file:
STACK_OF	common/tortls.c	/^rectify_client_ciphers(STACK_OF(SSL_CIPHER) **ciphers)$/;"	f	file:
STATE_IS_OPEN	or/control.c	/^#define STATE_IS_OPEN(/;"	d	file:
STATE_RELAY_CHECKPOINT_INTERVAL	or/config.c	/^#define STATE_RELAY_CHECKPOINT_INTERVAL /;"	d	file:
STATE_WRITE_RETRY_INTERVAL	or/config.c	/^#define STATE_WRITE_RETRY_INTERVAL /;"	d	file:
STATICLIB	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^#define STATICLIB$/;"	d	file:
STATICLIB	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define STATICLIB$/;"	d	file:
STDC_HEADERS	win32/orconfig.h	/^#define STDC_HEADERS$/;"	d
STMT_BEGIN	common/compat.h	/^#define STMT_BEGIN /;"	d
STMT_END	common/compat.h	/^#define STMT_END /;"	d
STMT_NIL	common/compat.h	/^#define STMT_NIL /;"	d
STMT_VOID	common/compat.h	/^#define STMT_VOID(/;"	d
STORE32H	common/sha256.c	/^#define STORE32H(/;"	d	file:
STORE64H	common/sha256.c	/^#define STORE64H(/;"	d	file:
STRDUP	or/routerparse.c	/^#define STRDUP(/;"	d	file:
STRDUP	or/routerparse.c	/^#undef STRDUP$/;"	d	file:
STREAMWINDOW_INCREMENT	or/or.h	/^#define STREAMWINDOW_INCREMENT /;"	d
STREAMWINDOW_START	or/or.h	/^#define STREAMWINDOW_START /;"	d
STREAM_EVENT_CLOSED	or/or.h	/^  STREAM_EVENT_CLOSED       = 4,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_FAILED	or/or.h	/^  STREAM_EVENT_FAILED       = 3,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_FAILED_RETRIABLE	or/or.h	/^  STREAM_EVENT_FAILED_RETRIABLE = 7,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_NEW	or/or.h	/^  STREAM_EVENT_NEW          = 5,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_NEW_RESOLVE	or/or.h	/^  STREAM_EVENT_NEW_RESOLVE  = 6,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_REMAP	or/or.h	/^  STREAM_EVENT_REMAP        = 8$/;"	e	enum:stream_status_event_t
STREAM_EVENT_SENT_CONNECT	or/or.h	/^  STREAM_EVENT_SENT_CONNECT = 0,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_SENT_RESOLVE	or/or.h	/^  STREAM_EVENT_SENT_RESOLVE = 1,$/;"	e	enum:stream_status_event_t
STREAM_EVENT_SUCCEEDED	or/or.h	/^  STREAM_EVENT_SUCCEEDED    = 2,$/;"	e	enum:stream_status_event_t
STRMAP_FOREACH	common/container.h	/^#define STRMAP_FOREACH(/;"	d
STRMAP_FOREACH_END	common/container.h	/^#define STRMAP_FOREACH_END /;"	d
STRMAP_FOREACH_MODIFY	common/container.h	/^#define STRMAP_FOREACH_MODIFY(/;"	d
STRNDUP	or/routerparse.c	/^#define STRNDUP(/;"	d	file:
STRNDUP	or/routerparse.c	/^#undef STRNDUP$/;"	d	file:
STRUCT_OFFSET	common/mempool.c	/^#define STRUCT_OFFSET(/;"	d	file:
STRUCT_OFFSET	common/util.h	/^ #define STRUCT_OFFSET(/;"	d
STRUCT_OFFSET	common/util.h	/^#define STRUCT_OFFSET(/;"	d
STRUCT_VAR_P	common/util.h	/^#define STRUCT_VAR_P(/;"	d
STUB_REGENERATE_INTERVAL	or/dirserv.c	/^#define STUB_REGENERATE_INTERVAL /;"	d	file:
SUBENT	test/test.c	/^#define SUBENT(/;"	d	file:
SUBTRACT_CLAMPED	or/rephist.c	/^#define SUBTRACT_CLAMPED(/;"	d	file:
SUBTYPE_P	common/util.h	/^#define SUBTYPE_P(/;"	d
S_CASE	or/reasons.c	/^#define S_CASE(/;"	d	file:
SafeLogging	or/or.h	/^  char *SafeLogging; \/**< Contains "relay", "1", "0" (meaning no scrubbing). *\/$/;"	m	struct:__anon49
SafeSocks	or/or.h	/^  int SafeSocks; \/**< Boolean: should we outright refuse application$/;"	m	struct:__anon49
ServerDNSAllowBrokenConfig	or/or.h	/^  int ServerDNSAllowBrokenConfig;$/;"	m	struct:__anon49
ServerDNSAllowNonRFC953Hostnames	or/or.h	/^  int ServerDNSAllowNonRFC953Hostnames;$/;"	m	struct:__anon49
ServerDNSDetectHijacking	or/or.h	/^  int ServerDNSDetectHijacking; \/**< Boolean: If true, check for DNS failure$/;"	m	struct:__anon49
ServerDNSRandomizeCase	or/or.h	/^  int ServerDNSRandomizeCase; \/**< Boolean: Use the 0x20-hack to prevent$/;"	m	struct:__anon49
ServerDNSResolvConfFile	or/or.h	/^  char *ServerDNSResolvConfFile; \/**< If provided, we configure our internal$/;"	m	struct:__anon49
ServerDNSSearchDomains	or/or.h	/^  int ServerDNSSearchDomains; \/**< Boolean: If set, we don't force exit$/;"	m	struct:__anon49
ServerDNSTestAddresses	or/or.h	/^  smartlist_t *ServerDNSTestAddresses; \/**< A list of addresses that definitely$/;"	m	struct:__anon49
ServerTransportPlugin	or/or.h	/^  config_line_t *ServerTransportPlugin; \/**< List of client$/;"	m	struct:__anon49
SetServiceStatus_fn	or/ntmain.c	/^  BOOL (WINAPI *SetServiceStatus_fn)(SERVICE_STATUS_HANDLE,$/;"	m	struct:service_fns	file:
ShutdownWaitLength	or/or.h	/^  int ShutdownWaitLength; \/**< When we get a SIGINT and we're a server, how$/;"	m	struct:__anon49
Sigma0	common/sha256.c	/^#define Sigma0(/;"	d	file:
Sigma1	common/sha256.c	/^#define Sigma1(/;"	d	file:
Socks4Proxy	or/or.h	/^  char *Socks4Proxy; \/**< hostname:port to use as a SOCKS4 proxy, if any. *\/$/;"	m	struct:__anon49
Socks4ProxyAddr	or/or.h	/^  tor_addr_t Socks4ProxyAddr; \/**< Derived from Socks4Proxy. *\/$/;"	m	struct:__anon49
Socks4ProxyPort	or/or.h	/^  uint16_t Socks4ProxyPort; \/**< Derived from Socks4Proxy. *\/$/;"	m	struct:__anon49
Socks5Proxy	or/or.h	/^  char *Socks5Proxy; \/**< hostname:port to use as a SOCKS5 proxy, if any. *\/$/;"	m	struct:__anon49
Socks5ProxyAddr	or/or.h	/^  tor_addr_t Socks5ProxyAddr; \/**< Derived from Sock5Proxy. *\/$/;"	m	struct:__anon49
Socks5ProxyPassword	or/or.h	/^  char *Socks5ProxyPassword; \/**< Password for SOCKS5 authentication, if any *\/$/;"	m	struct:__anon49
Socks5ProxyPort	or/or.h	/^  uint16_t Socks5ProxyPort; \/**< Derived from Socks5Proxy. *\/$/;"	m	struct:__anon49
Socks5ProxyUsername	or/or.h	/^  char *Socks5ProxyUsername; \/**< Username for SOCKS5 authentication, if any *\/$/;"	m	struct:__anon49
SocksListenAddress	or/or.h	/^  config_line_t *SocksListenAddress;$/;"	m	struct:__anon49
SocksPolicy	or/or.h	/^  config_line_t *SocksPolicy; \/**< Lists of socks policy components *\/$/;"	m	struct:__anon49
SocksPort	or/or.h	/^  config_line_t *SocksPort; \/**< Ports to listen on for SOCKS connections. *\/$/;"	m	struct:__anon49
SocksTimeout	or/or.h	/^  int SocksTimeout; \/**< How long do we let a socks connection wait$/;"	m	struct:__anon49
StartServiceA_fn	or/ntmain.c	/^  BOOL (WINAPI *StartServiceA_fn)($/;"	m	struct:service_fns	file:
StartServiceCtrlDispatcherA_fn	or/ntmain.c	/^  BOOL (WINAPI *StartServiceCtrlDispatcherA_fn)($/;"	m	struct:service_fns	file:
StrictNodes	or/or.h	/^  int StrictNodes; \/**< Boolean: When none of our EntryNodes or ExitNodes$/;"	m	struct:__anon49
T	or/routerparse.c	/^#define T(/;"	d	file:
T	or/routerparse.c	/^#undef T$/;"	d	file:
T	test/test_util.c	/^#define T(/;"	d	file:
T01	or/routerparse.c	/^#define T01(/;"	d	file:
T0N	or/routerparse.c	/^#define T0N(/;"	d	file:
T1	or/routerparse.c	/^#define T1(/;"	d	file:
T1N	or/routerparse.c	/^#define T1N(/;"	d	file:
T1_END	or/routerparse.c	/^#define T1_END(/;"	d	file:
T1_START	or/routerparse.c	/^#define T1_START(/;"	d	file:
TAG_LEN	or/cpuworker.c	/^#define TAG_LEN /;"	d	file:
TESTING_CIRCUIT_INTERVAL	or/circuituse.c	/^#define TESTING_CIRCUIT_INTERVAL /;"	d	file:
TEST_NAME	or/eventdns.c	/^#define TEST_NAME /;"	d	file:
TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT	or/or.h	/^#define TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT /;"	d
TIME_BEFORE_OR_CONN_IS_TOO_OLD	or/connection_or.c	/^#define TIME_BEFORE_OR_CONN_IS_TOO_OLD /;"	d	file:
TIME_FNS_NEED_LOCKS	common/compat.c	/^#define TIME_FNS_NEED_LOCKS$/;"	d	file:
TIME_KNOWN_TO_GUARANTEE_FAMILIAR	or/dirserv.c	/^#define TIME_KNOWN_TO_GUARANTEE_FAMILIAR /;"	d	file:
TIME_MAX	common/torint.h	/^#define TIME_MAX /;"	d
TIME_TO_EXEC_FWHELPER_FAIL	common/util.c	/^#define TIME_TO_EXEC_FWHELPER_FAIL /;"	d	file:
TIME_TO_EXEC_FWHELPER_SUCCESS	common/util.c	/^#define TIME_TO_EXEC_FWHELPER_SUCCESS /;"	d	file:
TIME_T_IS_SIGNED	win32/orconfig.h	/^#define TIME_T_IS_SIGNED$/;"	d
TINYTEST_H_INCLUDED_	test/tinytest.h	/^#define TINYTEST_H_INCLUDED_$/;"	d
TINYTEST_MACROS_H_INCLUDED_	test/tinytest_macros.h	/^#define TINYTEST_MACROS_H_INCLUDED_$/;"	d
TLSSECRET_MAGIC	common/tortls.c	/^#define TLSSECRET_MAGIC /;"	d	file:
TLS_HANDSHAKE_C	or/or.h	/^  TLS_HANDSHAKE_C, TLS_HANDSHAKE_S,$/;"	e	enum:__anon65
TLS_HANDSHAKE_S	or/or.h	/^  TLS_HANDSHAKE_C, TLS_HANDSHAKE_S,$/;"	e	enum:__anon65
TLS_HANDSHAKE_TIMEOUT	or/main.c	/^#define TLS_HANDSHAKE_TIMEOUT /;"	d	file:
TOLERATE_MICRODESC_AGE	or/microdesc.c	/^#define TOLERATE_MICRODESC_AGE /;"	d	file:
TOLOWER	or/eventdns.c	/^#define TOLOWER(/;"	d	file:
TOR	common/mempool.c	/^#define TOR$/;"	d	file:
TORTLS_PRIVATE	common/tortls.c	/^#define TORTLS_PRIVATE$/;"	d	file:
TOR_ADDR_BUF_LEN	common/address.h	/^#define TOR_ADDR_BUF_LEN /;"	d
TOR_ADDR_NULL	common/address.h	/^#define TOR_ADDR_NULL /;"	d
TOR_DI_OPS_H	common/di_ops.h	/^#define TOR_DI_OPS_H$/;"	d
TOR_INVALID_SOCKET	common/compat.h	/^#define TOR_INVALID_SOCKET /;"	d
TOR_ISALNUM_TABLE	common/compat.c	/^const uint32_t TOR_ISALNUM_TABLE[8] =$/;"	v
TOR_ISALPHA_TABLE	common/compat.c	/^const uint32_t TOR_ISALPHA_TABLE[8] =$/;"	v
TOR_ISDIGIT_TABLE	common/compat.c	/^const uint32_t TOR_ISDIGIT_TABLE[8] = { 0, 0x3ff0000, 0, 0, 0, 0, 0, 0 };$/;"	v
TOR_ISLOWER_TABLE	common/compat.c	/^const uint32_t TOR_ISLOWER_TABLE[8] = { 0, 0, 0, 0x7fffffe, 0, 0, 0, 0 };$/;"	v
TOR_ISODIGIT	common/util.c	/^#define TOR_ISODIGIT(/;"	d	file:
TOR_ISPRINT_TABLE	common/compat.c	/^const uint32_t TOR_ISPRINT_TABLE[8] =$/;"	v
TOR_ISSPACE_TABLE	common/compat.c	/^const uint32_t TOR_ISSPACE_TABLE[8] = { 0x3e00, 0x1, 0, 0, 0, 0, 0, 0 };$/;"	v
TOR_ISUPPER_TABLE	common/compat.c	/^const uint32_t TOR_ISUPPER_TABLE[8] = { 0, 0, 0x7fffffe, 0, 0, 0, 0, 0 };$/;"	v
TOR_ISXDIGIT_TABLE	common/compat.c	/^const uint32_t TOR_ISXDIGIT_TABLE[8] =$/;"	v
TOR_IS_MULTITHREADED	common/compat.h	/^#define TOR_IS_MULTITHREADED /;"	d
TOR_IS_MULTITHREADED	common/compat.h	/^#undef TOR_IS_MULTITHREADED$/;"	d
TOR_PROCMON_H	common/procmon.h	/^#define TOR_PROCMON_H$/;"	d
TOR_RAND_MAX	common/compat.h	/^#define TOR_RAND_MAX /;"	d
TOR_TLS_CLOSE	common/tortls.h	/^#define TOR_TLS_CLOSE /;"	d
TOR_TLS_DONE	common/tortls.h	/^#define TOR_TLS_DONE /;"	d
TOR_TLS_ERROR_CONNREFUSED	common/tortls.h	/^#define TOR_TLS_ERROR_CONNREFUSED /;"	d
TOR_TLS_ERROR_CONNRESET	common/tortls.h	/^#define TOR_TLS_ERROR_CONNRESET /;"	d
TOR_TLS_ERROR_IO	common/tortls.h	/^#define TOR_TLS_ERROR_IO /;"	d
TOR_TLS_ERROR_MISC	common/tortls.h	/^#define TOR_TLS_ERROR_MISC /;"	d
TOR_TLS_ERROR_NO_ROUTE	common/tortls.h	/^#define TOR_TLS_ERROR_NO_ROUTE /;"	d
TOR_TLS_ERROR_TIMEOUT	common/tortls.h	/^#define TOR_TLS_ERROR_TIMEOUT /;"	d
TOR_TLS_IS_ERROR	common/tortls.h	/^#define TOR_TLS_IS_ERROR(/;"	d
TOR_TLS_MAGIC	common/tortls.c	/^#define TOR_TLS_MAGIC /;"	d	file:
TOR_TLS_ST_BUFFEREVENT	common/tortls.c	/^    TOR_TLS_ST_BUFFEREVENT$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_CLOSED	common/tortls.c	/^    TOR_TLS_ST_SENTCLOSE, TOR_TLS_ST_CLOSED, TOR_TLS_ST_RENEGOTIATE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_GOTCLOSE	common/tortls.c	/^    TOR_TLS_ST_HANDSHAKE, TOR_TLS_ST_OPEN, TOR_TLS_ST_GOTCLOSE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_HANDSHAKE	common/tortls.c	/^    TOR_TLS_ST_HANDSHAKE, TOR_TLS_ST_OPEN, TOR_TLS_ST_GOTCLOSE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_OPEN	common/tortls.c	/^    TOR_TLS_ST_HANDSHAKE, TOR_TLS_ST_OPEN, TOR_TLS_ST_GOTCLOSE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_RENEGOTIATE	common/tortls.c	/^    TOR_TLS_ST_SENTCLOSE, TOR_TLS_ST_CLOSED, TOR_TLS_ST_RENEGOTIATE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_ST_SENTCLOSE	common/tortls.c	/^    TOR_TLS_ST_SENTCLOSE, TOR_TLS_ST_CLOSED, TOR_TLS_ST_RENEGOTIATE,$/;"	e	enum:tor_tls_t::__anon16	file:
TOR_TLS_WANTREAD	common/tortls.h	/^#define TOR_TLS_WANTREAD /;"	d
TOR_TLS_WANTWRITE	common/tortls.h	/^#define TOR_TLS_WANTWRITE /;"	d
TOR_TOLOWER	common/compat.h	/^#define TOR_TOLOWER(/;"	d
TOR_TOLOWER_TABLE	common/compat.c	/^const char TOR_TOLOWER_TABLE[256] = {$/;"	v
TOR_TOUPPER	common/compat.h	/^#define TOR_TOUPPER(/;"	d
TOR_TOUPPER_TABLE	common/compat.c	/^const char TOR_TOUPPER_TABLE[256] = {$/;"	v
TOR_TRANSPORTS_H	or/transports.h	/^#define TOR_TRANSPORTS_H$/;"	d
TOR_ZLIB_BUF_FULL	common/torgzip.h	/^  TOR_ZLIB_OK, TOR_ZLIB_DONE, TOR_ZLIB_BUF_FULL, TOR_ZLIB_ERR$/;"	e	enum:__anon15
TOR_ZLIB_DONE	common/torgzip.h	/^  TOR_ZLIB_OK, TOR_ZLIB_DONE, TOR_ZLIB_BUF_FULL, TOR_ZLIB_ERR$/;"	e	enum:__anon15
TOR_ZLIB_ERR	common/torgzip.h	/^  TOR_ZLIB_OK, TOR_ZLIB_DONE, TOR_ZLIB_BUF_FULL, TOR_ZLIB_ERR$/;"	e	enum:__anon15
TOR_ZLIB_OK	common/torgzip.h	/^  TOR_ZLIB_OK, TOR_ZLIB_DONE, TOR_ZLIB_BUF_FULL, TOR_ZLIB_ERR$/;"	e	enum:__anon15
TOUPPER	or/eventdns.c	/^#define TOUPPER(/;"	d	file:
TO_CIRCUIT	or/or.h	/^#define TO_CIRCUIT(/;"	d
TO_CONN	or/or.h	/^#define TO_CONN(/;"	d
TO_CONTROL_CONN	or/or.h	/^static INLINE control_connection_t *TO_CONTROL_CONN(connection_t *c)$/;"	f
TO_DIR_CONN	or/or.h	/^static INLINE dir_connection_t *TO_DIR_CONN(connection_t *c)$/;"	f
TO_EDGE_CONN	or/or.h	/^static INLINE edge_connection_t *TO_EDGE_CONN(connection_t *c)$/;"	f
TO_ENTRY_CONN	or/or.h	/^static INLINE entry_connection_t *TO_ENTRY_CONN(connection_t *c)$/;"	f
TO_LISTENER_CONN	or/or.h	/^static INLINE listener_connection_t *TO_LISTENER_CONN(connection_t *c)$/;"	f
TO_ORIGIN_CIRCUIT	or/or.h	/^static INLINE origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *x)$/;"	f
TO_OR_CIRCUIT	or/or.h	/^static INLINE or_circuit_t *TO_OR_CIRCUIT(circuit_t *x)$/;"	f
TO_OR_CONN	or/or.h	/^static INLINE or_connection_t *TO_OR_CONN(connection_t *c)$/;"	f
TO_SERVER_REQUEST	or/eventdns.c	/^#define TO_SERVER_REQUEST(/;"	d	file:
TRACKHOSTEXITS_RETRIES	or/connection_edge.c	/^#define TRACKHOSTEXITS_RETRIES /;"	d	file:
TRANS_NETFILTER	or/connection_edge.c	/^#define TRANS_NETFILTER$/;"	d	file:
TRANS_PF	or/connection_edge.c	/^#define TRANS_PF$/;"	d	file:
TRISTATE	common/address.c	/^#define TRISTATE(/;"	d	file:
TRUNCATED_STR	common/log.c	/^#define TRUNCATED_STR /;"	d	file:
TRUNCATED_STR_LEN	common/log.c	/^#define TRUNCATED_STR_LEN /;"	d	file:
TRY	or/eventdns.c	/^#define TRY(/;"	d	file:
TRY	or/eventdns.c	/^#undef TRY$/;"	d	file:
TS_ANNOTATIONS_OK	or/routerparse.c	/^#define TS_ANNOTATIONS_OK /;"	d	file:
TS_NOCHECK	or/routerparse.c	/^#define TS_NOCHECK /;"	d	file:
TS_NO_NEW_ANNOTATIONS	or/routerparse.c	/^#define TS_NO_NEW_ANNOTATIONS /;"	d	file:
TT_BLATHER	test/tinytest_macros.h	/^#define TT_BLATHER(/;"	d
TT_DECLARE	test/tinytest_macros.h	/^#define TT_DECLARE(/;"	d
TT_DIE	test/tinytest_macros.h	/^#define TT_DIE(/;"	d
TT_ENABLED_	test/tinytest.h	/^#define TT_ENABLED_ /;"	d
TT_EXIT_TEST_FUNCTION	test/test.h	/^#define TT_EXIT_TEST_FUNCTION /;"	d
TT_EXIT_TEST_FUNCTION	test/tinytest_macros.h	/^#define TT_EXIT_TEST_FUNCTION /;"	d
TT_FAIL	test/tinytest_macros.h	/^#define TT_FAIL(/;"	d
TT_FIRST_USER_FLAG	test/tinytest.h	/^#define TT_FIRST_USER_FLAG /;"	d
TT_FORK	test/tinytest.h	/^#define TT_FORK /;"	d
TT_GRIPE	test/tinytest_macros.h	/^#define TT_GRIPE(/;"	d
TT_SKIP	test/tinytest.h	/^#define TT_SKIP /;"	d
TT_STMT_BEGIN	test/tinytest_macros.h	/^#define TT_STMT_BEGIN /;"	d
TT_STMT_END	test/tinytest_macros.h	/^#define TT_STMT_END /;"	d
TYPE_A	or/eventdns.c	/^#define TYPE_A	/;"	d	file:
TYPE_AAAA	or/eventdns.c	/^#define TYPE_AAAA	/;"	d	file:
TYPE_CNAME	or/eventdns.c	/^#define TYPE_CNAME	/;"	d	file:
TYPE_PTR	or/eventdns.c	/^#define TYPE_PTR	/;"	d	file:
TestSocks	or/or.h	/^  int TestSocks; \/**< Boolean: when we get a socks connection, do we loudly$/;"	m	struct:__anon49
TestingAuthDirTimeToLearnReachability	or/or.h	/^  int TestingAuthDirTimeToLearnReachability;$/;"	m	struct:__anon49
TestingEstimatedDescriptorPropagationTime	or/or.h	/^  int TestingEstimatedDescriptorPropagationTime;$/;"	m	struct:__anon49
TestingTorNetwork	or/or.h	/^  int TestingTorNetwork;$/;"	m	struct:__anon49
TestingV3AuthInitialDistDelay	or/or.h	/^  int TestingV3AuthInitialDistDelay;$/;"	m	struct:__anon49
TestingV3AuthInitialVoteDelay	or/or.h	/^  int TestingV3AuthInitialVoteDelay;$/;"	m	struct:__anon49
TestingV3AuthInitialVotingInterval	or/or.h	/^  int TestingV3AuthInitialVotingInterval;$/;"	m	struct:__anon49
TokenBucketRefillInterval	or/or.h	/^  int TokenBucketRefillInterval;$/;"	m	struct:__anon49
Tor2webMode	or/or.h	/^  int Tor2webMode;$/;"	m	struct:__anon49
TorVersion	or/or.h	/^  char *TorVersion;$/;"	m	struct:__anon52
TotalBuildTimes	or/or.h	/^  unsigned int TotalBuildTimes;$/;"	m	struct:__anon52
TrackHostExits	or/or.h	/^  smartlist_t *TrackHostExits;$/;"	m	struct:__anon49
TrackHostExitsExpire	or/or.h	/^  int TrackHostExitsExpire; \/**< Number of seconds until we expire an$/;"	m	struct:__anon49
TransListenAddress	or/or.h	/^  config_line_t *TransListenAddress;$/;"	m	struct:__anon49
TransPort	or/or.h	/^  config_line_t *TransPort;$/;"	m	struct:__anon49
TransportProxies	or/or.h	/^  config_line_t *TransportProxies;$/;"	m	struct:__anon52
TunnelDirConns	or/or.h	/^  int TunnelDirConns; \/**< If true, use BEGIN_DIR rather than BEGIN when$/;"	m	struct:__anon49
U64_FORMAT	common/compat.h	/^#define U64_FORMAT /;"	d
U64_LITERAL	common/compat.h	/^#define U64_LITERAL(/;"	d
U64_PRINTF_ARG	common/compat.h	/^#define U64_PRINTF_ARG(/;"	d
U64_SCANF_ARG	common/compat.h	/^#define U64_SCANF_ARG(/;"	d
U64_TO_DBL	common/compat.h	/^#define U64_TO_DBL(/;"	d
U64_TO_DBL	common/compat.h	/^extern INLINE double U64_TO_DBL(uint64_t x) {$/;"	f
UINT16_MAX	common/torint.h	/^#define UINT16_MAX /;"	d
UINT32_MAX	common/torint.h	/^#define UINT32_MAX /;"	d
UINT64_MAX	common/torint.h	/^#define UINT64_MAX /;"	d
UINT_MAX	common/torint.h	/^#define UINT_MAX /;"	d
UINT_MAX_AS_DOUBLE	common/crypto.c	/^#define UINT_MAX_AS_DOUBLE /;"	d	file:
ULIMIT_BUFFER	common/compat.c	/^#define ULIMIT_BUFFER /;"	d	file:
UNALIGNED_INT_ACCESS_OK	win32/orconfig.h	/^#define UNALIGNED_INT_ACCESS_OK$/;"	d
UNITS_PER_SEC	common/compat.c	/^#define UNITS_PER_SEC /;"	d	file:
UNITS_PER_USEC	common/compat.c	/^#define UNITS_PER_USEC /;"	d	file:
UNIT_DAY	or/hibernate.c	/^  UNIT_MONTH=1, UNIT_WEEK=2, UNIT_DAY=3,$/;"	e	enum:__anon32	file:
UNIT_MONTH	or/hibernate.c	/^  UNIT_MONTH=1, UNIT_WEEK=2, UNIT_DAY=3,$/;"	e	enum:__anon32	file:
UNIT_WEEK	or/hibernate.c	/^  UNIT_MONTH=1, UNIT_WEEK=2, UNIT_DAY=3,$/;"	e	enum:__anon32	file:
UNKNOWN_METHOD	common/torgzip.h	/^  NO_METHOD=0, GZIP_METHOD=1, ZLIB_METHOD=2, UNKNOWN_METHOD=3$/;"	e	enum:__anon14
UNLOCK_LOGS	common/log.c	/^#define UNLOCK_LOGS(/;"	d	file:
UNNAMED_ROUTER_NICKNAME	or/or.h	/^#define UNNAMED_ROUTER_NICKNAME /;"	d
UPDATE	or/rephist.c	/^#define UPDATE(/;"	d	file:
UPDATE	or/rephist.c	/^#undef UPDATE$/;"	d	file:
UPDATE_CTR_BUF	common/aes.c	/^#define UPDATE_CTR_BUF(/;"	d	file:
UPDATE_IDX	common/container.c	/^#define UPDATE_IDX(/;"	d	file:
UPNP_DESC	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_DESC /;"	d	file:
UPNP_DISCOVER_TIMEOUT	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_DISCOVER_TIMEOUT /;"	d	file:
UPNP_ERR_ADDPORTMAPPING	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_ADDPORTMAPPING /;"	d	file:
UPNP_ERR_DELPORTMAPPING	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_DELPORTMAPPING /;"	d	file:
UPNP_ERR_GETEXTERNALIP	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_GETEXTERNALIP /;"	d	file:
UPNP_ERR_GETPORTMAPPING	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_GETPORTMAPPING /;"	d	file:
UPNP_ERR_INVAL	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_INVAL /;"	d	file:
UPNP_ERR_NODEVICESFOUND	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_NODEVICESFOUND /;"	d	file:
UPNP_ERR_NOIGDFOUND	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_NOIGDFOUND /;"	d	file:
UPNP_ERR_OTHER	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_OTHER /;"	d	file:
UPNP_ERR_SUCCESS	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_ERR_SUCCESS /;"	d	file:
UPNP_LANADDR_SZ	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^#define UPNP_LANADDR_SZ /;"	d
UPNP_SUCCESS	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^#define UPNP_SUCCESS /;"	d	file:
UPTIME_CUTOFF_FOR_NEW_BANDWIDTH_TEST	or/main.c	/^#define UPTIME_CUTOFF_FOR_NEW_BANDWIDTH_TEST /;"	d	file:
UPTIME_TO_GUARANTEE_STABLE	or/dirserv.c	/^#define UPTIME_TO_GUARANTEE_STABLE /;"	d	file:
USEC_PER_SEC	common/compat.c	/^#define USEC_PER_SEC /;"	d	file:
USE_EVP_AES_CTR	common/aes.c	/^#define USE_EVP_AES_CTR$/;"	d	file:
USE_PTHREADS	common/compat.h	/^#define USE_PTHREADS$/;"	d
USE_SENTINELS	common/memarea.c	/^#define USE_SENTINELS$/;"	d	file:
USE_WIN32_THREADS	common/compat.h	/^#define USE_WIN32_THREADS$/;"	d
USING_COUNTER_VARS	common/aes.c	/^#define USING_COUNTER_VARS$/;"	d	file:
USING_TWOS_COMPLEMENT	win32/orconfig.h	/^#define USING_TWOS_COMPLEMENT$/;"	d
UTIL_LEGACY	test/test_util.c	/^#define UTIL_LEGACY(/;"	d	file:
UTIL_PRIVATE	common/util.c	/^#define UTIL_PRIVATE$/;"	d	file:
UTIL_PRIVATE	test/test_util.c	/^#define UTIL_PRIVATE$/;"	d	file:
UTIL_TEST	test/test_util.c	/^#define UTIL_TEST(/;"	d	file:
UTRACE	common/OpenBSD_malloc_Linux.c	/^#define UTRACE(/;"	d	file:
UpdateBridgesFromAuthority	or/or.h	/^  int UpdateBridgesFromAuthority;$/;"	m	struct:__anon49
UseBridges	or/or.h	/^  int UseBridges; \/**< Boolean: should we start all circuits with a bridge? *\/$/;"	m	struct:__anon49
UseEntryGuards	or/or.h	/^  int UseEntryGuards; \/**< Boolean: Do we try to enter from a smallish number$/;"	m	struct:__anon49
UseMicrodescriptors	or/or.h	/^  int UseMicrodescriptors;$/;"	m	struct:__anon49
User	or/or.h	/^  char *User; \/**< Name of user to run Tor as. *\/$/;"	m	struct:__anon49
UserspaceIOCPBuffers	or/or.h	/^  int UserspaceIOCPBuffers;$/;"	m	struct:__anon49
V	common/compat_libevent.c	/^#define V(/;"	d	file:
V	or/config.c	/^#define V(/;"	d	file:
V	or/config.c	/^#undef V$/;"	d	file:
V1AuthoritativeDir	or/or.h	/^  int V1AuthoritativeDir; \/**< Boolean: is this an authoritative directory$/;"	m	struct:__anon49
V1_DIRINFO	or/or.h	/^  V1_DIRINFO      = 1 << 0,$/;"	e	enum:__anon45
V2AuthoritativeDir	or/or.h	/^  int V2AuthoritativeDir; \/**< Boolean: is this an authoritative directory$/;"	m	struct:__anon49
V2_DIRINFO	or/or.h	/^  V2_DIRINFO      = 1 << 1,$/;"	e	enum:__anon45
V2_HANDSHAKE_CLIENT	common/tortls.c	/^#define V2_HANDSHAKE_CLIENT$/;"	d	file:
V2_HANDSHAKE_SERVER	common/tortls.c	/^#define V2_HANDSHAKE_SERVER$/;"	d	file:
V2_NETWORKSTATUS_ROUTER_LIFETIME	or/networkstatus.c	/^#define V2_NETWORKSTATUS_ROUTER_LIFETIME /;"	d	file:
V3AuthDistDelay	or/or.h	/^  int V3AuthDistDelay;$/;"	m	struct:__anon49
V3AuthNIntervalsValid	or/or.h	/^  int V3AuthNIntervalsValid;$/;"	m	struct:__anon49
V3AuthUseLegacyKey	or/or.h	/^  int V3AuthUseLegacyKey;$/;"	m	struct:__anon49
V3AuthVoteDelay	or/or.h	/^  int V3AuthVoteDelay;$/;"	m	struct:__anon49
V3AuthVotingInterval	or/or.h	/^  int V3AuthVotingInterval;$/;"	m	struct:__anon49
V3AuthoritativeDir	or/or.h	/^  int V3AuthoritativeDir; \/**< Boolean: is this an authoritative directory$/;"	m	struct:__anon49
V3BandwidthsFile	or/or.h	/^  char *V3BandwidthsFile;$/;"	m	struct:__anon49
V3_AUTH_BODY_LEN	or/or.h	/^#define V3_AUTH_BODY_LEN /;"	d
V3_AUTH_FIXED_PART_LEN	or/or.h	/^#define V3_AUTH_FIXED_PART_LEN /;"	d
V3_DIRINFO	or/or.h	/^  V3_DIRINFO      = 1 << 2,$/;"	e	enum:__anon45
VAR	or/config.c	/^#define VAR(/;"	d	file:
VAR	or/config.c	/^#undef VAR$/;"	d	file:
VAR_CELL_HEADER_SIZE	or/or.h	/^#define VAR_CELL_HEADER_SIZE /;"	d
VERIFY_DIR	or/or.h	/^  VERIFY_DIR, VERIFY_RTR,$/;"	e	enum:__anon65
VERIFY_RTR	or/or.h	/^  VERIFY_DIR, VERIFY_RTR,$/;"	e	enum:__anon65
VERSION	win32/orconfig.h	/^#define VERSION /;"	d
VERY_OLD_FILE_AGE	or/config.c	/^#define VERY_OLD_FILE_AGE /;"	d	file:
VER_PRE	or/or.h	/^  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;$/;"	e	enum:tor_version_t::__anon67
VER_RC	or/or.h	/^  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;$/;"	e	enum:tor_version_t::__anon67
VER_RELEASE	or/or.h	/^  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;$/;"	e	enum:tor_version_t::__anon67
VER_SUITE_EMBEDDEDNT	common/compat.h	/^#define VER_SUITE_EMBEDDEDNT /;"	d
VER_SUITE_SINGLEUSERTS	common/compat.h	/^#define VER_SUITE_SINGLEUSERTS /;"	d
VS_EMPTY	or/or.h	/^  VS_EMPTY=5, \/**< The version list was empty; no agreed-on versions. *\/$/;"	e	enum:version_status_t
VS_NEW	or/or.h	/^  VS_NEW=2, \/**< This version is newer than any recommended version. *\/$/;"	e	enum:version_status_t
VS_NEW_IN_SERIES	or/or.h	/^  VS_NEW_IN_SERIES=3, \/**< This version is newer than any recommended version$/;"	e	enum:version_status_t
VS_OLD	or/or.h	/^  VS_OLD=1, \/**< This version is older than any recommended version. *\/$/;"	e	enum:version_status_t
VS_RECOMMENDED	or/or.h	/^  VS_RECOMMENDED=0, \/**< This version is listed as recommended. *\/$/;"	e	enum:version_status_t
VS_UNKNOWN	or/or.h	/^  VS_UNKNOWN, \/**< We have no idea. *\/$/;"	e	enum:version_status_t
VS_UNRECOMMENDED	or/or.h	/^  VS_UNRECOMMENDED=4, \/**< This version is not recommended (general case). *\/$/;"	e	enum:version_status_t
V_LINE_OVERHEAD	or/dirserv.c	/^#define V_LINE_OVERHEAD /;"	d	file:
V_OLD	common/compat_libevent.c	/^#define V_OLD(/;"	d	file:
VersioningAuthoritativeDir	or/or.h	/^  int VersioningAuthoritativeDir; \/**< Boolean: is this an authoritative$/;"	m	struct:__anon49
VirtualAddrNetwork	or/or.h	/^  char *VirtualAddrNetwork; \/**< Address and mask to hand out for virtual$/;"	m	struct:__anon49
VoteOnHidServDirectoriesV2	or/or.h	/^  int VoteOnHidServDirectoriesV2; \/**< As a directory authority, vote on$/;"	m	struct:__anon49
WARN_HANDOFF_FAILURE_INTERVAL	or/command.c	/^#define WARN_HANDOFF_FAILURE_INTERVAL /;"	d	file:
WARN_TOO_MANY_CIRC_CREATIONS_INTERVAL	or/onion.c	/^#define WARN_TOO_MANY_CIRC_CREATIONS_INTERVAL /;"	d	file:
WARN_TOO_MANY_CONNS_INTERVAL	or/connection.c	/^#define WARN_TOO_MANY_CONNS_INTERVAL /;"	d	file:
WEEKDAY_NAMES	common/util.c	/^static const char *WEEKDAY_NAMES[] =$/;"	v	file:
WEIGHT_FOR_DIR	or/or.h	/^  WEIGHT_FOR_DIR$/;"	e	enum:bandwidth_weight_rule_t
WEIGHT_FOR_EXIT	or/or.h	/^  NO_WEIGHTING, WEIGHT_FOR_EXIT, WEIGHT_FOR_MID, WEIGHT_FOR_GUARD,$/;"	e	enum:bandwidth_weight_rule_t
WEIGHT_FOR_GUARD	or/or.h	/^  NO_WEIGHTING, WEIGHT_FOR_EXIT, WEIGHT_FOR_MID, WEIGHT_FOR_GUARD,$/;"	e	enum:bandwidth_weight_rule_t
WEIGHT_FOR_MID	or/or.h	/^  NO_WEIGHTING, WEIGHT_FOR_EXIT, WEIGHT_FOR_MID, WEIGHT_FOR_GUARD,$/;"	e	enum:bandwidth_weight_rule_t
WFU_TO_GUARANTEE_GUARD	or/dirserv.c	/^#define WFU_TO_GUARANTEE_GUARD /;"	d	file:
WIN32_LEAN_AND_MEAN	common/compat.h	/^#define WIN32_LEAN_AND_MEAN$/;"	d
WIN32_LEAN_AND_MEAN	common/crypto.c	/^#define WIN32_LEAN_AND_MEAN$/;"	d	file:
WIN32_LEAN_AND_MEAN	common/tortls.c	/^ #define WIN32_LEAN_AND_MEAN$/;"	d	file:
WIN32_LEAN_AND_MEAN	or/or.h	/^#define WIN32_LEAN_AND_MEAN$/;"	d
WIN32_WINNT	common/compat.h	/^#define WIN32_WINNT /;"	d
WIN32_WINNT	common/crypto.c	/^#define WIN32_WINNT /;"	d	file:
WIN32_WINNT	common/tortls.c	/^ #define WIN32_WINNT /;"	d	file:
WIN32_WINNT	or/or.h	/^#define WIN32_WINNT /;"	d
WINDOWS_LEAN_AND_MEAN	test/test-child.c	/^#define WINDOWS_LEAN_AND_MEAN$/;"	d	file:
WIN_NS_9X_KEY	or/eventdns.c	/^#define WIN_NS_9X_KEY /;"	d	file:
WIN_NS_NT_KEY	or/eventdns.c	/^#define WIN_NS_NT_KEY /;"	d	file:
WRA_MORE_SEVERE	or/dirserv.c	/^WRA_MORE_SEVERE(was_router_added_t a, was_router_added_t b)$/;"	f	file:
WRA_WAS_ADDED	or/routerlist.h	/^WRA_WAS_ADDED(was_router_added_t s) {$/;"	f
WRA_WAS_OUTDATED	or/routerlist.h	/^static INLINE int WRA_WAS_OUTDATED(was_router_added_t s)$/;"	f
WRA_WAS_REJECTED	or/routerlist.h	/^static INLINE int WRA_WAS_REJECTED(was_router_added_t s)$/;"	f
WRITE_EVENT	or/main.h	/^  WRITE_EVENT=0x04 \/**< We want to know when a connection is writable *\/$/;"	e	enum:watchable_events
WRITE_STATS_INTERVAL	or/or.h	/^#define WRITE_STATS_INTERVAL /;"	d
WarnPlaintextPorts	or/or.h	/^  smartlist_t *WarnPlaintextPorts;$/;"	m	struct:__anon49
WarnUnsafeSocks	or/or.h	/^  int WarnUnsafeSocks;$/;"	m	struct:__anon49
X	common/crypto.c	/^#define X /;"	d	file:
X	common/crypto.c	/^#undef X$/;"	d	file:
XCIPHER	common/tortls.c	/^#define XCIPHER(/;"	d	file:
XCIPHER	common/tortls.c	/^#undef XCIPHER$/;"	d	file:
X_ADDRESS_HEADER	or/directory.c	/^#define X_ADDRESS_HEADER /;"	d	file:
Xm	or/or.h	/^  build_time_t Xm;$/;"	m	struct:__anon54
ZLIB_METHOD	common/torgzip.h	/^  NO_METHOD=0, GZIP_METHOD=1, ZLIB_METHOD=2, UNKNOWN_METHOD=3$/;"	e	enum:__anon14
_AP_CONN_STATE_MAX	or/or.h	/^#define _AP_CONN_STATE_MAX /;"	d
_AP_CONN_STATE_MIN	or/or.h	/^#define _AP_CONN_STATE_MIN /;"	d
_A_UNKNOWN	or/routerparse.c	/^  _A_UNKNOWN,$/;"	e	enum:__anon69	file:
_AllowInvalid	or/or.h	/^  invalid_router_usage_t _AllowInvalid;$/;"	m	struct:__anon49
_BridgePassword_AuthDigest	or/or.h	/^  char *_BridgePassword_AuthDigest;$/;"	m	struct:__anon49
_CIRCUIT_PURPOSE_C_MAX	or/or.h	/^#define _CIRCUIT_PURPOSE_C_MAX /;"	d
_CIRCUIT_PURPOSE_MAX	or/or.h	/^#define _CIRCUIT_PURPOSE_MAX /;"	d
_CIRCUIT_PURPOSE_MIN	or/or.h	/^#define _CIRCUIT_PURPOSE_MIN /;"	d
_CIRCUIT_PURPOSE_OR_MAX	or/or.h	/^#define _CIRCUIT_PURPOSE_OR_MAX /;"	d
_CIRCUIT_PURPOSE_OR_MIN	or/or.h	/^#define _CIRCUIT_PURPOSE_OR_MIN /;"	d
_CONN_TYPE_MAX	or/or.h	/^#define _CONN_TYPE_MAX /;"	d
_CONN_TYPE_MIN	or/or.h	/^#define _CONN_TYPE_MIN /;"	d
_CONTROL_CONN_STATE_MAX	or/or.h	/^#define _CONTROL_CONN_STATE_MAX /;"	d
_CONTROL_CONN_STATE_MIN	or/or.h	/^#define _CONTROL_CONN_STATE_MIN /;"	d
_CPUWORKER_STATE_MAX	or/or.h	/^#define _CPUWORKER_STATE_MAX /;"	d
_CPUWORKER_STATE_MIN	or/or.h	/^#define _CPUWORKER_STATE_MIN /;"	d
_ConnLimit	or/or.h	/^  int _ConnLimit; \/**< Maximum allowed number of simultaneous connections. *\/$/;"	m	struct:__anon49
_DIR_CONN_STATE_MAX	or/or.h	/^#define _DIR_CONN_STATE_MAX /;"	d
_DIR_CONN_STATE_MIN	or/or.h	/^#define _DIR_CONN_STATE_MIN /;"	d
_DIR_PURPOSE_MAX	or/or.h	/^#define _DIR_PURPOSE_MAX /;"	d
_DIR_PURPOSE_MIN	or/or.h	/^#define _DIR_PURPOSE_MIN /;"	d
_END_CIRC_REASON_MAX	or/or.h	/^#define _END_CIRC_REASON_MAX /;"	d
_END_CIRC_REASON_MIN	or/or.h	/^#define _END_CIRC_REASON_MIN /;"	d
_EOF	or/routerparse.c	/^  _EOF,$/;"	e	enum:__anon69	file:
_ERR	or/routerparse.c	/^  _ERR,$/;"	e	enum:__anon69	file:
_EVENT_MAX	or/control.c	/^#define _EVENT_MAX /;"	d	file:
_EVENT_MIN	or/control.c	/^#define _EVENT_MIN /;"	d	file:
_EXIT_CONN_STATE_MAX	or/or.h	/^#define _EXIT_CONN_STATE_MAX /;"	d
_EXIT_CONN_STATE_MIN	or/or.h	/^#define _EXIT_CONN_STATE_MIN /;"	d
_EXIT_PURPOSE_MAX	or/or.h	/^#define _EXIT_PURPOSE_MAX /;"	d
_EXIT_PURPOSE_MIN	or/or.h	/^#define _EXIT_PURPOSE_MIN /;"	d
_ExcludeExitNodesUnion	or/or.h	/^  routerset_t *_ExcludeExitNodesUnion;$/;"	m	struct:__anon49
_FILE_OFFSET_BITS	common/torgzip.c	/^#define _FILE_OFFSET_BITS /;"	d	file:
_GNU_SOURCE	common/compat.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	common/util.c	/^#define _GNU_SOURCE$/;"	d	file:
_GNU_SOURCE	or/eventdns.c	/^#define _GNU_SOURCE$/;"	d	file:
_LARGEFILE64_SOURCE	common/torgzip.c	/^#define _LARGEFILE64_SOURCE /;"	d	file:
_LFS64_LARGEFILE	common/torgzip.c	/^#define _LFS64_LARGEFILE /;"	d	file:
_MALLOC_LOCK	common/OpenBSD_malloc_Linux.c	/^#define _MALLOC_LOCK(/;"	d	file:
_MALLOC_LOCK_INIT	common/OpenBSD_malloc_Linux.c	/^#define _MALLOC_LOCK_INIT(/;"	d	file:
_MALLOC_UNLOCK	common/OpenBSD_malloc_Linux.c	/^#define _MALLOC_UNLOCK(/;"	d	file:
_MIN_TOR_TLS_ERROR_VAL	common/tortls.h	/^#define _MIN_TOR_TLS_ERROR_VAL /;"	d
_NIL	or/routerparse.c	/^  _NIL$/;"	e	enum:__anon69	file:
_OR_CONN_STATE_MAX	or/or.h	/^#define _OR_CONN_STATE_MAX /;"	d
_OR_CONN_STATE_MIN	or/or.h	/^#define _OR_CONN_STATE_MIN /;"	d
_PDS_PREFER_TUNNELED_DIR_CONNS	or/or.h	/^#define _PDS_PREFER_TUNNELED_DIR_CONNS /;"	d
_PublishServerDescriptor	or/or.h	/^  dirinfo_type_t _PublishServerDescriptor;$/;"	m	struct:__anon49
_SHORT_FILE_	common/compat.h	/^#define _SHORT_FILE_ /;"	d
_SafeLogging	or/or.h	/^  } _SafeLogging;$/;"	m	struct:__anon49	typeref:enum:__anon49::__anon51
_TOR_ADDRESS_H	common/address.h	/^#define _TOR_ADDRESS_H$/;"	d
_TOR_AES_H	common/aes.h	/^#define _TOR_AES_H$/;"	d
_TOR_BUFFERS_H	or/buffers.h	/^#define _TOR_BUFFERS_H$/;"	d
_TOR_CIRCUITBUILD_H	or/circuitbuild.h	/^#define _TOR_CIRCUITBUILD_H$/;"	d
_TOR_CIRCUITLIST_H	or/circuitlist.h	/^#define _TOR_CIRCUITLIST_H$/;"	d
_TOR_CIRCUITUSE_H	or/circuituse.h	/^#define _TOR_CIRCUITUSE_H$/;"	d
_TOR_COMMAND_H	or/command.h	/^#define _TOR_COMMAND_H$/;"	d
_TOR_COMPAT_H	common/compat.h	/^#define _TOR_COMPAT_H$/;"	d
_TOR_COMPAT_LIBEVENT_H	common/compat_libevent.h	/^#define _TOR_COMPAT_LIBEVENT_H$/;"	d
_TOR_CONFIG_H	or/config.h	/^#define _TOR_CONFIG_H$/;"	d
_TOR_CONNECTION_EDGE_H	or/connection_edge.h	/^#define _TOR_CONNECTION_EDGE_H$/;"	d
_TOR_CONNECTION_H	or/connection.h	/^#define _TOR_CONNECTION_H$/;"	d
_TOR_CONNECTION_OR_H	or/connection_or.h	/^#define _TOR_CONNECTION_OR_H$/;"	d
_TOR_CONTAINER_H	common/container.h	/^#define _TOR_CONTAINER_H$/;"	d
_TOR_CONTROL_H	or/control.h	/^#define _TOR_CONTROL_H$/;"	d
_TOR_CPUWORKER_H	or/cpuworker.h	/^#define _TOR_CPUWORKER_H$/;"	d
_TOR_CRYPTO_H	common/crypto.h	/^#define _TOR_CRYPTO_H$/;"	d
_TOR_DIRECTORY_H	or/directory.h	/^#define _TOR_DIRECTORY_H$/;"	d
_TOR_DIRSERV_H	or/dirserv.h	/^#define _TOR_DIRSERV_H$/;"	d
_TOR_DIRVOTE_H	or/dirvote.h	/^#define _TOR_DIRVOTE_H$/;"	d
_TOR_DNSSERV_H	or/dnsserv.h	/^#define _TOR_DNSSERV_H$/;"	d
_TOR_DNS_H	or/dns.h	/^#define _TOR_DNS_H$/;"	d
_TOR_EVENTDNS_H	or/eventdns.h	/^#define _TOR_EVENTDNS_H$/;"	d
_TOR_FW_HELPER_H	tools/tor-fw-helper/tor-fw-helper.h	/^#define _TOR_FW_HELPER_H$/;"	d
_TOR_FW_HELPER_NATPMP_H	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^#define _TOR_FW_HELPER_NATPMP_H$/;"	d
_TOR_FW_HELPER_UPNP_H	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^#define _TOR_FW_HELPER_UPNP_H$/;"	d
_TOR_GEOIP_H	or/geoip.h	/^#define _TOR_GEOIP_H$/;"	d
_TOR_HIBERNATE_H	or/hibernate.h	/^#define _TOR_HIBERNATE_H$/;"	d
_TOR_HT_H	common/ht.h	/^#define _TOR_HT_H$/;"	d
_TOR_LOG_H	common/torlog.h	/^# define _TOR_LOG_H$/;"	d
_TOR_MAIN_H	or/main.h	/^#define _TOR_MAIN_H$/;"	d
_TOR_MEMAREA_H	common/memarea.h	/^#define _TOR_MEMAREA_H$/;"	d
_TOR_MEMPOOL_H	common/mempool.h	/^#define _TOR_MEMPOOL_H$/;"	d
_TOR_MICRODESC_H	or/microdesc.h	/^#define _TOR_MICRODESC_H$/;"	d
_TOR_NETWORKSTATUS_H	or/networkstatus.h	/^#define _TOR_NETWORKSTATUS_H$/;"	d
_TOR_NODELIST_H	or/nodelist.h	/^#define _TOR_NODELIST_H$/;"	d
_TOR_NTMAIN_H	or/ntmain.h	/^#define _TOR_NTMAIN_H$/;"	d
_TOR_ONION_H	or/onion.h	/^#define _TOR_ONION_H$/;"	d
_TOR_OR_H	or/or.h	/^#define _TOR_OR_H$/;"	d
_TOR_POLICIES_H	or/policies.h	/^#define _TOR_POLICIES_H$/;"	d
_TOR_REASONS_H	or/reasons.h	/^#define _TOR_REASONS_H$/;"	d
_TOR_RELAY_H	or/relay.h	/^#define _TOR_RELAY_H$/;"	d
_TOR_RENDCLIENT_H	or/rendclient.h	/^#define _TOR_RENDCLIENT_H$/;"	d
_TOR_RENDCOMMON_H	or/rendcommon.h	/^#define _TOR_RENDCOMMON_H$/;"	d
_TOR_RENDMID_H	or/rendmid.h	/^#define _TOR_RENDMID_H$/;"	d
_TOR_RENDSERVICE_H	or/rendservice.h	/^#define _TOR_RENDSERVICE_H$/;"	d
_TOR_REPHIST_H	or/rephist.h	/^#define _TOR_REPHIST_H$/;"	d
_TOR_ROUTERLIST_H	or/routerlist.h	/^#define _TOR_ROUTERLIST_H$/;"	d
_TOR_ROUTERPARSE_H	or/routerparse.h	/^#define _TOR_ROUTERPARSE_H$/;"	d
_TOR_ROUTER_H	or/router.h	/^#define _TOR_ROUTER_H$/;"	d
_TOR_STATUS_H	or/status.h	/^#define _TOR_STATUS_H$/;"	d
_TOR_TEST_H	test/test.h	/^#define _TOR_TEST_H$/;"	d
_TOR_TLS_SYSCALL	common/tortls.c	/^#define _TOR_TLS_SYSCALL /;"	d	file:
_TOR_TLS_ZERORETURN	common/tortls.c	/^#define _TOR_TLS_ZERORETURN /;"	d	file:
_TOR_TORGZIP_H	common/torgzip.h	/^#define _TOR_TORGZIP_H$/;"	d
_TOR_TORINT_H	common/torint.h	/^#define _TOR_TORINT_H$/;"	d
_TOR_TORTLS_H	common/tortls.h	/^#define _TOR_TORTLS_H$/;"	d
_TOR_UTIL_H	common/util.h	/^#define _TOR_UTIL_H$/;"	d
_UseFilteringSSLBufferevents	or/or.h	/^  int _UseFilteringSSLBufferevents;$/;"	m	struct:__anon49
_UsingTestNetworkDefaults	or/or.h	/^  int _UsingTestNetworkDefaults;$/;"	m	struct:__anon49
_WIN32	win32/orconfig.h	/^#define _WIN32$/;"	d
_WIN32_WINNT	common/address.c	/^#define _WIN32_WINNT /;"	d	file:
_WIN32_WINNT	common/address.c	/^#undef _WIN32_WINNT$/;"	d	file:
_WIN32_WINNT	common/compat.h	/^#define _WIN32_WINNT /;"	d
_WIN32_WINNT	common/crypto.c	/^#define _WIN32_WINNT /;"	d	file:
_WIN32_WINNT	common/tortls.c	/^ #define _WIN32_WINNT /;"	d	file:
_WIN32_WINNT	or/or.h	/^#define _WIN32_WINNT /;"	d
__USE_ISOC99	common/util.c	/^#define __USE_ISOC99 /;"	d	file:
__attribute__	test/tinytest.c	/^#define __attribute__(/;"	d	file:
__func__	common/compat.h	/^#define __func__ /;"	d
_aes_fill_buf	common/aes.c	/^_aes_fill_buf(aes_cnt_cipher_t *cipher)$/;"	f	file:
_assert_cache_ok	or/dns.c	/^_assert_cache_ok(void)$/;"	f	file:
_base	or/or.h	/^  circuit_t _base;$/;"	m	struct:or_circuit_t
_base	or/or.h	/^  circuit_t _base;$/;"	m	struct:origin_circuit_t
_base	or/or.h	/^  connection_t _base;$/;"	m	struct:control_connection_t
_base	or/or.h	/^  connection_t _base;$/;"	m	struct:dir_connection_t
_base	or/or.h	/^  connection_t _base;$/;"	m	struct:edge_connection_t
_base	or/or.h	/^  connection_t _base;$/;"	m	struct:listener_connection_t
_base	or/or.h	/^  connection_t _base;$/;"	m	struct:or_connection_t
_buffer_stats_compare_entries	or/rephist.c	/^_buffer_stats_compare_entries(const void **_a, const void **_b)$/;"	f	file:
_c_hist_compare	or/geoip.c	/^_c_hist_compare(const void **_a, const void **_b)$/;"	f	file:
_check_no_tls_errors	common/tortls.c	/^_check_no_tls_errors(const char *fname, int line)$/;"	f
_circuit_get_global_list	or/circuitlist.c	/^_circuit_get_global_list(void)$/;"	f
_circuit_mark_for_close	or/circuitlist.c	/^_circuit_mark_for_close(circuit_t *circ, int reason, int line,$/;"	f
_cmp_int_strings	or/dirvote.c	/^_cmp_int_strings(const void **_a, const void **_b)$/;"	f	file:
_compare_cached_resolves_by_expiry	or/dns.c	/^_compare_cached_resolves_by_expiry(const void *_a, const void *_b)$/;"	f	file:
_compare_digests	common/container.c	/^_compare_digests(const void **_a, const void **_b)$/;"	f	file:
_compare_digests256	common/container.c	/^_compare_digests256(const void **_a, const void **_b)$/;"	f	file:
_compare_dir_src_ents_by_authority_id	or/dirvote.c	/^_compare_dir_src_ents_by_authority_id(const void **_a, const void **_b)$/;"	f	file:
_compare_duration_idx	or/routerlist.c	/^_compare_duration_idx(const void *_d1, const void *_d2)$/;"	f	file:
_compare_int	or/rephist.c	/^_compare_int(const void *x, const void *y)$/;"	f	file:
_compare_networkstatus_v2_published_on	or/networkstatus.c	/^_compare_networkstatus_v2_published_on(const void **_a, const void **_b)$/;"	f	file:
_compare_old_routers_by_identity	or/routerlist.c	/^_compare_old_routers_by_identity(const void **_a, const void **_b)$/;"	f	file:
_compare_pairs	or/directory.c	/^_compare_pairs(const void **a, const void **b)$/;"	f	file:
_compare_routerinfo_by_id_digest	or/routerlist.c	/^_compare_routerinfo_by_id_digest(const void **a, const void **b)$/;"	f	file:
_compare_routerinfo_by_ip_and_bw	or/dirserv.c	/^_compare_routerinfo_by_ip_and_bw(const void **a, const void **b)$/;"	f	file:
_compare_signed_descriptors_by_age	or/routerlist.c	/^_compare_signed_descriptors_by_age(const void **_a, const void **_b)$/;"	f	file:
_compare_string_ptrs	common/container.c	/^_compare_string_ptrs(const void **_a, const void **_b)$/;"	f	file:
_compare_strings_for_pqueue	test/test_containers.c	/^_compare_strings_for_pqueue(const void *p1, const void *p2)$/;"	f	file:
_compare_strs	or/directory.c	/^_compare_strs(const void **a, const void **b)$/;"	f	file:
_compare_strs	test/test_containers.c	/^_compare_strs(const void **a, const void **b)$/;"	f	file:
_compare_tor_version_str_ptr	or/routerparse.c	/^_compare_tor_version_str_ptr(const void **_a, const void **_b)$/;"	f	file:
_compare_vote_rs	or/dirvote.c	/^_compare_vote_rs(const void **_a, const void **_b)$/;"	f	file:
_compare_votes_by_authority_id	or/dirvote.c	/^_compare_votes_by_authority_id(const void **_a, const void **_b)$/;"	f	file:
_compare_without_first_ch	test/test_containers.c	/^_compare_without_first_ch(const void *a, const void **b)$/;"	f	file:
_connection_free	or/connection.c	/^_connection_free(connection_t *conn)$/;"	f	file:
_connection_mark_and_flush	or/connection.h	/^#define _connection_mark_and_flush(/;"	d
_connection_mark_for_close	or/connection.c	/^_connection_mark_for_close(connection_t *conn, int line, const char *file)$/;"	f
_connection_mark_unattached_ap	or/connection_edge.c	/^_connection_mark_unattached_ap(entry_connection_t *conn, int endreason,$/;"	f
_connection_write_to_buf_impl	or/connection.c	/^_connection_write_to_buf_impl(const char *string, size_t len,$/;"	f
_crypto_dh_get_dh	common/crypto.c	/^_crypto_dh_get_dh(crypto_dh_t *dh)$/;"	f
_crypto_global_initialized	common/crypto.c	/^static int _crypto_global_initialized = 0;$/;"	v	file:
_crypto_new_pk_from_rsa	common/crypto.c	/^_crypto_new_pk_from_rsa(RSA *rsa)$/;"	f
_crypto_pk_get_evp_pkey	common/crypto.c	/^_crypto_pk_get_evp_pkey(crypto_pk_t *env, int private)$/;"	f
_crypto_pk_get_rsa	common/crypto.c	/^_crypto_pk_get_rsa(crypto_pk_t *env)$/;"	f
_dirreq_map_get	or/geoip.c	/^_dirreq_map_get(dirreq_type_t type, uint64_t dirreq_id)$/;"	f	file:
_dirreq_map_put	or/geoip.c	/^_dirreq_map_put(dirreq_map_entry_t *entry, dirreq_type_t type,$/;"	f	file:
_dns_randfn	or/dns.c	/^_dns_randfn(char *b, size_t n)$/;"	f	file:
_dummy	common/mempool.c	/^    ALIGNMENT_TYPE _dummy;$/;"	m	union:mp_allocated_t::__anon13	file:
_edge	or/or.h	/^  edge_connection_t _edge;$/;"	m	struct:entry_connection_t
_evdns_log	or/eventdns.c	/^_evdns_log(int warn, const char *fmt, ...)$/;"	f	file:
_evdns_nameserver_add_impl	or/eventdns.c	/^_evdns_nameserver_add_impl(const struct sockaddr *address,$/;"	f	file:
_extrainfo_free	or/routerlist.c	/^_extrainfo_free(void *e)$/;"	f	file:
_find_by_keyword	or/routerparse.c	/^_find_by_keyword(smartlist_t *s, directory_keyword keyword,$/;"	f	file:
_free_cached_dir	or/dirserv.c	/^_free_cached_dir(void *_d)$/;"	f	file:
_free_cached_resolve	or/dns.c	/^_free_cached_resolve(cached_resolve_t *r)$/;"	f	file:
_free_duplicate_routerstatus_entry	or/routerparse.c	/^_free_duplicate_routerstatus_entry(void *e)$/;"	f	file:
_free_link_history	or/rephist.c	/^_free_link_history(void *val)$/;"	f	file:
_geoip_compare_entries	or/geoip.c	/^_geoip_compare_entries(const void **_a, const void **_b)$/;"	f	file:
_geoip_compare_key_to_entry	or/geoip.c	/^_geoip_compare_key_to_entry(const void *_key, const void **_member)$/;"	f	file:
_hex_decode_digit	common/util.c	/^_hex_decode_digit(char c)$/;"	f	file:
_log_debug	common/log.c	/^_log_debug(log_domain_mask_t domain, const char *format, ...)$/;"	f
_log_err	common/log.c	/^_log_err(log_domain_mask_t domain, const char *format, ...)$/;"	f
_log_fn	common/log.c	/^_log_fn(int severity, log_domain_mask_t domain, const char *fn,$/;"	f
_log_fn	common/log.c	/^_log_fn(int severity, log_domain_mask_t domain, const char *format, ...)$/;"	f
_log_fn_function_name	common/log.c	/^const char *_log_fn_function_name=NULL;$/;"	v
_log_global_min_severity	common/log.c	/^int _log_global_min_severity = LOG_NOTICE;$/;"	v
_log_info	common/log.c	/^_log_info(log_domain_mask_t domain, const char *format, ...)$/;"	f
_log_notice	common/log.c	/^_log_notice(log_domain_mask_t domain, const char *format, ...)$/;"	f
_log_prefix	common/log.c	/^_log_prefix(char *buf, size_t buf_len, int severity)$/;"	f	file:
_log_warn	common/log.c	/^_log_warn(log_domain_mask_t domain, const char *format, ...)$/;"	f
_magic	or/or.h	/^  uint32_t _magic;$/;"	m	struct:__anon49
_magic	or/or.h	/^  uint32_t _magic;$/;"	m	struct:__anon52
_microdesc_eq	or/microdesc.c	/^_microdesc_eq(microdesc_t *a, microdesc_t *b)$/;"	f	file:
_microdesc_hash	or/microdesc.c	/^_microdesc_hash(microdesc_t *md)$/;"	f	file:
_mm_free	or/eventdns.c	/^#define _mm_free(/;"	d	file:
_n_openssl_mutexes	common/crypto.c	/^static int _n_openssl_mutexes = 0;$/;"	v	file:
_openssl_dynlock_create_cb	common/crypto.c	/^_openssl_dynlock_create_cb(const char *file, int line)$/;"	f	file:
_openssl_dynlock_destroy_cb	common/crypto.c	/^_openssl_dynlock_destroy_cb(struct CRYPTO_dynlock_value *v,$/;"	f	file:
_openssl_dynlock_lock_cb	common/crypto.c	/^_openssl_dynlock_lock_cb(int mode, struct CRYPTO_dynlock_value *v,$/;"	f	file:
_openssl_locking_cb	common/crypto.c	/^_openssl_locking_cb(int mode, int n, const char *file, int line)$/;"	f	file:
_openssl_mutexes	common/crypto.c	/^static tor_mutex_t **_openssl_mutexes = NULL;$/;"	v	file:
_option_abbrevs	or/config.c	/^static config_abbrev_t _option_abbrevs[] = {$/;"	v	file:
_option_vars	or/config.c	/^static config_var_t _option_vars[] = {$/;"	v	file:
_orconn_circid_entries_eq	or/circuitlist.c	/^_orconn_circid_entries_eq(orconn_circid_circuit_map_t *a,$/;"	f	file:
_orconn_circid_entry_hash	or/circuitlist.c	/^_orconn_circid_entry_hash(orconn_circid_circuit_map_t *a)$/;"	f	file:
_remove_old_client_helper	or/geoip.c	/^_remove_old_client_helper(struct clientmap_entry_t *ent, void *_cutoff)$/;"	f	file:
_rend_cache_entry_free	or/rendcommon.c	/^_rend_cache_entry_free(void *p)$/;"	f	file:
_routerlist_find_elt	or/routerlist.c	/^_routerlist_find_elt(smartlist_t *sl, void *ri, int idx)$/;"	f	file:
_sha256_compress	common/sha256.c	/^static int _sha256_compress(sha256_state * md, unsigned char *buf)$/;"	f	file:
_state_abbrevs	or/config.c	/^static config_abbrev_t _state_abbrevs[] = {$/;"	v	file:
_state_vars	or/config.c	/^static config_var_t _state_vars[] = {$/;"	v	file:
_test_op_ip6	test/test_addr.c	/^#define _test_op_ip6(/;"	d	file:
_thread1_name	test/test_util.c	/^static char *_thread1_name = NULL;$/;"	v	file:
_thread2_name	test/test_util.c	/^static char *_thread2_name = NULL;$/;"	v	file:
_thread_test_func	test/test_util.c	/^_thread_test_func(void* _s)$/;"	f	file:
_thread_test_mutex	test/test_util.c	/^static tor_mutex_t *_thread_test_mutex = NULL;$/;"	v	file:
_thread_test_start1	test/test_util.c	/^static tor_mutex_t *_thread_test_start1 = NULL,$/;"	v	file:
_thread_test_start2	test/test_util.c	/^                   *_thread_test_start2 = NULL;$/;"	v	file:
_thread_test_strmap	test/test_util.c	/^static strmap_t *_thread_test_strmap = NULL;$/;"	v	file:
_tor_calloc	common/util.c	/^_tor_calloc(size_t nmemb, size_t size DMALLOC_PARAMS)$/;"	f
_tor_free	common/util.c	/^_tor_free(void *mem)$/;"	f
_tor_malloc	common/util.c	/^_tor_malloc(size_t size DMALLOC_PARAMS)$/;"	f
_tor_malloc_roundup	common/util.c	/^_tor_malloc_roundup(size_t *sizep DMALLOC_PARAMS)$/;"	f
_tor_malloc_zero	common/util.c	/^_tor_malloc_zero(size_t size DMALLOC_PARAMS)$/;"	f
_tor_memdup	common/util.c	/^_tor_memdup(const void *mem, size_t len DMALLOC_PARAMS)$/;"	f
_tor_realloc	common/util.c	/^_tor_realloc(void *ptr, size_t size DMALLOC_PARAMS)$/;"	f
_tor_strdup	common/util.c	/^_tor_strdup(const char *s DMALLOC_PARAMS)$/;"	f
_tor_strndup	common/util.c	/^_tor_strndup(const char *s, size_t n DMALLOC_PARAMS)$/;"	f
_void_for_alignment	common/memarea.c	/^    void *_void_for_alignment; \/**< Dummy; used to make sure mem is aligned. *\/$/;"	m	union:memarea_chunk_t::__anon12	file:
a	or/dns.c	/^    } a;$/;"	m	union:cached_resolve_t::__anon26	typeref:struct:cached_resolve_t::__anon26::__anon27	file:
a	or/eventdns.c	/^		} a;$/;"	m	union:reply::__anon28	typeref:struct:reply::__anon28::__anon29	file:
aaaa	or/eventdns.c	/^		} aaaa;$/;"	m	union:reply::__anon28	typeref:struct:reply::__anon28::__anon30	file:
abbreviated	or/config.c	/^  const char *abbreviated;$/;"	m	struct:config_abbrev_t	file:
abbrevs	or/config.c	/^  config_abbrev_t *abbrevs; \/**< List of abbreviations that we expand when$/;"	m	struct:__anon21	file:
abort_writing_to_file	common/util.c	/^abort_writing_to_file(open_file_t *file_data)$/;"	f
accepted	or/policies.c	/^    unsigned int accepted:1; \/** Has this port already been accepted *\/$/;"	m	struct:policy_summary_item_t	file:
accepted_intro_dh_parts	or/rendservice.c	/^  digestmap_t *accepted_intro_dh_parts;$/;"	m	struct:rend_service_t	file:
accepted_intro_rsa_parts	or/or.h	/^  digestmap_t *accepted_intro_rsa_parts;$/;"	m	struct:rend_intro_point_t
accounting_add_bytes	or/hibernate.c	/^accounting_add_bytes(size_t n_read, size_t n_written, int seconds)$/;"	f
accounting_get_interval_length	or/hibernate.c	/^accounting_get_interval_length(void)$/;"	f
accounting_is_enabled	or/hibernate.c	/^accounting_is_enabled(const or_options_t *options)$/;"	f
accounting_parse_options	or/hibernate.c	/^accounting_parse_options(const or_options_t *options, int validate_only)$/;"	f
accounting_record_bandwidth_usage	or/hibernate.c	/^accounting_record_bandwidth_usage(time_t now, or_state_t *state)$/;"	f
accounting_run_housekeeping	or/hibernate.c	/^accounting_run_housekeeping(time_t now)$/;"	f
accounting_set_wakeup_time	or/hibernate.c	/^accounting_set_wakeup_time(void)$/;"	f	file:
action	or/geoip.c	/^  unsigned int action:2; \/**< Is this a v2 or v3 request? *\/$/;"	m	struct:dirreq_map_entry_t	file:
action	or/geoip.c	/^  unsigned int action:2;$/;"	m	struct:clientmap_entry_t	file:
active_circuit_pqueue	or/or.h	/^  smartlist_t *active_circuit_pqueue;$/;"	m	struct:or_connection_t
active_circuit_pqueue_last_recalibrated	or/or.h	/^  unsigned active_circuit_pqueue_last_recalibrated;$/;"	m	struct:or_connection_t
active_circuits	or/or.h	/^  struct circuit_t *active_circuits;$/;"	m	struct:or_connection_t	typeref:struct:or_connection_t::circuit_t
active_linked_connection_lst	or/main.c	/^static smartlist_t *active_linked_connection_lst = NULL;$/;"	v	file:
active_on_link	or/or.h	/^  unsigned int active_on_link:1;$/;"	m	struct:connection_t
add_an_entry_guard	or/circuitbuild.c	/^add_an_entry_guard(const node_t *chosen, int reset_status, int prepend)$/;"	f	file:
add_answer_to_cache	or/dns.c	/^add_answer_to_cache(const char *address, uint8_t is_reverse, uint32_t addr,$/;"	f	file:
add_callback_log	common/log.c	/^add_callback_log(const log_severity_list_t *severity, log_callback cb)$/;"	f
add_cell_ewma_to_conn	or/relay.c	/^add_cell_ewma_to_conn(or_connection_t *conn, cell_ewma_t *ewma)$/;"	f	file:
add_connection_to_closeable_list	or/main.c	/^add_connection_to_closeable_list(connection_t *conn)$/;"	f
add_default_trusted_dir_authorities	or/config.c	/^add_default_trusted_dir_authorities(dirinfo_type_t type)$/;"	f	file:
add_file_log	common/log.c	/^add_file_log(const log_severity_list_t *severity, const char *filename)$/;"	f
add_fingerprint_to_dir	or/dirserv.c	/^add_fingerprint_to_dir(const char *nickname, const char *fp,$/;"	f
add_networkstatus_to_cache	or/networkstatus.c	/^add_networkstatus_to_cache(const char *s,$/;"	f	file:
add_newly_used_chunk_to_used_list	common/mempool.c	/^add_newly_used_chunk_to_used_list(mp_pool_t *pool, mp_chunk_t *chunk)$/;"	f	file:
add_obs	or/rephist.c	/^add_obs(bw_array_t *b, time_t when, uint64_t n)$/;"	f	file:
add_predicted_port	or/rephist.c	/^add_predicted_port(time_t now, uint16_t port)$/;"	f	file:
add_spaces_to_fp	common/crypto.c	/^add_spaces_to_fp(char *out, size_t outlen, const char *in)$/;"	f
add_stream_log	common/log.c	/^add_stream_log(const log_severity_list_t *severity, const char *name, int fd)$/;"	f
add_stream_log_impl	common/log.c	/^add_stream_log_impl(const log_severity_list_t *severity,$/;"	f	file:
add_syslog_log	common/log.c	/^add_syslog_log(const log_severity_list_t *severity)$/;"	f
add_tcp_mapping	tools/tor-fw-helper/tor-fw-helper.h	/^  int (*add_tcp_mapping)(tor_fw_options_t *options, void *backend_state);$/;"	m	struct:tor_fw_backend_t
add_temp_log	common/log.c	/^add_temp_log(int min_severity)$/;"	f
add_timeout_event	or/eventdns.c	/^#define add_timeout_event(/;"	d	file:
add_transport_to_proxy	or/transports.c	/^add_transport_to_proxy(const char *transport, managed_proxy_t *mp)$/;"	f	file:
add_trusted_dir_server	or/routerlist.c	/^add_trusted_dir_server(const char *nickname, const char *address,$/;"	f
add_wildcarded_test_address	or/dns.c	/^add_wildcarded_test_address(const char *address)$/;"	f	file:
additional	or/eventdns.c	/^	struct server_reply_item *additional; \/* linked list of additional RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
addr	common/address.h	/^  tor_addr_t addr;$/;"	m	struct:tor_addr_port_t
addr	common/address.h	/^  } addr;$/;"	m	struct:tor_addr_t	typeref:union:tor_addr_t::__anon1
addr	or/circuitbuild.c	/^  tor_addr_t addr;$/;"	m	struct:__anon19	file:
addr	or/circuitbuild.h	/^  tor_addr_t addr;$/;"	m	struct:__anon20
addr	or/dns.c	/^      uint32_t addr;  \/**< IPv4 addr for <b>address<\/b>. *\/$/;"	m	struct:cached_resolve_t::__anon26::__anon27	file:
addr	or/eventdns.c	/^	struct sockaddr_storage addr; \/* Where to send the response *\/$/;"	m	struct:server_request	typeref:struct:server_request::sockaddr_storage	file:
addr	or/geoip.c	/^  tor_addr_t addr;$/;"	m	struct:clientmap_entry_t	file:
addr	or/or.h	/^  tor_addr_t addr; \/**< Base address to accept or reject. *\/$/;"	m	struct:addr_policy_t
addr	or/or.h	/^  tor_addr_t addr; \/**< IP address. *\/$/;"	m	struct:extend_info_t
addr	or/or.h	/^  tor_addr_t addr; \/**< IP of the other side of the connection; used to$/;"	m	struct:connection_t
addr	or/or.h	/^  tor_addr_t addr; \/**< The actual IP to listen on, if !is_unix_addr. *\/$/;"	m	struct:port_cfg_t
addr	or/or.h	/^  uint32_t addr; \/**< Address of this voter, in IPv4, in host order. *\/$/;"	m	struct:networkstatus_voter_info_t
addr	or/or.h	/^  uint32_t addr; \/**< IPv4 address for this router. *\/$/;"	m	struct:routerstatus_t
addr	or/or.h	/^  uint32_t addr; \/**< IPv4 address of OR, in host order. *\/$/;"	m	struct:__anon41
addr	or/or.h	/^  uint32_t addr; \/**< IPv4 address. *\/$/;"	m	struct:trusted_dir_server_t
addr	or/or.h	/^  uint32_t addr;$/;"	m	struct:authority_cert_t
addr6	or/dns.c	/^      struct in6_addr addr6; \/**< IPv6 addr for <b>address<\/b>. *\/$/;"	m	struct:cached_resolve_t::__anon26::__anon27	typeref:struct:cached_resolve_t::__anon26::__anon27::in6_addr	file:
addr_current_at	or/or.h	/^  time_t addr_current_at; \/**< When was the document that we derived the$/;"	m	struct:trusted_dir_server_t
addr_is_in_cc_list	or/policies.c	/^addr_is_in_cc_list(uint32_t addr, const smartlist_t *cc_list)$/;"	f	file:
addr_mask_cmp_bits	common/address.c	/^addr_mask_cmp_bits(uint32_t a1, uint32_t a2, maskbits_t bits)$/;"	f
addr_mask_get_bits	common/address.c	/^addr_mask_get_bits(uint32_t mask)$/;"	f
addr_policy_action_t	or/or.h	/^} addr_policy_action_t;$/;"	t	typeref:enum:__anon38
addr_policy_covers	or/policies.c	/^addr_policy_covers(addr_policy_t *a, addr_policy_t *b)$/;"	f	file:
addr_policy_free	or/policies.c	/^addr_policy_free(addr_policy_t *p)$/;"	f
addr_policy_intersects	or/policies.c	/^addr_policy_intersects(addr_policy_t *a, addr_policy_t *b)$/;"	f	file:
addr_policy_list_free	or/policies.c	/^addr_policy_list_free(smartlist_t *lst)$/;"	f
addr_policy_permits_address	or/policies.c	/^addr_policy_permits_address(uint32_t addr, uint16_t port,$/;"	f	file:
addr_policy_permits_tor_addr	or/policies.c	/^addr_policy_permits_tor_addr(const tor_addr_t *addr, uint16_t port,$/;"	f	file:
addr_policy_result_t	or/or.h	/^} addr_policy_result_t;$/;"	t	typeref:enum:__anon64
addr_policy_t	or/or.h	/^typedef struct addr_policy_t {$/;"	s
addr_policy_t	or/or.h	/^} addr_policy_t;$/;"	t	typeref:struct:addr_policy_t
addr_port_lookup	common/address.c	/^addr_port_lookup(int severity, const char *addrport, char **address,$/;"	f
addr_tests	test/test_addr.c	/^struct testcase_t addr_tests[] = {$/;"	v	typeref:struct:testcase_t
addrcount	or/eventdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon28::__anon29	file:
addrcount	or/eventdns.c	/^			u32 addrcount;$/;"	m	struct:reply::__anon28::__anon30	file:
address	common/tortls.c	/^  char *address; \/**< An address to log when describing this connection. *\/$/;"	m	struct:tor_tls_t	file:
address	or/dns.c	/^  char address[MAX_ADDRESSLEN]; \/**< The hostname to be resolved. *\/$/;"	m	struct:cached_resolve_t	file:
address	or/eventdns.c	/^	struct sockaddr_storage address;$/;"	m	struct:nameserver	typeref:struct:nameserver::sockaddr_storage	file:
address	or/or.h	/^  char *address; \/**< Address of this voter, in string format. *\/$/;"	m	struct:networkstatus_voter_info_t
address	or/or.h	/^  char *address; \/**< FQDN (or IP) of the guy on the other end.$/;"	m	struct:connection_t
address	or/or.h	/^  char *address; \/**< Hostname. *\/$/;"	m	struct:trusted_dir_server_t
address	or/or.h	/^  char *address; \/**< Location of OR: either a hostname or an IP address. *\/$/;"	m	struct:__anon41
address	or/or.h	/^  char address[MAX_SOCKS_ADDR_LEN]; \/**< What address did the client ask to$/;"	m	struct:socks_request_t
address	tools/tor-gencert.c	/^char *address = NULL;$/;"	v
address_is_in_virtual_range	or/connection_edge.c	/^address_is_in_virtual_range(const char *address)$/;"	f	file:
address_is_invalid_destination	or/connection_edge.c	/^address_is_invalid_destination(const char *address, int client)$/;"	f
address_ttl	or/or.h	/^  uint32_t address_ttl; \/**< TTL for address-to-addr mapping on exit$/;"	m	struct:edge_connection_t
addresses	or/eventdns.c	/^			struct in6_addr addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon28::__anon30	typeref:struct:reply::__anon28::__anon30::in6_addr	file:
addresses	or/eventdns.c	/^			u32 addresses[MAX_ADDRS];$/;"	m	struct:reply::__anon28::__anon29	file:
addressmap	or/connection_edge.c	/^static strmap_t *addressmap=NULL;$/;"	v	file:
addressmap_clean	or/connection_edge.c	/^addressmap_clean(time_t now)$/;"	f
addressmap_clear_configured	or/connection_edge.c	/^addressmap_clear_configured(void)$/;"	f
addressmap_clear_excluded_trackexithosts	or/connection_edge.c	/^addressmap_clear_excluded_trackexithosts(const or_options_t *options)$/;"	f
addressmap_clear_invalid_automaps	or/connection_edge.c	/^addressmap_clear_invalid_automaps(const or_options_t *options)$/;"	f
addressmap_clear_transient	or/connection_edge.c	/^addressmap_clear_transient(void)$/;"	f
addressmap_ent_free	or/connection_edge.c	/^addressmap_ent_free(void *_ent)$/;"	f	file:
addressmap_ent_remove	or/connection_edge.c	/^addressmap_ent_remove(const char *address, addressmap_entry_t *ent)$/;"	f	file:
addressmap_entry_source_t	or/or.h	/^} addressmap_entry_source_t;$/;"	t	typeref:enum:__anon55
addressmap_entry_t	or/connection_edge.c	/^} addressmap_entry_t;$/;"	t	typeref:struct:__anon22	file:
addressmap_free_all	or/connection_edge.c	/^addressmap_free_all(void)$/;"	f
addressmap_get_mappings	or/connection_edge.c	/^addressmap_get_mappings(smartlist_t *sl, time_t min_expires,$/;"	f
addressmap_get_virtual_address	or/connection_edge.c	/^addressmap_get_virtual_address(int type)$/;"	f	file:
addressmap_have_mapping	or/connection_edge.c	/^addressmap_have_mapping(const char *address, int update_expiry)$/;"	f
addressmap_init	or/connection_edge.c	/^addressmap_init(void)$/;"	f
addressmap_match_superdomains	or/connection_edge.c	/^addressmap_match_superdomains(char *address)$/;"	f	file:
addressmap_register	or/connection_edge.c	/^addressmap_register(const char *address, char *new_address, time_t expires,$/;"	f
addressmap_register_virtual_address	or/connection_edge.c	/^addressmap_register_virtual_address(int type, char *new_address)$/;"	f
addressmap_rewrite	or/connection_edge.c	/^addressmap_rewrite(char *address, size_t maxlen, time_t *expires_out)$/;"	f
addressmap_rewrite_reverse	or/connection_edge.c	/^addressmap_rewrite_reverse(char *address, size_t maxlen, time_t *expires_out)$/;"	f	file:
addressmap_virtaddress_ent_free	or/connection_edge.c	/^addressmap_virtaddress_ent_free(void *_ent)$/;"	f	file:
addressmap_virtaddress_remove	or/connection_edge.c	/^addressmap_virtaddress_remove(const char *address, addressmap_entry_t *ent)$/;"	f	file:
addrlen	or/eventdns.c	/^	socklen_t addrlen; \/* length of addr *\/$/;"	m	struct:server_request	file:
addrs_in_same_network_family	or/routerlist.c	/^addrs_in_same_network_family(const tor_addr_t *a1,$/;"	f	file:
advance_obs	or/rephist.c	/^advance_obs(bw_array_t *b)$/;"	f	file:
advertised_server_mode	or/router.c	/^advertised_server_mode(void)$/;"	f
aes	common/aes.c	/^    AES_KEY aes;$/;"	m	union:aes_cnt_cipher::__anon3	file:
aes_cipher_free	common/aes.c	/^aes_cipher_free(aes_cnt_cipher_t *cipher)$/;"	f
aes_cnt_cipher	common/aes.c	/^struct aes_cnt_cipher {$/;"	s	file:
aes_cnt_cipher_t	common/aes.h	/^typedef struct aes_cnt_cipher aes_cnt_cipher_t;$/;"	t	typeref:struct:aes_cnt_cipher
aes_crypt	common/aes.c	/^aes_crypt(aes_cnt_cipher_t *cipher, const char *input, size_t len,$/;"	f
aes_crypt_inplace	common/aes.c	/^aes_crypt_inplace(aes_cnt_cipher_t *cipher, char *data, size_t len)$/;"	f
aes_new_cipher	common/aes.c	/^aes_new_cipher(const char *key, const char *iv)$/;"	f
aes_set_iv	common/aes.c	/^aes_set_iv(aes_cnt_cipher_t *cipher, const char *iv)$/;"	f	file:
aes_set_key	common/aes.c	/^aes_set_key(aes_cnt_cipher_t *cipher, const char *key, int key_bits)$/;"	f	file:
after_firsthop_idx	or/or.h	/^  int after_firsthop_idx;$/;"	m	struct:__anon53
alg	or/or.h	/^  digest_algorithm_t alg;$/;"	m	struct:document_signature_t
algorithm	common/crypto.c	/^  digest_algorithm_t algorithm : 8; \/**< Which algorithm is in use? *\/$/;"	m	struct:crypto_digest_t	file:
align	common/OpenBSD_malloc_Linux.c	/^static int align = 0;$/;"	v	file:
all_addrs	or/or.h	/^  unsigned int all_addrs : 1;$/;"	m	struct:port_cfg_t
all_uploads_performed	or/or.h	/^  int all_uploads_performed;$/;"	m	struct:rend_service_descriptor_t
alloc_chunk	common/memarea.c	/^alloc_chunk(size_t sz, int freelist_ok)$/;"	f	file:
alloc_http_authenticator	or/connection.c	/^alloc_http_authenticator(const char *authenticator)$/;"	f
alloc_size	or/buffers.c	/^  size_t alloc_size; \/**< What size chunks does this freelist hold? *\/$/;"	m	struct:chunk_freelist_t	file:
allow_single_hop_exits	or/or.h	/^  unsigned int allow_single_hop_exits:1;  \/**< Whether the router says$/;"	m	struct:__anon41
alpha	or/or.h	/^  double alpha;$/;"	m	struct:__anon54
already_have_cert	or/routerlist.c	/^already_have_cert(authority_cert_t *cert)$/;"	f	file:
always_accept_verify_cb	common/tortls.c	/^always_accept_verify_cb(int preverify_ok,$/;"	f	file:
annotations_len	or/or.h	/^  size_t annotations_len;$/;"	m	struct:signed_descriptor_t
answer	or/eventdns.c	/^	struct server_reply_item *answer; \/* linked list of answer RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
answer_is_wildcarded	or/dns.c	/^answer_is_wildcarded(const char *ip)$/;"	f	file:
any_bridge_descriptors_known	or/circuitbuild.c	/^any_bridge_descriptors_known(void)$/;"	f
any_bridges_dont_support_microdescriptors	or/circuitbuild.c	/^any_bridges_dont_support_microdescriptors(void)$/;"	f
any_pending_bridge_descriptor_fetches	or/circuitbuild.c	/^any_pending_bridge_descriptor_fetches(void)$/;"	f
any_predicted_circuits	or/rephist.c	/^any_predicted_circuits(time_t now)$/;"	f
any_trusted_dir_is_v1_authority	or/routerlist.c	/^any_trusted_dir_is_v1_authority(void)$/;"	f
ap_stream_wants_exit_attention	or/circuitbuild.c	/^ap_stream_wants_exit_attention(connection_t *conn)$/;"	f	file:
append_address_to_payload	or/relay.c	/^append_address_to_payload(uint8_t *payload_out, const tor_addr_t *addr)$/;"	f
append_bytes_to_file	common/util.c	/^append_bytes_to_file(const char *fname, const char *str, size_t len,$/;"	f
append_cell_to_circuit_queue	or/relay.c	/^append_cell_to_circuit_queue(circuit_t *circ, or_connection_t *orconn,$/;"	f
append_exit_policy_string	or/policies.c	/^append_exit_policy_string(smartlist_t **policy, const char *more)$/;"	f	file:
appname	common/log.c	/^static char *appname = NULL;$/;"	v	file:
approx_time	common/util.c	/^approx_time(void)$/;"	f
approx_time	common/util.h	/^#define approx_time(/;"	d
args	or/routerparse.c	/^  char **args;                 \/**< Array of arguments from keyword line. *\/$/;"	m	struct:directory_token_t	file:
argv	or/transports.h	/^  char **argv; \/* the cli arguments of this proxy *\/$/;"	m	struct:__anon71
assert_active_circuits_ok	or/relay.c	/^assert_active_circuits_ok(or_connection_t *orconn)$/;"	f
assert_active_circuits_ok_paranoid	or/relay.c	/^#define assert_active_circuits_ok_paranoid(/;"	d	file:
assert_addr_policy_ok	or/routerparse.c	/^assert_addr_policy_ok(smartlist_t *lst)$/;"	f
assert_all_pending_dns_resolves_ok	or/dns.c	/^assert_all_pending_dns_resolves_ok(void)$/;"	f
assert_buf_ok	or/buffers.c	/^assert_buf_ok(buf_t *buf)$/;"	f
assert_cache_ok	or/dns.c	/^#define assert_cache_ok(/;"	d	file:
assert_chunks_ok	common/mempool.c	/^assert_chunks_ok(mp_pool_t *pool, mp_chunk_t *chunk, int empty, int full)$/;"	f	file:
assert_circuit_ok	or/circuitlist.c	/^assert_circuit_ok(const circuit_t *c)$/;"	f
assert_connection_edge_not_dns_pending	or/dns.c	/^assert_connection_edge_not_dns_pending(edge_connection_t *conn)$/;"	f
assert_connection_ok	or/connection.c	/^assert_connection_ok(connection_t *conn, time_t now)$/;"	f
assert_cpath_layer_ok	or/circuitlist.c	/^assert_cpath_layer_ok(const crypt_path_t *cp)$/;"	f
assert_cpath_ok	or/circuitlist.c	/^assert_cpath_ok(const crypt_path_t *cp)$/;"	f	file:
assert_freelist_ok	or/buffers.c	/^assert_freelist_ok(chunk_freelist_t *fl)$/;"	f	file:
assert_identity_keys_ok	or/router.c	/^assert_identity_keys_ok(void)$/;"	f	file:
assert_resolve_ok	or/dns.c	/^assert_resolve_ok(cached_resolve_t *resolve)$/;"	f	file:
assert_unconfigured_count_ok	or/transports.c	/^assert_unconfigured_count_ok(void)$/;"	f	file:
assign_onionskin_to_cpuworker	or/cpuworker.c	/^assign_onionskin_to_cpuworker(connection_t *cpuworker,$/;"	f
associated_isolated_stream_global_id	or/or.h	/^  uint64_t associated_isolated_stream_global_id;$/;"	m	struct:origin_circuit_t
attr_reentrant	common/compat.c	/^static pthread_mutexattr_t attr_reentrant;$/;"	v	file:
auth_cert	or/or.h	/^  tor_cert_t *auth_cert;$/;"	m	struct:or_handshake_state_t
auth_hid_servs	or/rendclient.c	/^static strmap_t *auth_hid_servs = NULL;$/;"	v	file:
auth_key	common/tortls.c	/^  crypto_pk_t *auth_key;$/;"	m	struct:tor_tls_context_t	file:
auth_type	or/or.h	/^  rend_auth_type_t auth_type;$/;"	m	struct:rend_data_t
auth_type	or/or.h	/^  rend_auth_type_t auth_type;$/;"	m	struct:rend_service_authorization_t
auth_type	or/or.h	/^  uint8_t auth_type;$/;"	m	struct:socks_request_t
auth_type	or/rendservice.c	/^  rend_auth_type_t auth_type; \/**< Client authorization type or 0 if no client$/;"	m	struct:rend_service_t	file:
authdir_baddir_policy	or/policies.c	/^static smartlist_t *authdir_baddir_policy = NULL;$/;"	v	file:
authdir_badexit_policy	or/policies.c	/^static smartlist_t *authdir_badexit_policy = NULL;$/;"	v	file:
authdir_config_new	or/dirserv.c	/^authdir_config_new(void)$/;"	f	file:
authdir_config_t	or/dirserv.c	/^typedef struct authdir_config_t {$/;"	s	file:
authdir_config_t	or/dirserv.c	/^} authdir_config_t;$/;"	t	typeref:struct:authdir_config_t	file:
authdir_invalid_policy	or/policies.c	/^static smartlist_t *authdir_invalid_policy = NULL;$/;"	v	file:
authdir_mode	or/router.c	/^authdir_mode(const or_options_t *options)$/;"	f
authdir_mode_any_main	or/router.c	/^authdir_mode_any_main(const or_options_t *options)$/;"	f
authdir_mode_any_nonhidserv	or/router.c	/^authdir_mode_any_nonhidserv(const or_options_t *options)$/;"	f
authdir_mode_bridge	or/router.c	/^authdir_mode_bridge(const or_options_t *options)$/;"	f
authdir_mode_handles_descs	or/router.c	/^authdir_mode_handles_descs(const or_options_t *options, int purpose)$/;"	f
authdir_mode_publishes_statuses	or/router.c	/^authdir_mode_publishes_statuses(const or_options_t *options)$/;"	f
authdir_mode_tests_reachability	or/router.c	/^authdir_mode_tests_reachability(const or_options_t *options)$/;"	f
authdir_mode_v1	or/router.c	/^authdir_mode_v1(const or_options_t *options)$/;"	f
authdir_mode_v2	or/router.c	/^authdir_mode_v2(const or_options_t *options)$/;"	f
authdir_mode_v3	or/router.c	/^authdir_mode_v3(const or_options_t *options)$/;"	f
authdir_policy_baddir_address	or/policies.c	/^authdir_policy_baddir_address(uint32_t addr, uint16_t port)$/;"	f
authdir_policy_badexit_address	or/policies.c	/^authdir_policy_badexit_address(uint32_t addr, uint16_t port)$/;"	f
authdir_policy_permits_address	or/policies.c	/^authdir_policy_permits_address(uint32_t addr, uint16_t port)$/;"	f
authdir_policy_valid_address	or/policies.c	/^authdir_policy_valid_address(uint32_t addr, uint16_t port)$/;"	f
authdir_reject_policy	or/policies.c	/^static smartlist_t *authdir_reject_policy = NULL;$/;"	v	file:
authdir_type_to_string	or/directory.c	/^authdir_type_to_string(dirinfo_type_t auth)$/;"	f	file:
authdir_wants_to_reject_router	or/dirserv.c	/^authdir_wants_to_reject_router(routerinfo_t *ri, const char **msg,$/;"	f
authenticated	or/or.h	/^  unsigned int authenticated : 1;$/;"	m	struct:or_handshake_state_t
authenticated_peer_id	or/or.h	/^  uint8_t authenticated_peer_id[DIGEST_LEN];$/;"	m	struct:or_handshake_state_t
authentication_cookie	or/control.c	/^static char authentication_cookie[AUTHENTICATION_COOKIE_LEN];$/;"	v	file:
authentication_cookie_is_set	or/control.c	/^static int authentication_cookie_is_set = 0;$/;"	v	file:
authority	or/eventdns.c	/^	struct server_reply_item *authority; \/* linked list of authority RRs *\/$/;"	m	struct:server_request	typeref:struct:server_request::server_reply_item	file:
authority_cert_dl_failed	or/routerlist.c	/^authority_cert_dl_failed(const char *id_digest, int status)$/;"	f
authority_cert_dl_looks_uncertain	or/routerlist.c	/^authority_cert_dl_looks_uncertain(const char *id_digest)$/;"	f
authority_cert_dup	or/dirvote.c	/^authority_cert_dup(authority_cert_t *cert)$/;"	f
authority_cert_free	or/routerlist.c	/^authority_cert_free(authority_cert_t *cert)$/;"	f
authority_cert_get_all	or/routerlist.c	/^authority_cert_get_all(smartlist_t *certs_out)$/;"	f
authority_cert_get_by_digests	or/routerlist.c	/^authority_cert_get_by_digests(const char *id_digest,$/;"	f
authority_cert_get_by_sk_digest	or/routerlist.c	/^authority_cert_get_by_sk_digest(const char *sk_digest)$/;"	f
authority_cert_get_newest_by_id	or/routerlist.c	/^authority_cert_get_newest_by_id(const char *id_digest)$/;"	f
authority_cert_parse_from_string	or/routerparse.c	/^authority_cert_parse_from_string(const char *s, const char **end_of_string)$/;"	f
authority_cert_t	or/or.h	/^typedef struct authority_cert_t {$/;"	s
authority_cert_t	or/or.h	/^} authority_cert_t;$/;"	t	typeref:struct:authority_cert_t
authority_certs_fetch_missing	or/routerlist.c	/^authority_certs_fetch_missing(networkstatus_t *status, time_t now)$/;"	f
authority_key_certificate	or/router.c	/^static authority_cert_t *authority_key_certificate = NULL;$/;"	v	file:
authority_signing_key	or/router.c	/^static crypto_pk_t *authority_signing_key = NULL;$/;"	v	file:
b_crypto	or/or.h	/^  crypto_cipher_t *b_crypto;$/;"	m	struct:crypt_path_t
b_digest	or/or.h	/^  crypto_digest_t *b_digest;$/;"	m	struct:crypt_path_t
ba	common/container.h	/^  bitarray_t *ba; \/**< A bit array to implement the Bloom filter. *\/$/;"	m	struct:__anon8
backend_ops	tools/tor-fw-helper/tor-fw-helper.c	/^  tor_fw_backend_t backend_ops[MAX_BACKENDS];$/;"	m	struct:backends_t	file:
backend_state	tools/tor-fw-helper/tor-fw-helper.c	/^  void *backend_state[MAX_BACKENDS];$/;"	m	struct:backends_t	file:
backends_t	tools/tor-fw-helper/tor-fw-helper.c	/^typedef struct backends_t {$/;"	s	file:
backends_t	tools/tor-fw-helper/tor-fw-helper.c	/^} backends_t;$/;"	t	typeref:struct:backends_t	file:
backup_argc	or/ntmain.c	/^static int backup_argc;$/;"	v	file:
backup_argv	or/ntmain.c	/^static char **backup_argv;$/;"	v	file:
bad_sig	or/or.h	/^  unsigned int bad_sig : 1;$/;"	m	struct:extrainfo_t
bad_signature	or/or.h	/^  unsigned int bad_signature : 1; \/**< Set to true if we've tried to verify$/;"	m	struct:document_signature_t
bad_since	or/circuitbuild.c	/^  time_t bad_since; \/**< 0 if this guard is currently usable, or the time at$/;"	m	struct:__anon18	file:
bandwidth	or/or.h	/^  uint32_t bandwidth; \/**< Bandwidth (capacity) of the router as reported in$/;"	m	struct:routerstatus_t
bandwidth_weight_rule_t	or/or.h	/^typedef enum bandwidth_weight_rule_t {$/;"	g
bandwidth_weight_rule_t	or/or.h	/^} bandwidth_weight_rule_t;$/;"	t	typeref:enum:bandwidth_weight_rule_t
bandwidth_weight_rule_to_string	or/reasons.c	/^bandwidth_weight_rule_to_string(bandwidth_weight_rule_t rule)$/;"	f
bandwidthburst	or/or.h	/^  int bandwidthburst; \/**< Max bucket size for this conn. (OPEN ORs only.) *\/$/;"	m	struct:or_connection_t
bandwidthburst	or/or.h	/^  uint32_t bandwidthburst; \/**< How large is this OR's token bucket? *\/$/;"	m	struct:__anon41
bandwidthcapacity	or/or.h	/^  uint32_t bandwidthcapacity;$/;"	m	struct:__anon41
bandwidthrate	or/or.h	/^  int bandwidthrate; \/**< Bytes\/s added to the bucket. (OPEN ORs only.) *\/$/;"	m	struct:or_connection_t
bandwidthrate	or/or.h	/^  uint32_t bandwidthrate; \/**< How many bytes does this OR add to its token$/;"	m	struct:__anon41
base	common/OpenBSD_malloc_Linux.c	/^	struct pginfo	**base;$/;"	m	struct:pdinfo	typeref:struct:pdinfo::pginfo	file:
base	or/eventdns.c	/^	struct evdns_server_request base;$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_request	file:
base16_decode	common/util.c	/^base16_decode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
base16_encode	common/util.c	/^base16_encode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
base32_decode	common/crypto.c	/^base32_decode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
base32_encode	common/crypto.c	/^base32_encode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
base64_decode	common/crypto.c	/^base64_decode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
base64_decode_table	common/crypto.c	/^static const uint8_t base64_decode_table[256] = {$/;"	v	file:
base64_encode	common/crypto.c	/^base64_encode(char *dest, size_t destlen, const char *src, size_t srclen)$/;"	f
below_threshold	or/rephist.c	/^static uint32_t below_threshold = 0;$/;"	v	file:
bench_aes	test/bench.c	/^bench_aes(void)$/;"	f	file:
bench_cell_aes	test/bench.c	/^bench_cell_aes(void)$/;"	f	file:
bench_cell_ops	test/bench.c	/^bench_cell_ops(void)$/;"	f	file:
bench_dmap	test/bench.c	/^bench_dmap(void)$/;"	f	file:
bench_fn	test/bench.c	/^typedef void (*bench_fn)(void);$/;"	t	file:
benchmark_t	test/bench.c	/^typedef struct benchmark_t {$/;"	s	file:
benchmark_t	test/bench.c	/^} benchmark_t;$/;"	t	typeref:struct:benchmark_t	file:
benchmarks	test/bench.c	/^static struct benchmark_t benchmarks[] = {$/;"	v	typeref:struct:benchmark_t	file:
bidi_map_ent_eq	or/rephist.c	/^bidi_map_ent_eq(const bidi_map_entry_t *a, const bidi_map_entry_t *b)$/;"	f	file:
bidi_map_ent_hash	or/rephist.c	/^bidi_map_ent_hash(const bidi_map_entry_t *entry)$/;"	f	file:
bidi_map_entry_t	or/rephist.c	/^typedef struct bidi_map_entry_t {$/;"	s	file:
bidi_map_entry_t	or/rephist.c	/^} bidi_map_entry_t;$/;"	t	typeref:struct:bidi_map_entry_t	file:
bidi_map_free	or/rephist.c	/^bidi_map_free(void)$/;"	f	file:
bidi_next_interval	or/rephist.c	/^static time_t bidi_next_interval = 0;$/;"	v	file:
binary	common/util.c	/^  unsigned binary:1; \/**< Did we open in binary mode? *\/$/;"	m	struct:open_file_t	file:
binds_names	or/or.h	/^  unsigned int binds_names:1; \/**< True iff this directory server binds$/;"	m	struct:networkstatus_v2_t
bitarray_clear	common/container.h	/^bitarray_clear(bitarray_t *b, int bit)$/;"	f
bitarray_expand	common/container.h	/^bitarray_expand(bitarray_t *ba,$/;"	f
bitarray_free	common/container.h	/^bitarray_free(bitarray_t *ba)$/;"	f
bitarray_init_zero	common/container.h	/^bitarray_init_zero(unsigned int n_bits)$/;"	f
bitarray_is_set	common/container.h	/^bitarray_is_set(bitarray_t *b, int bit)$/;"	f
bitarray_set	common/container.h	/^bitarray_set(bitarray_t *b, int bit)$/;"	f
bitarray_t	common/container.h	/^typedef unsigned int bitarray_t;$/;"	t
bits	common/OpenBSD_malloc_Linux.c	/^	u_long		bits[1];\/* Which chunks are free *\/$/;"	m	struct:pginfo	file:
body	or/dirvote.c	/^  char *body;$/;"	m	struct:pending_consensus_t	file:
body	or/networkstatus.c	/^  char *body;$/;"	m	struct:consensus_waiting_for_certs_t	file:
body	or/or.h	/^  char *body;$/;"	m	struct:microdesc_t
body	or/or.h	/^  char body[CELL_NETWORK_SIZE]; \/**< Cell as packed for network. *\/$/;"	m	struct:packed_cell_t
body_is_plausible	or/directory.c	/^body_is_plausible(const char *body, size_t len, int purpose)$/;"	f	file:
bodylen	or/or.h	/^  size_t bodylen;$/;"	m	struct:microdesc_t
bool_eq	common/util.h	/^#define bool_eq(/;"	d
bool_neq	common/util.h	/^#define bool_neq(/;"	d
bootstrap_percent	or/control.c	/^static int bootstrap_percent = BOOTSTRAP_STATUS_UNDEF;$/;"	v	file:
bootstrap_problems	or/control.c	/^static int bootstrap_problems = 0;$/;"	v	file:
bootstrap_status_t	or/or.h	/^} bootstrap_status_t;$/;"	t	typeref:enum:__anon56
bootstrap_status_to_string	or/control.c	/^bootstrap_status_to_string(bootstrap_status_t s, const char **tag,$/;"	f	file:
both_read_and_written	or/rephist.c	/^static uint32_t both_read_and_written = 0;$/;"	v	file:
bridge_add_from_config	or/circuitbuild.c	/^bridge_add_from_config(const tor_addr_t *addr, uint16_t port,$/;"	f
bridge_dl_schedule	or/directory.c	/^static const int bridge_dl_schedule[] = {$/;"	v	file:
bridge_free	or/circuitbuild.c	/^bridge_free(bridge_info_t *bridge)$/;"	f	file:
bridge_get_advertised_bandwidth_bounded	or/routerlist.c	/^bridge_get_advertised_bandwidth_bounded(routerinfo_t *router)$/;"	f	file:
bridge_info_t	or/circuitbuild.c	/^} bridge_info_t;$/;"	t	typeref:struct:__anon19	file:
bridge_list	or/circuitbuild.c	/^static smartlist_t *bridge_list = NULL;$/;"	v	file:
bridge_stats_extrainfo	or/geoip.c	/^static char *bridge_stats_extrainfo = NULL;$/;"	v	file:
broken_connection_counts	or/connection_or.c	/^static strmap_t *broken_connection_counts;$/;"	v	file:
broken_state_count_compare	or/connection_or.c	/^broken_state_count_compare(const void **a_ptr, const void **b_ptr)$/;"	f	file:
broken_state_count_t	or/connection_or.c	/^typedef struct broken_state_count_t {$/;"	s	file:
broken_state_count_t	or/connection_or.c	/^} broken_state_count_t;$/;"	t	typeref:struct:broken_state_count_t	file:
bucket_cfg	or/or.h	/^  struct ev_token_bucket_cfg *bucket_cfg;$/;"	m	struct:or_connection_t	typeref:struct:or_connection_t::ev_token_bucket_cfg
buf	common/aes.c	/^    uint8_t buf[16];$/;"	m	union:aes_cnt_cipher::__anon4	file:
buf	common/aes.c	/^  uint8_t buf[16];$/;"	m	struct:aes_cnt_cipher	file:
buf	common/sha256.c	/^    unsigned char buf[64];$/;"	m	struct:sha256_state	file:
buf	test/test.c	/^  buf_t *buf;$/;"	m	struct:socks_test_data_t	file:
buf32	common/aes.c	/^    uint32_t buf32[4];$/;"	m	union:aes_cnt_cipher::__anon4	file:
buf_add_chunk_with_capacity	or/buffers.c	/^buf_add_chunk_with_capacity(buf_t *buf, size_t capacity, int capped)$/;"	f	file:
buf_allocation	or/buffers.c	/^buf_allocation(const buf_t *buf)$/;"	f
buf_clear	or/buffers.c	/^buf_clear(buf_t *buf)$/;"	f
buf_copy	or/buffers.c	/^buf_copy(const buf_t *buf)$/;"	f
buf_datalen	or/buffers.c	/^buf_datalen(const buf_t *buf)$/;"	f
buf_dump_freelist_sizes	or/buffers.c	/^buf_dump_freelist_sizes(int severity)$/;"	f
buf_find_offset_of_char	or/buffers.c	/^buf_find_offset_of_char(buf_t *buf, char ch)$/;"	f	file:
buf_find_pos_of_char	or/buffers.c	/^buf_find_pos_of_char(char ch, buf_pos_t *out)$/;"	f	file:
buf_find_string_offset	or/buffers.c	/^buf_find_string_offset(const buf_t *buf, const char *s, size_t n)$/;"	f
buf_free	or/buffers.c	/^buf_free(buf_t *buf)$/;"	f
buf_matches_at_pos	or/buffers.c	/^buf_matches_at_pos(const buf_pos_t *pos, const char *s, size_t n)$/;"	f	file:
buf_new	or/buffers.c	/^buf_new(void)$/;"	f
buf_new_with_capacity	or/buffers.c	/^buf_new_with_capacity(size_t size)$/;"	f
buf_pos_inc	or/buffers.c	/^buf_pos_inc(buf_pos_t *pos)$/;"	f	file:
buf_pos_init	or/buffers.c	/^buf_pos_init(const buf_t *buf, buf_pos_t *out)$/;"	f	file:
buf_pos_t	or/buffers.c	/^typedef struct buf_pos_t {$/;"	s	file:
buf_pos_t	or/buffers.c	/^} buf_pos_t;$/;"	t	typeref:struct:buf_pos_t	file:
buf_pullup	or/buffers.c	/^buf_pullup(buf_t *buf, size_t bytes, int nulterminate)$/;"	f	file:
buf_remove_from_front	or/buffers.c	/^buf_remove_from_front(buf_t *buf, size_t n)$/;"	f	file:
buf_shrink	or/buffers.c	/^buf_shrink(buf_t *buf)$/;"	f
buf_shrink_freelists	or/buffers.c	/^buf_shrink_freelists(int free_all)$/;"	f
buf_slack	or/buffers.c	/^buf_slack(const buf_t *buf)$/;"	f
buf_t	or/buffers.c	/^struct buf_t {$/;"	s	file:
buf_t	or/or.h	/^typedef struct buf_t buf_t;$/;"	t	typeref:struct:buf_t
bufev	or/or.h	/^  struct bufferevent *bufev; \/**< A Libevent buffered IO structure. *\/$/;"	m	struct:connection_t	typeref:struct:connection_t::bufferevent
buffer1	test/tinytest_demo.c	/^	char buffer1[512];$/;"	m	struct:data_buffer	file:
buffer2	test/tinytest_demo.c	/^	char buffer2[512];$/;"	m	struct:data_buffer	file:
build_socks_resolve_request	tools/tor-resolve.c	/^build_socks_resolve_request(char **out,$/;"	f	file:
build_state	or/or.h	/^  cpath_build_state_t *build_state;$/;"	m	struct:origin_circuit_t
build_state_get_exit_nickname	or/circuitbuild.c	/^build_state_get_exit_nickname(cpath_build_state_t *state)$/;"	f
build_state_get_exit_node	or/circuitbuild.c	/^build_state_get_exit_node(cpath_build_state_t *state)$/;"	f
build_time_t	or/or.h	/^typedef uint32_t build_time_t;$/;"	t
build_times_idx	or/or.h	/^  int build_times_idx;$/;"	m	struct:__anon54
buildtimeout_set_event_t	or/or.h	/^typedef enum buildtimeout_set_event_t {$/;"	g
buildtimeout_set_event_t	or/or.h	/^} buildtimeout_set_event_t;$/;"	t	typeref:enum:buildtimeout_set_event_t
built_last_stability_doc_at	or/rephist.c	/^static time_t built_last_stability_doc_at = 0;$/;"	v	file:
bw	or/or.h	/^  long int bw;$/;"	m	struct:measured_bw_line_t
bw_array_new	or/rephist.c	/^bw_array_new(void)$/;"	f	file:
bw_array_t	or/rephist.c	/^typedef struct bw_array_t {$/;"	s	file:
bw_array_t	or/rephist.c	/^} bw_array_t;$/;"	t	typeref:struct:bw_array_t	file:
bw_arrays_init	or/rephist.c	/^bw_arrays_init(void)$/;"	f	file:
bw_weights_error_t	or/dirvote.c	/^} bw_weights_error_t;$/;"	t	typeref:enum:__anon24	file:
bytes	common/util.h	/^  const char *bytes;$/;"	m	struct:sized_chunk_t
bytes	or/directory.c	/^  uint64_t bytes; \/**< How many bytes have we transferred? *\/$/;"	m	struct:request_t	file:
bytes_dropped	or/microdesc.c	/^  size_t bytes_dropped;$/;"	m	struct:microdesc_cache_t	file:
bytes_dropped	or/or.h	/^  size_t bytes_dropped;$/;"	m	struct:desc_store_t
bytes_to_usage	or/status.c	/^bytes_to_usage(uint64_t bytes)$/;"	f	file:
c_hist_t	or/geoip.c	/^typedef struct c_hist_t {$/;"	s	file:
c_hist_t	or/geoip.c	/^} c_hist_t;$/;"	t	typeref:struct:c_hist_t	file:
cache_content	or/microdesc.c	/^  tor_mmap_t *cache_content;$/;"	m	struct:microdesc_cache_t	file:
cache_fname	or/microdesc.c	/^  char *cache_fname;$/;"	m	struct:microdesc_cache_t	file:
cache_info	or/or.h	/^  signed_descriptor_t cache_info;$/;"	m	struct:__anon41
cache_info	or/or.h	/^  signed_descriptor_t cache_info;$/;"	m	struct:authority_cert_t
cache_info	or/or.h	/^  signed_descriptor_t cache_info;$/;"	m	struct:extrainfo_t
cached_approx_time	common/util.c	/^static time_t cached_approx_time = 0;$/;"	v	file:
cached_consensuses	or/dirserv.c	/^static strmap_t *cached_consensuses = NULL;$/;"	v	file:
cached_dir	or/or.h	/^  struct cached_dir_t *cached_dir;$/;"	m	struct:dir_connection_t	typeref:struct:dir_connection_t::cached_dir_t
cached_dir_decref	or/dirserv.c	/^cached_dir_decref(cached_dir_t *d)$/;"	f
cached_dir_offset	or/or.h	/^  off_t cached_dir_offset;$/;"	m	struct:dir_connection_t
cached_dir_t	or/or.h	/^typedef struct cached_dir_t {$/;"	s
cached_dir_t	or/or.h	/^} cached_dir_t;$/;"	t	typeref:struct:cached_dir_t
cached_directory	or/dirserv.c	/^static cached_dir_t *cached_directory = NULL;$/;"	v	file:
cached_resolve_hash	or/dns.c	/^cached_resolve_hash(cached_resolve_t *a)$/;"	f	file:
cached_resolve_pqueue	or/dns.c	/^static smartlist_t *cached_resolve_pqueue = NULL;$/;"	v	file:
cached_resolve_t	or/dns.c	/^typedef struct cached_resolve_t {$/;"	s	file:
cached_resolve_t	or/dns.c	/^} cached_resolve_t;$/;"	t	typeref:struct:cached_resolve_t	file:
cached_resolves_eq	or/dns.c	/^cached_resolves_eq(cached_resolve_t *a, cached_resolve_t *b)$/;"	f	file:
cached_runningrouters	or/dirserv.c	/^static cached_dir_t cached_runningrouters;$/;"	v	file:
cached_time_hires	or/relay.c	/^static struct timeval cached_time_hires = {0, 0};$/;"	v	typeref:struct:timeval	file:
cached_v2_networkstatus	or/dirserv.c	/^static digestmap_t *cached_v2_networkstatus = NULL;$/;"	v	file:
caches_extra_info	or/or.h	/^  unsigned int caches_extra_info:1; \/**< Whether the router says it caches and$/;"	m	struct:__anon41
callback	common/log.c	/^  log_callback callback; \/**< If not NULL, send messages to this function. *\/$/;"	m	struct:logfile_t	file:
callback_arg	common/tortls.c	/^  void *callback_arg;$/;"	m	struct:tor_tls_t	file:
called_loop_once	or/main.c	/^static int called_loop_once = 0;$/;"	v	file:
calloc	common/OpenBSD_malloc_Linux.c	/^calloc(size_t num, size_t size)$/;"	f
can_complete_circuit	or/main.c	/^int can_complete_circuit=0;$/;"	v
can_reach_dir_port	or/router.c	/^static int can_reach_dir_port = 0;$/;"	v	file:
can_reach_or_port	or/router.c	/^static int can_reach_or_port = 0;$/;"	v	file:
can_retry	or/circuitbuild.c	/^  unsigned int can_retry : 1; \/**< Should we retry connecting to this entry,$/;"	m	struct:__anon18	file:
capacity	common/container.h	/^  int capacity;$/;"	m	struct:smartlist_t
capacity	common/mempool.c	/^  int capacity; \/**< Number of items that can be fit into this chunk. *\/$/;"	m	struct:mp_chunk_t	file:
cases	test/tinytest.h	/^	struct testcase_t *cases; \/** Array, ending with END_OF_TESTCASES *\/$/;"	m	struct:testgroup_t	typeref:struct:testgroup_t::testcase_t
cb	common/compat_libevent.c	/^  void (*cb)(struct periodic_timer_t *, void *);$/;"	m	struct:periodic_timer_t	file:
cb	common/procmon.c	/^  tor_procmon_callback_t cb;$/;"	m	struct:tor_process_monitor_t	file:
cb_arg	common/procmon.c	/^  void *cb_arg; \/**< A user-specified pointer to be passed to cb. *\/$/;"	m	struct:tor_process_monitor_t	file:
cell_command_is_var_length	or/buffers.c	/^cell_command_is_var_length(uint8_t command, int linkproto)$/;"	f	file:
cell_count	or/or.h	/^  double cell_count;$/;"	m	struct:__anon48
cell_direction_t	or/or.h	/^} cell_direction_t;$/;"	t	typeref:enum:__anon35
cell_ewma_get_tick	or/relay.c	/^cell_ewma_get_tick(void)$/;"	f
cell_ewma_set_scale_factor	or/relay.c	/^cell_ewma_set_scale_factor(const or_options_t *options,$/;"	f
cell_ewma_t	or/or.h	/^} cell_ewma_t;$/;"	t	typeref:struct:__anon48
cell_ewma_tick_from_timeval	or/relay.c	/^cell_ewma_tick_from_timeval(const struct timeval *now,$/;"	f	file:
cell_ewma_to_circuit	or/relay.c	/^cell_ewma_to_circuit(cell_ewma_t *ewma)$/;"	f	file:
cell_pack	or/connection_or.c	/^cell_pack(packed_cell_t *dst, const cell_t *src)$/;"	f
cell_pool	or/relay.c	/^static mp_pool_t *cell_pool = NULL;$/;"	v	file:
cell_queue_append	or/relay.c	/^cell_queue_append(cell_queue_t *queue, packed_cell_t *cell)$/;"	f
cell_queue_append_packed_copy	or/relay.c	/^cell_queue_append_packed_copy(cell_queue_t *queue, const cell_t *cell)$/;"	f
cell_queue_clear	or/relay.c	/^cell_queue_clear(cell_queue_t *queue)$/;"	f
cell_queue_pop	or/relay.c	/^cell_queue_pop(cell_queue_t *queue)$/;"	f	file:
cell_queue_t	or/or.h	/^typedef struct cell_queue_t {$/;"	s
cell_queue_t	or/or.h	/^} cell_queue_t;$/;"	t	typeref:struct:cell_queue_t
cell_t	or/or.h	/^#define cell_t /;"	d
cell_t	or/or.h	/^typedef struct cell_t {$/;"	s
cell_t	or/or.h	/^} cell_t;$/;"	t	typeref:struct:cell_t
cell_unpack	or/connection_or.c	/^cell_unpack(cell_t *dest, const char *src)$/;"	f	file:
cert	common/tortls.c	/^  X509 *cert;$/;"	m	struct:tor_cert_t	file:
cert	or/or.h	/^  struct authority_cert_t *cert; \/**< Vote only: the voter's certificate. *\/$/;"	m	struct:networkstatus_t	typeref:struct:networkstatus_t::authority_cert_t
cert_digests	common/tortls.c	/^  digests_t cert_digests;$/;"	m	struct:tor_cert_t	file:
cert_list_t	or/routerlist.c	/^typedef struct cert_list_t {$/;"	s	file:
cert_list_t	or/routerlist.c	/^} cert_list_t;$/;"	t	typeref:struct:cert_list_t	file:
certificate_file	tools/tor-gencert.c	/^char *certificate_file = NULL;$/;"	v
certs	or/routerlist.c	/^  smartlist_t *certs;$/;"	m	struct:cert_list_t	file:
cfg_start_day	or/hibernate.c	/^static int cfg_start_day = 0,$/;"	v	file:
cfg_start_hour	or/hibernate.c	/^           cfg_start_hour = 0,$/;"	v	file:
cfg_start_min	or/hibernate.c	/^           cfg_start_min = 0;$/;"	v	file:
cfg_unit	or/hibernate.c	/^static time_unit_t cfg_unit = UNIT_MONTH;$/;"	v	file:
change_callback_log_severity	common/log.c	/^change_callback_log_severity(int loglevelMin, int loglevelMax,$/;"	f
changed	or/rephist.c	/^  time_t changed;$/;"	m	struct:link_history_t	file:
changed	or/rephist.c	/^  time_t changed;$/;"	m	struct:or_history_t	file:
check	or/buffers.c	/^#define check(/;"	d	file:
check_cert_lifetime_internal	common/tortls.c	/^check_cert_lifetime_internal(int severity, const X509 *cert,$/;"	f	file:
check_descriptor_bandwidth_changed	or/router.c	/^check_descriptor_bandwidth_changed(time_t now)$/;"	f
check_descriptor_ipaddress_changed	or/router.c	/^check_descriptor_ipaddress_changed(time_t now)$/;"	f
check_if_restarts_needed	or/transports.c	/^static int check_if_restarts_needed = 0;$/;"	v	file:
check_location_for_unix_socket	or/connection.c	/^check_location_for_unix_socket(const or_options_t *options, const char *path)$/;"	f	file:
check_nickname_list	or/config.c	/^check_nickname_list(const char *lst, const char *name, char **msg)$/;"	f	file:
check_no_tls_errors	common/tortls.h	/^#define check_no_tls_errors(/;"	d
check_private_dir	common/util.c	/^check_private_dir(const char *dirname, cpd_check_t check,$/;"	f
check_server_ports	or/config.c	/^check_server_ports(const smartlist_t *ports,$/;"	f	file:
check_signature_token	or/routerparse.c	/^check_signature_token(const char *digest,$/;"	f	file:
check_sockaddr	or/connection.c	/^check_sockaddr(struct sockaddr *sa, int len, int level)$/;"	f	file:
check_sockaddr_family_match	or/connection.c	/^check_sockaddr_family_match(sa_family_t got, connection_t *listener)$/;"	f	file:
check_whether_dirport_reachable	or/router.c	/^check_whether_dirport_reachable(void)$/;"	f
check_whether_orport_reachable	or/router.c	/^check_whether_orport_reachable(void)$/;"	f
choked	or/eventdns.c	/^	char choked;  \/* true if we have an EAGAIN from this server's socket *\/$/;"	m	struct:nameserver	file:
choked	or/eventdns.c	/^	char choked; \/* Are we currently blocked from writing? *\/$/;"	m	struct:evdns_server_port	file:
choose_good_entry_server	or/circuitbuild.c	/^choose_good_entry_server(uint8_t purpose, cpath_build_state_t *state)$/;"	f	file:
choose_good_exit_server	or/circuitbuild.c	/^choose_good_exit_server(uint8_t purpose,$/;"	f	file:
choose_good_exit_server_general	or/circuitbuild.c	/^choose_good_exit_server_general(int need_uptime, int need_capacity)$/;"	f	file:
choose_good_middle_server	or/circuitbuild.c	/^choose_good_middle_server(uint8_t purpose,$/;"	f	file:
choose_random_entry	or/circuitbuild.c	/^choose_random_entry(cpath_build_state_t *state)$/;"	f
chosen_by_version	or/circuitbuild.c	/^  char *chosen_by_version; \/**< What tor version added this guard? NULL$/;"	m	struct:__anon18	file:
chosen_exit	or/or.h	/^  extend_info_t *chosen_exit;$/;"	m	struct:__anon47
chosen_exit_name	or/or.h	/^  char *chosen_exit_name;$/;"	m	struct:entry_connection_t
chosen_exit_optional	or/or.h	/^  unsigned int chosen_exit_optional:1;$/;"	m	struct:entry_connection_t
chosen_exit_retries	or/or.h	/^  unsigned int chosen_exit_retries:3;$/;"	m	struct:entry_connection_t
chosen_on_date	or/circuitbuild.c	/^  time_t chosen_on_date; \/**< Approximately when was this guard added?$/;"	m	struct:__anon18	file:
chunk	or/buffers.c	/^  const chunk_t *chunk; \/**< Which chunk are we pointing to? *\/$/;"	m	struct:buf_pos_t	file:
chunk_copy	or/buffers.c	/^chunk_copy(const chunk_t *in_chunk)$/;"	f	file:
chunk_free_unchecked	common/memarea.c	/^chunk_free_unchecked(memarea_chunk_t *chunk)$/;"	f	file:
chunk_free_unchecked	or/buffers.c	/^chunk_free_unchecked(chunk_t *chunk)$/;"	f	file:
chunk_freelist_t	or/buffers.c	/^typedef struct chunk_freelist_t {$/;"	s	file:
chunk_freelist_t	or/buffers.c	/^} chunk_freelist_t;$/;"	t	typeref:struct:chunk_freelist_t	file:
chunk_grow	or/buffers.c	/^chunk_grow(chunk_t *chunk, size_t sz)$/;"	f	file:
chunk_new_with_alloc_size	or/buffers.c	/^chunk_new_with_alloc_size(size_t alloc)$/;"	f	file:
chunk_pos	or/buffers.c	/^  size_t chunk_pos; \/**< Total length of all previous chunks. *\/$/;"	m	struct:buf_pos_t	file:
chunk_repack	or/buffers.c	/^chunk_repack(chunk_t *chunk)$/;"	f	file:
chunk_t	or/buffers.c	/^typedef struct chunk_t {$/;"	s	file:
chunk_t	or/buffers.c	/^} chunk_t;$/;"	t	typeref:struct:chunk_t	file:
cipher	common/crypto.c	/^  aes_cnt_cipher_t *cipher; \/**< The key in format usable for counter-mode AES$/;"	m	struct:crypto_cipher_t	file:
cipher_info_t	common/tortls.c	/^typedef struct cipher_info_t { unsigned id; const char *name; } cipher_info_t;$/;"	s	file:
cipher_info_t	common/tortls.c	/^typedef struct cipher_info_t { unsigned id; const char *name; } cipher_info_t;$/;"	t	typeref:struct:cipher_info_t	file:
circ	or/onion.c	/^  or_circuit_t *circ;$/;"	m	struct:onion_queue_t	file:
circ_buffer_stats_t	or/rephist.c	/^typedef struct circ_buffer_stats_t {$/;"	s	file:
circ_buffer_stats_t	or/rephist.c	/^} circ_buffer_stats_t;$/;"	t	typeref:struct:circ_buffer_stats_t	file:
circ_id	or/circuitlist.c	/^  circid_t circ_id;$/;"	m	struct:orconn_circid_circuit_map_t	file:
circ_id	or/or.h	/^  circid_t circ_id; \/**< Circuit which received the cell. *\/$/;"	m	struct:cell_t
circ_id	or/or.h	/^  circid_t circ_id;$/;"	m	struct:var_cell_t
circ_id_type	or/or.h	/^  circ_id_type_t circ_id_type:2; \/**< When we send CREATE cells along this$/;"	m	struct:or_connection_t
circ_id_type_t	or/or.h	/^} circ_id_type_t;$/;"	t	typeref:enum:__anon34
circ_times	or/circuitbuild.c	/^circuit_build_times_t circ_times;$/;"	v
circid_t	or/or.h	/^typedef uint16_t circid_t;$/;"	t
circuit	or/circuitlist.c	/^  circuit_t *circuit;$/;"	m	struct:orconn_circid_circuit_map_t	file:
circuit_add	or/circuitlist.c	/^circuit_add(circuit_t *circ)$/;"	f	file:
circuit_all_predicted_ports_handled	or/circuitbuild.c	/^circuit_all_predicted_ports_handled(time_t now, int *need_uptime,$/;"	f
circuit_append_new_exit	or/circuitbuild.c	/^circuit_append_new_exit(origin_circuit_t *circ, extend_info_t *exit)$/;"	f
circuit_build_failed	or/circuituse.c	/^circuit_build_failed(origin_circuit_t *circ)$/;"	f
circuit_build_needed_circs	or/circuituse.c	/^circuit_build_needed_circs(time_t now)$/;"	f
circuit_build_times	or/or.h	/^  build_time_t circuit_build_times[CBT_NCIRCUITS_TO_OBSERVE];$/;"	m	struct:__anon54
circuit_build_times_add_time	or/circuitbuild.c	/^circuit_build_times_add_time(circuit_build_times_t *cbt, build_time_t time)$/;"	f
circuit_build_times_calculate_timeout	or/circuitbuild.c	/^circuit_build_times_calculate_timeout(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_cdf	or/circuitbuild.c	/^circuit_build_times_cdf(circuit_build_times_t *cbt, double x)$/;"	f
circuit_build_times_close_quantile	or/circuitbuild.c	/^circuit_build_times_close_quantile(void)$/;"	f	file:
circuit_build_times_close_rate	or/circuitbuild.c	/^circuit_build_times_close_rate(const circuit_build_times_t *cbt)$/;"	f
circuit_build_times_count_close	or/circuitbuild.c	/^circuit_build_times_count_close(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_count_timeout	or/circuitbuild.c	/^circuit_build_times_count_timeout(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_create_histogram	or/circuitbuild.c	/^circuit_build_times_create_histogram(circuit_build_times_t *cbt,$/;"	f	file:
circuit_build_times_default_num_xm_modes	or/circuitbuild.c	/^circuit_build_times_default_num_xm_modes(void)$/;"	f	file:
circuit_build_times_disabled	or/circuitbuild.c	/^circuit_build_times_disabled(void)$/;"	f	file:
circuit_build_times_enough_to_compute	or/circuitbuild.c	/^circuit_build_times_enough_to_compute(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_filter_timeouts	or/circuitbuild.c	/^circuit_build_times_filter_timeouts(circuit_build_times_t *cbt)$/;"	f	file:
circuit_build_times_generate_sample	or/circuitbuild.c	/^circuit_build_times_generate_sample(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_get_bw_scale	or/circuitbuild.c	/^circuit_build_times_get_bw_scale(networkstatus_t *ns)$/;"	f
circuit_build_times_get_initial_timeout	or/circuitbuild.c	/^circuit_build_times_get_initial_timeout(void)$/;"	f	file:
circuit_build_times_get_xm	or/circuitbuild.c	/^circuit_build_times_get_xm(circuit_build_times_t *cbt)$/;"	f	file:
circuit_build_times_init	or/circuitbuild.c	/^circuit_build_times_init(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_initial_alpha	or/circuitbuild.c	/^circuit_build_times_initial_alpha(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_initial_timeout	or/circuitbuild.c	/^circuit_build_times_initial_timeout(void)$/;"	f
circuit_build_times_max	or/circuitbuild.c	/^circuit_build_times_max(circuit_build_times_t *cbt)$/;"	f	file:
circuit_build_times_max_timeouts	or/circuitbuild.c	/^circuit_build_times_max_timeouts(void)$/;"	f	file:
circuit_build_times_min_circs_to_observe	or/circuitbuild.c	/^circuit_build_times_min_circs_to_observe(void)$/;"	f	file:
circuit_build_times_min_timeout	or/circuitbuild.c	/^circuit_build_times_min_timeout(void)$/;"	f	file:
circuit_build_times_needs_circuits	or/circuitbuild.c	/^circuit_build_times_needs_circuits(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_needs_circuits_now	or/circuitbuild.c	/^circuit_build_times_needs_circuits_now(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_network_check_changed	or/circuitbuild.c	/^circuit_build_times_network_check_changed(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_network_check_live	or/circuitbuild.c	/^circuit_build_times_network_check_live(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_network_circ_success	or/circuitbuild.c	/^circuit_build_times_network_circ_success(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_network_close	or/circuitbuild.c	/^circuit_build_times_network_close(circuit_build_times_t *cbt,$/;"	f	file:
circuit_build_times_network_is_live	or/circuitbuild.c	/^circuit_build_times_network_is_live(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_network_timeout	or/circuitbuild.c	/^circuit_build_times_network_timeout(circuit_build_times_t *cbt,$/;"	f	file:
circuit_build_times_new_consensus_params	or/circuitbuild.c	/^circuit_build_times_new_consensus_params(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_parse_state	or/circuitbuild.c	/^circuit_build_times_parse_state(circuit_build_times_t *cbt,$/;"	f
circuit_build_times_quantile_cutoff	or/circuitbuild.c	/^circuit_build_times_quantile_cutoff(void)$/;"	f
circuit_build_times_recent_circuit_count	or/circuitbuild.c	/^circuit_build_times_recent_circuit_count(networkstatus_t *ns)$/;"	f	file:
circuit_build_times_reset	or/circuitbuild.c	/^circuit_build_times_reset(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_set_timeout	or/circuitbuild.c	/^circuit_build_times_set_timeout(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_set_timeout_worker	or/circuitbuild.c	/^circuit_build_times_set_timeout_worker(circuit_build_times_t *cbt)$/;"	f	file:
circuit_build_times_shuffle_and_store_array	or/circuitbuild.c	/^circuit_build_times_shuffle_and_store_array(circuit_build_times_t *cbt,$/;"	f	file:
circuit_build_times_t	or/or.h	/^} circuit_build_times_t;$/;"	t	typeref:struct:__anon54
circuit_build_times_test_frequency	or/circuitbuild.c	/^circuit_build_times_test_frequency(void)$/;"	f	file:
circuit_build_times_timeout_rate	or/circuitbuild.c	/^circuit_build_times_timeout_rate(const circuit_build_times_t *cbt)$/;"	f
circuit_build_times_update_alpha	or/circuitbuild.c	/^circuit_build_times_update_alpha(circuit_build_times_t *cbt)$/;"	f
circuit_build_times_update_state	or/circuitbuild.c	/^circuit_build_times_update_state(circuit_build_times_t *cbt,$/;"	f
circuit_change_purpose	or/circuituse.c	/^circuit_change_purpose(circuit_t *circ, uint8_t new_purpose)$/;"	f
circuit_clear_cell_queue	or/relay.c	/^circuit_clear_cell_queue(circuit_t *circ, or_connection_t *orconn)$/;"	f
circuit_clear_isolation	or/connection_edge.c	/^circuit_clear_isolation(origin_circuit_t *circ)$/;"	f
circuit_close_all_marked	or/circuitlist.c	/^circuit_close_all_marked(void)$/;"	f
circuit_consider_sending_sendme	or/relay.c	/^circuit_consider_sending_sendme(circuit_t *circ, crypt_path_t *layer_hint)$/;"	f	file:
circuit_consider_stop_edge_reading	or/relay.c	/^circuit_consider_stop_edge_reading(circuit_t *circ, crypt_path_t *layer_hint)$/;"	f	file:
circuit_count_pending_on_or_conn	or/circuitlist.c	/^circuit_count_pending_on_or_conn(or_connection_t *or_conn)$/;"	f
circuit_deliver_create_cell	or/circuitbuild.c	/^circuit_deliver_create_cell(circuit_t *circ, uint8_t cell_type,$/;"	f	file:
circuit_describe_status_for_controller	or/control.c	/^circuit_describe_status_for_controller(origin_circuit_t *circ)$/;"	f	file:
circuit_detach_stream	or/circuituse.c	/^circuit_detach_stream(circuit_t *circ, edge_connection_t *conn)$/;"	f
circuit_discard_optional_exit_enclaves	or/connection_edge.c	/^circuit_discard_optional_exit_enclaves(extend_info_t *info)$/;"	f
circuit_dump_by_conn	or/circuitlist.c	/^circuit_dump_by_conn(connection_t *conn, int severity)$/;"	f
circuit_dump_details	or/circuitlist.c	/^circuit_dump_details(int severity, circuit_t *circ, int conn_array_index,$/;"	f	file:
circuit_end_reason_to_control_string	or/reasons.c	/^circuit_end_reason_to_control_string(int reason)$/;"	f
circuit_enough_testing_circs	or/circuituse.c	/^circuit_enough_testing_circs(void)$/;"	f
circuit_establish_circuit	or/circuitbuild.c	/^circuit_establish_circuit(uint8_t purpose, extend_info_t *exit, int flags)$/;"	f
circuit_expire_all_dirty_circs	or/circuitlist.c	/^circuit_expire_all_dirty_circs(void)$/;"	f
circuit_expire_building	or/circuituse.c	/^circuit_expire_building(void)$/;"	f
circuit_expire_old_circuits_clientside	or/circuituse.c	/^circuit_expire_old_circuits_clientside(void)$/;"	f	file:
circuit_expire_old_circuits_serverside	or/circuituse.c	/^circuit_expire_old_circuits_serverside(time_t now)$/;"	f
circuit_extend	or/circuitbuild.c	/^circuit_extend(cell_t *cell, circuit_t *circ)$/;"	f
circuit_extend_to_new_exit	or/circuitbuild.c	/^circuit_extend_to_new_exit(origin_circuit_t *circ, extend_info_t *exit)$/;"	f
circuit_find_to_cannibalize	or/circuitlist.c	/^circuit_find_to_cannibalize(uint8_t purpose, extend_info_t *info,$/;"	f
circuit_finish_handshake	or/circuitbuild.c	/^circuit_finish_handshake(origin_circuit_t *circ, uint8_t reply_type,$/;"	f
circuit_free	or/circuitlist.c	/^circuit_free(circuit_t *circ)$/;"	f	file:
circuit_free_all	or/circuitlist.c	/^circuit_free_all(void)$/;"	f
circuit_free_cpath	or/circuitlist.c	/^circuit_free_cpath(crypt_path_t *cpath)$/;"	f	file:
circuit_free_cpath_node	or/circuitlist.c	/^circuit_free_cpath_node(crypt_path_t *victim)$/;"	f	file:
circuit_get_all_pending_on_or_conn	or/circuitlist.c	/^circuit_get_all_pending_on_or_conn(smartlist_t *out, or_connection_t *or_conn)$/;"	f
circuit_get_best	or/circuituse.c	/^circuit_get_best(const entry_connection_t *conn,$/;"	f	file:
circuit_get_by_circid_orconn	or/circuitlist.c	/^circuit_get_by_circid_orconn(circid_t circ_id, or_connection_t *conn)$/;"	f
circuit_get_by_circid_orconn_impl	or/circuitlist.c	/^circuit_get_by_circid_orconn_impl(circid_t circ_id, or_connection_t *conn)$/;"	f	file:
circuit_get_by_edge_conn	or/circuitlist.c	/^circuit_get_by_edge_conn(edge_connection_t *conn)$/;"	f
circuit_get_by_global_id	or/circuitlist.c	/^circuit_get_by_global_id(uint32_t id)$/;"	f
circuit_get_by_rend_token_and_purpose	or/circuitlist.c	/^circuit_get_by_rend_token_and_purpose(uint8_t purpose, const char *token,$/;"	f	file:
circuit_get_cpath_hop	or/circuitlist.c	/^circuit_get_cpath_hop(origin_circuit_t *circ, int hopnum)$/;"	f
circuit_get_cpath_len	or/circuitlist.c	/^circuit_get_cpath_len(origin_circuit_t *circ)$/;"	f
circuit_get_intro_point	or/circuitlist.c	/^circuit_get_intro_point(const char *digest)$/;"	f
circuit_get_next_by_pk_and_purpose	or/circuitlist.c	/^circuit_get_next_by_pk_and_purpose(origin_circuit_t *start,$/;"	f
circuit_get_open_circ_or_launch	or/circuituse.c	/^circuit_get_open_circ_or_launch(entry_connection_t *conn,$/;"	f	file:
circuit_get_ready_rend_circ_by_rend_data	or/circuitlist.c	/^circuit_get_ready_rend_circ_by_rend_data(const rend_data_t *rend_data)$/;"	f
circuit_get_rendezvous	or/circuitlist.c	/^circuit_get_rendezvous(const char *cookie)$/;"	f
circuit_get_unhandled_ports	or/circuitbuild.c	/^circuit_get_unhandled_ports(time_t now)$/;"	f	file:
circuit_handle_first_hop	or/circuitbuild.c	/^circuit_handle_first_hop(origin_circuit_t *circ)$/;"	f
circuit_has_opened	or/circuituse.c	/^circuit_has_opened(origin_circuit_t *circ)$/;"	f
circuit_id_in_use_on_orconn	or/circuitlist.c	/^circuit_id_in_use_on_orconn(circid_t circ_id, or_connection_t *conn)$/;"	f
circuit_increment_failure_count	or/circuituse.c	/^circuit_increment_failure_count(void)$/;"	f	file:
circuit_init_cpath_crypto	or/circuitbuild.c	/^circuit_init_cpath_crypto(crypt_path_t *cpath, const char *key_data,$/;"	f
circuit_initial_package_window	or/circuitlist.c	/^circuit_initial_package_window(void)$/;"	f
circuit_is_acceptable	or/circuituse.c	/^circuit_is_acceptable(const origin_circuit_t *origin_circ,$/;"	f	file:
circuit_is_better	or/circuituse.c	/^circuit_is_better(const origin_circuit_t *oa, const origin_circuit_t *ob,$/;"	f	file:
circuit_launch	or/circuituse.c	/^circuit_launch(uint8_t purpose, int flags)$/;"	f
circuit_launch_by_extend_info	or/circuituse.c	/^circuit_launch_by_extend_info(uint8_t purpose,$/;"	f
circuit_list_path	or/circuitbuild.c	/^circuit_list_path(origin_circuit_t *circ, int verbose)$/;"	f
circuit_list_path_for_controller	or/circuitbuild.c	/^circuit_list_path_for_controller(origin_circuit_t *circ)$/;"	f
circuit_list_path_impl	or/circuitbuild.c	/^circuit_list_path_impl(origin_circuit_t *circ, int verbose, int verbose_names)$/;"	f	file:
circuit_log_path	or/circuitbuild.c	/^circuit_log_path(int severity, unsigned int domain, origin_circuit_t *circ)$/;"	f
circuit_mark_all_unused_circs	or/circuitlist.c	/^circuit_mark_all_unused_circs(void)$/;"	f
circuit_mark_for_close	or/circuitlist.h	/^#define circuit_mark_for_close(/;"	d
circuit_n_conn_done	or/circuitbuild.c	/^circuit_n_conn_done(or_connection_t *or_conn, int status)$/;"	f
circuit_note_clock_jumped	or/circuitbuild.c	/^circuit_note_clock_jumped(int seconds_elapsed)$/;"	f
circuit_package_relay_cell	or/relay.c	/^circuit_package_relay_cell(cell_t *cell, circuit_t *circ,$/;"	f	file:
circuit_predict_and_launch_new	or/circuituse.c	/^circuit_predict_and_launch_new(void)$/;"	f	file:
circuit_purpose_from_string	or/control.c	/^circuit_purpose_from_string(const char *string)$/;"	f	file:
circuit_purpose_to_controller_hs_state_string	or/circuitlist.c	/^circuit_purpose_to_controller_hs_state_string(uint8_t purpose)$/;"	f
circuit_purpose_to_controller_string	or/circuitlist.c	/^circuit_purpose_to_controller_string(uint8_t purpose)$/;"	f
circuit_purpose_to_string	or/circuitlist.c	/^circuit_purpose_to_string(uint8_t purpose)$/;"	f
circuit_queue_streams_are_blocked	or/relay.c	/^circuit_queue_streams_are_blocked(circuit_t *circ)$/;"	f	file:
circuit_receive_relay_cell	or/relay.c	/^circuit_receive_relay_cell(cell_t *cell, circuit_t *circ,$/;"	f
circuit_remove_handled_ports	or/circuituse.c	/^circuit_remove_handled_ports(smartlist_t *needed_ports)$/;"	f
circuit_rep_hist_note_result	or/circuitbuild.c	/^circuit_rep_hist_note_result(origin_circuit_t *circ)$/;"	f
circuit_reset_failure_count	or/circuituse.c	/^circuit_reset_failure_count(int timeout)$/;"	f
circuit_resume_edge_reading	or/relay.c	/^circuit_resume_edge_reading(circuit_t *circ, crypt_path_t *layer_hint)$/;"	f	file:
circuit_resume_edge_reading_helper	or/relay.c	/^circuit_resume_edge_reading_helper(edge_connection_t *first_conn,$/;"	f	file:
circuit_send_next_onion_skin	or/circuitbuild.c	/^circuit_send_next_onion_skin(origin_circuit_t *circ)$/;"	f
circuit_set_circid_orconn_helper	or/circuitlist.c	/^circuit_set_circid_orconn_helper(circuit_t *circ, int direction,$/;"	f	file:
circuit_set_n_circid_orconn	or/circuitlist.c	/^circuit_set_n_circid_orconn(circuit_t *circ, circid_t id,$/;"	f
circuit_set_p_circid_orconn	or/circuitlist.c	/^circuit_set_p_circid_orconn(or_circuit_t *circ, circid_t id,$/;"	f
circuit_set_state	or/circuitlist.c	/^circuit_set_state(circuit_t *circ, uint8_t state)$/;"	f
circuit_state_to_string	or/circuitlist.c	/^circuit_state_to_string(int state)$/;"	f
circuit_status_event_t	or/or.h	/^typedef enum circuit_status_event_t {$/;"	g
circuit_status_event_t	or/or.h	/^} circuit_status_event_t;$/;"	t	typeref:enum:circuit_status_event_t
circuit_status_minor_event_t	or/or.h	/^typedef enum circuit_status_minor_event_t {$/;"	g
circuit_status_minor_event_t	or/or.h	/^} circuit_status_minor_event_t;$/;"	t	typeref:enum:circuit_status_minor_event_t
circuit_stream_is_being_handled	or/circuituse.c	/^circuit_stream_is_being_handled(entry_connection_t *conn,$/;"	f
circuit_t	or/or.h	/^typedef struct circuit_t {$/;"	s
circuit_t	or/or.h	/^} circuit_t;$/;"	t	typeref:struct:circuit_t
circuit_testing_failed	or/circuituse.c	/^circuit_testing_failed(origin_circuit_t *circ, int at_last_hop)$/;"	f	file:
circuit_testing_opened	or/circuituse.c	/^circuit_testing_opened(origin_circuit_t *circ)$/;"	f	file:
circuit_timeout_want_to_count_circ	or/circuitbuild.c	/^circuit_timeout_want_to_count_circ(origin_circuit_t *circ)$/;"	f
circuit_truncated	or/circuitbuild.c	/^circuit_truncated(origin_circuit_t *circ, crypt_path_t *layer)$/;"	f
circuit_try_attaching_streams	or/circuituse.c	/^circuit_try_attaching_streams(origin_circuit_t *circ)$/;"	f
circuit_try_clearing_isolation_state	or/circuituse.c	/^circuit_try_clearing_isolation_state(origin_circuit_t *circ)$/;"	f	file:
circuit_unlink_all_from_or_conn	or/circuitlist.c	/^circuit_unlink_all_from_or_conn(or_connection_t *conn, int reason)$/;"	f
circuitbuild_running_unit_tests	or/circuitbuild.c	/^circuitbuild_running_unit_tests(void)$/;"	f
circuits_for_buffer_stats	or/rephist.c	/^static smartlist_t *circuits_for_buffer_stats = NULL;$/;"	v	file:
circuits_pending_or_conns	or/circuitlist.c	/^static smartlist_t *circuits_pending_or_conns=NULL;$/;"	v	file:
class	or/eventdns.c	/^	u16 class : 16; \/* The RR class (usually CLASS_INET) *\/$/;"	m	struct:server_reply_item	file:
clean_accepted_intro_dh_parts	or/rendservice.c	/^clean_accepted_intro_dh_parts(rend_service_t *service, time_t now)$/;"	f	file:
clean_cell_pool	or/relay.c	/^clean_cell_pool(void)$/;"	f
clean_data_buffer	test/tinytest_demo.c	/^clean_data_buffer(const struct testcase_t *testcase, void *ptr)$/;"	f
clean_name_for_stat	common/util.c	/^clean_name_for_stat(char *name)$/;"	f	file:
cleanup	tools/tor-fw-helper/tor-fw-helper.h	/^  int (*cleanup)(tor_fw_options_t *options, void *backend_state);$/;"	m	struct:tor_fw_backend_t
cleanup_fn	test/tinytest.h	/^	int (*cleanup_fn)(const struct testcase_t *, void *);$/;"	m	struct:testcase_setup_t
clear_bridge_list	or/circuitbuild.c	/^clear_bridge_list(void)$/;"	f	file:
clear_broken_connection_map	or/connection_or.c	/^clear_broken_connection_map(int stop_recording)$/;"	f
clear_cached_dir	or/dirserv.c	/^clear_cached_dir(cached_dir_t *d)$/;"	f	file:
clear_geoip_db	or/geoip.c	/^clear_geoip_db(void)$/;"	f	file:
clear_hex_errno	test/test_util.c	/^clear_hex_errno(char *hex_errno)$/;"	f	file:
clear_passphrase	tools/tor-gencert.c	/^clear_passphrase(void)$/;"	f	file:
clear_pending_onions	or/onion.c	/^clear_pending_onions(void)$/;"	f
clear_status_flags_on_sybil	or/dirserv.c	/^clear_status_flags_on_sybil(routerstatus_t *rs)$/;"	f	file:
clear_trackexithost_mappings	or/connection_edge.c	/^clear_trackexithost_mappings(const char *exitname)$/;"	f	file:
clear_transport_list	or/circuitbuild.c	/^clear_transport_list(void)$/;"	f
clear_trusted_dir_servers	or/routerlist.c	/^clear_trusted_dir_servers(void)$/;"	f
client_addr	or/or.h	/^  tor_addr_t client_addr;$/;"	m	struct:origin_circuit_t
client_check_address_changed	or/connection.c	/^client_check_address_changed(tor_socket_t sock)$/;"	f	file:
client_consensus_dl_schedule	or/directory.c	/^static const int client_consensus_dl_schedule[] = {$/;"	v	file:
client_dl_schedule	or/directory.c	/^static const int client_dl_schedule[] = {$/;"	v	file:
client_dns_clear_failures	or/connection_edge.c	/^client_dns_clear_failures(const char *address)$/;"	f
client_dns_incr_failures	or/connection_edge.c	/^client_dns_incr_failures(const char *address)$/;"	f
client_dns_set_addressmap	or/connection_edge.c	/^client_dns_set_addressmap(const char *address, uint32_t val,$/;"	f
client_dns_set_addressmap_impl	or/connection_edge.c	/^client_dns_set_addressmap_impl(const char *address, const char *name,$/;"	f	file:
client_dns_set_reverse_addressmap	or/connection_edge.c	/^client_dns_set_reverse_addressmap(const char *address, const char *v,$/;"	f	file:
client_history_clear	or/geoip.c	/^client_history_clear(void)$/;"	f	file:
client_identity_key_is_set	or/router.c	/^client_identity_key_is_set(void)$/;"	f
client_identitykey	or/router.c	/^static crypto_pk_t *client_identitykey=NULL;$/;"	v	file:
client_key	or/or.h	/^  crypto_pk_t *client_key;$/;"	m	struct:rend_authorized_client_t
client_keys_token_table	or/routerparse.c	/^static token_rule_t client_keys_token_table[] = {$/;"	v	file:
client_likes_consensus	or/directory.c	/^client_likes_consensus(networkstatus_t *v, const char *want_url)$/;"	f
client_name	or/or.h	/^  char *client_name;$/;"	m	struct:rend_authorized_client_t
client_proto_socksver	or/or.h	/^  uint8_t client_proto_socksver;$/;"	m	struct:origin_circuit_t
client_proto_type	or/or.h	/^  uint8_t client_proto_type;$/;"	m	struct:origin_circuit_t
client_tls_context	common/tortls.c	/^static tor_tls_context_t *client_tls_context = NULL;$/;"	v	file:
client_used	or/or.h	/^  time_t client_used;$/;"	m	struct:or_connection_t
client_versions	or/or.h	/^  char *client_versions; \/**< comma-separated list of recommended client$/;"	m	struct:networkstatus_v2_t
client_versions	or/or.h	/^  char *client_versions;$/;"	m	struct:networkstatus_t
client_would_use_router	or/routerlist.c	/^client_would_use_router(const routerstatus_t *rs, time_t now,$/;"	f	file:
clientmap_entries_eq	or/geoip.c	/^clientmap_entries_eq(const clientmap_entry_t *a, const clientmap_entry_t *b)$/;"	f	file:
clientmap_entry_hash	or/geoip.c	/^clientmap_entry_hash(const clientmap_entry_t *a)$/;"	f	file:
clientmap_entry_t	or/geoip.c	/^typedef struct clientmap_entry_t {$/;"	s	file:
clientmap_entry_t	or/geoip.c	/^} clientmap_entry_t;$/;"	t	typeref:struct:clientmap_entry_t	file:
clients	or/rendservice.c	/^  smartlist_t *clients; \/**< List of rend_authorized_client_t's of$/;"	m	struct:rend_service_t	file:
close_closeable_connections	or/main.c	/^close_closeable_connections(void)$/;"	f	file:
close_log	common/log.c	/^close_log(logfile_t *victim)$/;"	f	file:
close_ms	or/or.h	/^  double close_ms;$/;"	m	struct:__anon54
close_temp_logs	common/log.c	/^close_temp_logs(void)$/;"	f
closeable_connection_lst	or/main.c	/^static smartlist_t *closeable_connection_lst = NULL;$/;"	v	file:
closing	or/eventdns.c	/^	char closing; \/* Are we trying to close this port, pending writes? *\/$/;"	m	struct:evdns_server_port	file:
cmp_addr_policies	or/policies.c	/^cmp_addr_policies(smartlist_t *a, smartlist_t *b)$/;"	f
cmp_single_addr_policy	or/policies.c	/^cmp_single_addr_policy(addr_policy_t *a, addr_policy_t *b)$/;"	f	file:
code	common/compat.c	/^struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon5	file:
command	or/or.h	/^  uint8_t command; \/**< The end-to-end relay command. *\/$/;"	m	struct:__anon36
command	or/or.h	/^  uint8_t command; \/**< Type of the cell: one of CELL_PADDING, CELL_CREATE,$/;"	m	struct:cell_t
command	or/or.h	/^  uint8_t command;$/;"	m	struct:socks_request_t
command	or/or.h	/^  uint8_t command;$/;"	m	struct:var_cell_t
command	or/or.h	/^  unsigned int command:2;$/;"	m	struct:config_line_t
command	or/or.h	/^  } command;$/;"	m	struct:__anon49	typeref:enum:__anon49::__anon50
command_allowed_before_handshake	or/command.c	/^command_allowed_before_handshake(uint8_t command)$/;"	f	file:
command_arg	or/or.h	/^  const char *command_arg; \/**< Argument for command-line option. *\/$/;"	m	struct:__anon49
command_process_auth_challenge_cell	or/command.c	/^command_process_auth_challenge_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_authenticate_cell	or/command.c	/^command_process_authenticate_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_cell	or/command.c	/^command_process_cell(cell_t *cell, or_connection_t *conn)$/;"	f
command_process_certs_cell	or/command.c	/^command_process_certs_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_create_cell	or/command.c	/^command_process_create_cell(cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_created_cell	or/command.c	/^command_process_created_cell(cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_destroy_cell	or/command.c	/^command_process_destroy_cell(cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_netinfo_cell	or/command.c	/^command_process_netinfo_cell(cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_relay_cell	or/command.c	/^command_process_relay_cell(cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_process_var_cell	or/command.c	/^command_process_var_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f
command_process_versions_cell	or/command.c	/^command_process_versions_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f	file:
command_time_process_cell	or/command.c	/^command_time_process_cell(cell_t *cell, or_connection_t *conn, int *time,$/;"	f	file:
commandline_only	or/config.c	/^  int commandline_only;$/;"	m	struct:config_abbrev_t	file:
commandname	test/tinytest.c	/^static char commandname[MAX_PATH+1];$/;"	v	file:
commit_max	or/rephist.c	/^commit_max(bw_array_t *b)$/;"	f	file:
compare_cell_ewma_counts	or/relay.c	/^compare_cell_ewma_counts(const void *p1, const void *p2)$/;"	f	file:
compare_digest_to_routerstatus_entry	or/networkstatus.c	/^compare_digest_to_routerstatus_entry(const void *_key, const void **_member)$/;"	f
compare_known_tor_addr_to_addr_policy	or/policies.c	/^compare_known_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,$/;"	f	file:
compare_known_tor_addr_to_addr_policy_noport	or/policies.c	/^compare_known_tor_addr_to_addr_policy_noport(const tor_addr_t *addr,$/;"	f	file:
compare_routerstatus_entries	or/routerparse.c	/^compare_routerstatus_entries(const void **_a, const void **_b)$/;"	f
compare_tor_addr_to_addr_policy	or/policies.c	/^compare_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,$/;"	f
compare_tor_addr_to_node_policy	or/policies.c	/^compare_tor_addr_to_node_policy(const tor_addr_t *addr, uint16_t port,$/;"	f
compare_tor_addr_to_short_policy	or/policies.c	/^compare_tor_addr_to_short_policy(const tor_addr_t *addr, uint16_t port,$/;"	f
compare_unknown_tor_addr_to_addr_policy	or/policies.c	/^compare_unknown_tor_addr_to_addr_policy(uint16_t port,$/;"	f	file:
compare_vote_rs	or/dirvote.c	/^compare_vote_rs(const vote_routerstatus_t *a, const vote_routerstatus_t *b)$/;"	f	file:
completed	or/geoip.c	/^  unsigned int completed:1; \/**< Is this request complete? *\/$/;"	m	struct:dirreq_map_entry_t	file:
completion_time	or/geoip.c	/^  struct timeval completion_time; \/**< When did the request succeed? *\/$/;"	m	struct:dirreq_map_entry_t	typeref:struct:dirreq_map_entry_t::timeval	file:
compress	common/torgzip.c	/^  int compress; \/**< True if we are compressing; false if we are inflating *\/$/;"	m	struct:tor_zlib_state_t	file:
compress_method_t	common/torgzip.h	/^} compress_method_t;$/;"	t	typeref:enum:__anon14
compute_consensus_method	or/dirvote.c	/^compute_consensus_method(smartlist_t *votes)$/;"	f	file:
compute_consensus_versions_list	or/dirvote.c	/^compute_consensus_versions_list(smartlist_t *lst, int n_versioning)$/;"	f	file:
compute_num_cpus	common/compat.c	/^compute_num_cpus(void)$/;"	f
compute_num_cpus_impl	common/compat.c	/^compute_num_cpus_impl(void)$/;"	f	file:
compute_publishserverdescriptor	or/config.c	/^compute_publishserverdescriptor(or_options_t *options)$/;"	f	file:
compute_retry_timeout	or/connection_edge.c	/^compute_retry_timeout(entry_connection_t *conn)$/;"	f	file:
compute_routerstatus_consensus	or/dirvote.c	/^compute_routerstatus_consensus(smartlist_t *votes, int consensus_method,$/;"	f	file:
concat_args	or/routerparse.c	/^  int concat_args;$/;"	m	struct:token_rule_t	file:
conf_protocol	or/transports.h	/^  int conf_protocol; \/* the configuration protocol version used *\/$/;"	m	struct:__anon71
conf_state	or/transports.h	/^  enum pt_proto_state conf_state; \/* the current configuration state *\/$/;"	m	struct:__anon71	typeref:enum:__anon71::pt_proto_state
config_abbrev_t	or/config.c	/^typedef struct config_abbrev_t {$/;"	s	file:
config_abbrev_t	or/config.c	/^} config_abbrev_t;$/;"	t	typeref:struct:config_abbrev_t	file:
config_alloc	or/config.c	/^config_alloc(const config_format_t *fmt)$/;"	f	file:
config_assign	or/config.c	/^config_assign(const config_format_t *fmt, void *options, config_line_t *list,$/;"	f	file:
config_assign_line	or/config.c	/^config_assign_line(const config_format_t *fmt, or_options_t *options,$/;"	f	file:
config_assign_value	or/config.c	/^config_assign_value(const config_format_t *fmt, or_options_t *options,$/;"	f	file:
config_count_options	or/config.c	/^config_count_options(const config_format_t *fmt)$/;"	f	file:
config_dump	or/config.c	/^config_dump(const config_format_t *fmt, const void *default_options,$/;"	f	file:
config_find_option	or/config.c	/^config_find_option(const config_format_t *fmt, const char *key)$/;"	f	file:
config_find_option_mutable	or/config.c	/^config_find_option_mutable(config_format_t *fmt, const char *key)$/;"	f	file:
config_format_t	or/config.c	/^} config_format_t;$/;"	t	typeref:struct:__anon21	file:
config_free	or/config.c	/^config_free(const config_format_t *fmt, void *options)$/;"	f	file:
config_free_all	or/config.c	/^config_free_all(void)$/;"	f
config_free_lines	or/config.c	/^config_free_lines(config_line_t *front)$/;"	f
config_get_commandlines	or/config.c	/^config_get_commandlines(int argc, char **argv, config_line_t **result)$/;"	f	file:
config_get_lines	or/config.c	/^config_get_lines(const char *string, config_line_t **result, int extended)$/;"	f
config_init	or/config.c	/^config_init(const config_format_t *fmt, void *options)$/;"	f	file:
config_line_append	or/config.c	/^config_line_append(config_line_t **lst,$/;"	f	file:
config_line_t	or/or.h	/^typedef struct config_line_t {$/;"	s
config_line_t	or/or.h	/^} config_line_t;$/;"	t	typeref:struct:config_line_t
config_lines_dup	or/config.c	/^config_lines_dup(const config_line_t *inp)$/;"	f	file:
config_lines_eq	or/config.c	/^config_lines_eq(config_line_t *a, config_line_t *b)$/;"	f	file:
config_mark_lists_fragile	or/config.c	/^config_mark_lists_fragile(const config_format_t *fmt, or_options_t *options)$/;"	f	file:
config_nameserver_from_reg_key	or/eventdns.c	/^config_nameserver_from_reg_key(HKEY key, const TCHAR *subkey)$/;"	f	file:
config_parse_interval	or/config.c	/^config_parse_interval(const char *s, int *ok)$/;"	f	file:
config_parse_memunit	or/config.c	/^config_parse_memunit(const char *s, int *ok)$/;"	f	file:
config_parse_msec_interval	or/config.c	/^config_parse_msec_interval(const char *s, int *ok)$/;"	f	file:
config_parse_units	or/config.c	/^config_parse_units(const char *val, struct unit_table_t *u, int *ok)$/;"	f	file:
config_register_addressmaps	or/config.c	/^config_register_addressmaps(const or_options_t *options)$/;"	f
config_reset_line	or/config.c	/^config_reset_line(const config_format_t *fmt, or_options_t *options,$/;"	f	file:
config_tests	test/test_config.c	/^struct testcase_t config_tests[] = {$/;"	v	typeref:struct:testcase_t
config_type_t	or/config.c	/^typedef enum config_type_t {$/;"	g	file:
config_type_t	or/config.c	/^} config_type_t;$/;"	t	typeref:enum:config_type_t	file:
config_value_needs_escape	or/config.c	/^config_value_needs_escape(const char *value)$/;"	f	file:
config_var_description_t	or/config.c	/^typedef struct config_var_description_t {$/;"	s	file:
config_var_description_t	or/config.c	/^} config_var_description_t;$/;"	t	typeref:struct:config_var_description_t	file:
config_var_t	or/config.c	/^typedef struct config_var_t {$/;"	s	file:
config_var_t	or/config.c	/^} config_var_t;$/;"	t	typeref:struct:config_var_t	file:
configure_accounting	or/hibernate.c	/^configure_accounting(time_t now)$/;"	f
configure_libevent_logging	common/compat_libevent.c	/^configure_libevent_logging(void)$/;"	f
configure_nameservers	or/dns.c	/^configure_nameservers(int force)$/;"	f	file:
configure_proxy	or/transports.c	/^configure_proxy(managed_proxy_t *mp)$/;"	f	file:
configured_ports	or/config.c	/^static smartlist_t *configured_ports = NULL;$/;"	v	file:
conn	or/dns.c	/^  edge_connection_t *conn;$/;"	m	struct:pending_connection_t	file:
conn_array_index	or/or.h	/^  int conn_array_index; \/**< Index into the global connection array. *\/$/;"	m	struct:connection_t
conn_close_if_marked	or/main.c	/^conn_close_if_marked(int i)$/;"	f	file:
conn_id	or/rephist.c	/^  uint64_t conn_id; \/**< Connection ID *\/$/;"	m	struct:bidi_map_entry_t	file:
conn_read_callback	or/main.c	/^conn_read_callback(evutil_socket_t fd, short event, void *_conn)$/;"	f	file:
conn_state_to_string	or/connection.c	/^conn_state_to_string(int type, int state)$/;"	f
conn_type_to_string	or/connection.c	/^conn_type_to_string(int type)$/;"	f
conn_write_callback	or/main.c	/^conn_write_callback(evutil_socket_t fd, short events, void *_conn)$/;"	f	file:
connection_about_to_close_connection	or/connection.c	/^connection_about_to_close_connection(connection_t *conn)$/;"	f
connection_add	or/main.h	/^#define connection_add(/;"	d
connection_add_connecting	or/main.h	/^#define connection_add_connecting(/;"	d
connection_add_impl	or/main.c	/^connection_add_impl(connection_t *conn, int is_connecting)$/;"	f
connection_ap_about_to_close	or/connection_edge.c	/^connection_ap_about_to_close(entry_connection_t *entry_conn)$/;"	f
connection_ap_attach_pending	or/connection_edge.c	/^connection_ap_attach_pending(void)$/;"	f
connection_ap_can_use_exit	or/connection_edge.c	/^connection_ap_can_use_exit(const entry_connection_t *conn, const node_t *exit)$/;"	f
connection_ap_detach_retriable	or/connection_edge.c	/^connection_ap_detach_retriable(entry_connection_t *conn,$/;"	f
connection_ap_expire_beginning	or/connection_edge.c	/^connection_ap_expire_beginning(void)$/;"	f
connection_ap_fail_onehop	or/connection_edge.c	/^connection_ap_fail_onehop(const char *failed_digest,$/;"	f
connection_ap_get_original_destination	or/connection_edge.c	/^connection_ap_get_original_destination(entry_connection_t *conn,$/;"	f	file:
connection_ap_handshake_attach_chosen_circuit	or/circuituse.c	/^connection_ap_handshake_attach_chosen_circuit(entry_connection_t *conn,$/;"	f
connection_ap_handshake_attach_circuit	or/circuituse.c	/^connection_ap_handshake_attach_circuit(entry_connection_t *conn)$/;"	f
connection_ap_handshake_process_socks	or/connection_edge.c	/^connection_ap_handshake_process_socks(entry_connection_t *conn)$/;"	f	file:
connection_ap_handshake_rewrite_and_attach	or/connection_edge.c	/^connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn,$/;"	f
connection_ap_handshake_send_begin	or/connection_edge.c	/^connection_ap_handshake_send_begin(entry_connection_t *ap_conn)$/;"	f
connection_ap_handshake_send_resolve	or/connection_edge.c	/^connection_ap_handshake_send_resolve(entry_connection_t *ap_conn)$/;"	f
connection_ap_handshake_socks_reply	or/connection_edge.c	/^connection_ap_handshake_socks_reply(entry_connection_t *conn, char *reply,$/;"	f
connection_ap_handshake_socks_resolved	or/connection_edge.c	/^connection_ap_handshake_socks_resolved(entry_connection_t *conn,$/;"	f
connection_ap_make_link	or/connection_edge.c	/^connection_ap_make_link(connection_t *partner,$/;"	f
connection_ap_process_end_not_open	or/relay.c	/^connection_ap_process_end_not_open($/;"	f	file:
connection_ap_process_natd	or/connection_edge.c	/^connection_ap_process_natd(entry_connection_t *conn)$/;"	f	file:
connection_ap_process_transparent	or/connection_edge.c	/^connection_ap_process_transparent(entry_connection_t *conn)$/;"	f
connection_ap_rewrite_and_attach_if_allowed	or/connection_edge.c	/^connection_ap_rewrite_and_attach_if_allowed(entry_connection_t *conn,$/;"	f
connection_ap_supports_optimistic_data	or/connection_edge.c	/^connection_ap_supports_optimistic_data(const entry_connection_t *conn)$/;"	f	file:
connection_array	or/main.c	/^static smartlist_t *connection_array = NULL;$/;"	v	file:
connection_bucket_init	or/connection.c	/^connection_bucket_init(void)$/;"	f
connection_bucket_read_limit	or/connection.c	/^connection_bucket_read_limit(connection_t *conn, time_t now)$/;"	f	file:
connection_bucket_refill	or/connection.c	/^connection_bucket_refill(int milliseconds_elapsed, time_t now)$/;"	f
connection_bucket_refill	or/connection.c	/^connection_bucket_refill(int seconds_elapsed, time_t now)$/;"	f
connection_bucket_refill_helper	or/connection.c	/^connection_bucket_refill_helper(int *bucket, int rate, int burst,$/;"	f	file:
connection_bucket_round_robin	or/connection.c	/^connection_bucket_round_robin(int base, int priority,$/;"	f	file:
connection_bucket_should_increase	or/connection.c	/^connection_bucket_should_increase(int bucket, or_connection_t *conn)$/;"	f	file:
connection_bucket_write_limit	or/connection.c	/^connection_bucket_write_limit(connection_t *conn, time_t now)$/;"	f
connection_buckets_decrement	or/connection.c	/^connection_buckets_decrement(connection_t *conn, time_t now,$/;"	f	file:
connection_close_immediate	or/connection.c	/^connection_close_immediate(connection_t *conn)$/;"	f
connection_configure_bufferevent_callbacks	or/connection.c	/^connection_configure_bufferevent_callbacks(connection_t *conn)$/;"	f
connection_connect	or/connection.c	/^connection_connect(connection_t *conn, const char *address,$/;"	f
connection_consider_empty_read_buckets	or/connection.c	/^connection_consider_empty_read_buckets(connection_t *conn)$/;"	f	file:
connection_consider_empty_write_buckets	or/connection.c	/^connection_consider_empty_write_buckets(connection_t *conn)$/;"	f	file:
connection_control_closed	or/control.c	/^connection_control_closed(control_connection_t *conn)$/;"	f
connection_control_finished_flushing	or/control.c	/^connection_control_finished_flushing(control_connection_t *conn)$/;"	f
connection_control_process_inbuf	or/control.c	/^connection_control_process_inbuf(control_connection_t *conn)$/;"	f
connection_control_reached_eof	or/control.c	/^connection_control_reached_eof(control_connection_t *conn)$/;"	f
connection_counts_as_relayed_traffic	or/connection.c	/^connection_counts_as_relayed_traffic(connection_t *conn, time_t now)$/;"	f	file:
connection_cpu_finished_flushing	or/cpuworker.c	/^connection_cpu_finished_flushing(connection_t *conn)$/;"	f
connection_cpu_process_inbuf	or/cpuworker.c	/^connection_cpu_process_inbuf(connection_t *conn)$/;"	f
connection_cpu_reached_eof	or/cpuworker.c	/^connection_cpu_reached_eof(connection_t *conn)$/;"	f
connection_dir_about_to_close	or/directory.c	/^connection_dir_about_to_close(dir_connection_t *dir_conn)$/;"	f
connection_dir_bridge_routerdesc_failed	or/directory.c	/^connection_dir_bridge_routerdesc_failed(dir_connection_t *conn)$/;"	f	file:
connection_dir_client_reached_eof	or/directory.c	/^connection_dir_client_reached_eof(dir_connection_t *conn)$/;"	f	file:
connection_dir_download_cert_failed	or/directory.c	/^connection_dir_download_cert_failed(dir_connection_t *conn, int status)$/;"	f	file:
connection_dir_download_routerdesc_failed	or/directory.c	/^connection_dir_download_routerdesc_failed(dir_connection_t *conn)$/;"	f	file:
connection_dir_download_v2_networkstatus_failed	or/directory.c	/^connection_dir_download_v2_networkstatus_failed(dir_connection_t *conn,$/;"	f	file:
connection_dir_finished_connecting	or/directory.c	/^connection_dir_finished_connecting(dir_connection_t *conn)$/;"	f
connection_dir_finished_flushing	or/directory.c	/^connection_dir_finished_flushing(dir_connection_t *conn)$/;"	f
connection_dir_get_by_purpose_and_resource	or/connection.c	/^connection_dir_get_by_purpose_and_resource(int purpose,$/;"	f
connection_dir_is_encrypted	or/directory.c	/^connection_dir_is_encrypted(dir_connection_t *conn)$/;"	f
connection_dir_process_inbuf	or/directory.c	/^connection_dir_process_inbuf(dir_connection_t *conn)$/;"	f
connection_dir_reached_eof	or/directory.c	/^connection_dir_reached_eof(dir_connection_t *conn)$/;"	f
connection_dir_request_failed	or/directory.c	/^connection_dir_request_failed(dir_connection_t *conn)$/;"	f	file:
connection_dir_retry_bridges	or/directory.c	/^connection_dir_retry_bridges(smartlist_t *descs)$/;"	f	file:
connection_dirserv_add_dir_bytes_to_outbuf	or/dirserv.c	/^connection_dirserv_add_dir_bytes_to_outbuf(dir_connection_t *conn)$/;"	f	file:
connection_dirserv_add_microdescs_to_outbuf	or/dirserv.c	/^connection_dirserv_add_microdescs_to_outbuf(dir_connection_t *conn)$/;"	f	file:
connection_dirserv_add_networkstatus_bytes_to_outbuf	or/dirserv.c	/^connection_dirserv_add_networkstatus_bytes_to_outbuf(dir_connection_t *conn)$/;"	f	file:
connection_dirserv_add_servers_to_outbuf	or/dirserv.c	/^connection_dirserv_add_servers_to_outbuf(dir_connection_t *conn)$/;"	f	file:
connection_dirserv_finish_spooling	or/dirserv.c	/^connection_dirserv_finish_spooling(dir_connection_t *conn)$/;"	f	file:
connection_dirserv_flushed_some	or/dirserv.c	/^connection_dirserv_flushed_some(dir_connection_t *conn)$/;"	f
connection_dns_remove	or/dns.c	/^connection_dns_remove(edge_connection_t *conn)$/;"	f
connection_dump_buffer_mem_stats	or/connection.c	/^connection_dump_buffer_mem_stats(int severity)$/;"	f
connection_edge_about_to_close	or/connection_edge.c	/^connection_edge_about_to_close(edge_connection_t *edge_conn)$/;"	f	file:
connection_edge_compatible_with_circuit	or/connection_edge.c	/^connection_edge_compatible_with_circuit(const entry_connection_t *conn,$/;"	f
connection_edge_consider_sending_sendme	or/relay.c	/^connection_edge_consider_sending_sendme(edge_connection_t *conn)$/;"	f
connection_edge_destroy	or/connection_edge.c	/^connection_edge_destroy(circid_t circ_id, edge_connection_t *conn)$/;"	f
connection_edge_end	or/connection_edge.c	/^connection_edge_end(edge_connection_t *conn, uint8_t reason)$/;"	f
connection_edge_end_errno	or/connection_edge.c	/^connection_edge_end_errno(edge_connection_t *conn)$/;"	f
connection_edge_finished_connecting	or/connection_edge.c	/^connection_edge_finished_connecting(edge_connection_t *edge_conn)$/;"	f
connection_edge_finished_flushing	or/connection_edge.c	/^connection_edge_finished_flushing(edge_connection_t *conn)$/;"	f
connection_edge_flushed_some	or/connection_edge.c	/^connection_edge_flushed_some(edge_connection_t *conn)$/;"	f
connection_edge_is_rendezvous_stream	or/connection_edge.c	/^connection_edge_is_rendezvous_stream(edge_connection_t *conn)$/;"	f
connection_edge_package_raw_inbuf	or/relay.c	/^connection_edge_package_raw_inbuf(edge_connection_t *conn, int package_partial,$/;"	f
connection_edge_process_inbuf	or/connection_edge.c	/^connection_edge_process_inbuf(edge_connection_t *conn, int package_partial)$/;"	f
connection_edge_process_relay_cell	or/relay.c	/^connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,$/;"	f	file:
connection_edge_process_relay_cell_not_open	or/relay.c	/^connection_edge_process_relay_cell_not_open($/;"	f	file:
connection_edge_reached_eof	or/connection_edge.c	/^connection_edge_reached_eof(edge_connection_t *conn)$/;"	f
connection_edge_send_command	or/relay.c	/^connection_edge_send_command(edge_connection_t *fromconn,$/;"	f
connection_edge_update_circuit_isolation	or/connection_edge.c	/^connection_edge_update_circuit_isolation(const entry_connection_t *conn,$/;"	f
connection_enable_rate_limiting	or/connection.c	/^connection_enable_rate_limiting(connection_t *conn)$/;"	f
connection_exit_about_to_close	or/connection_edge.c	/^connection_exit_about_to_close(edge_connection_t *edge_conn)$/;"	f
connection_exit_begin_conn	or/connection_edge.c	/^connection_exit_begin_conn(cell_t *cell, circuit_t *circ)$/;"	f
connection_exit_begin_resolve	or/connection_edge.c	/^connection_exit_begin_resolve(cell_t *cell, or_circuit_t *circ)$/;"	f
connection_exit_connect	or/connection_edge.c	/^connection_exit_connect(edge_connection_t *edge_conn)$/;"	f
connection_exit_connect_dir	or/connection_edge.c	/^connection_exit_connect_dir(edge_connection_t *exitconn)$/;"	f	file:
connection_expire_held_open	or/connection.c	/^connection_expire_held_open(void)$/;"	f
connection_fetch_from_buf	or/connection.c	/^connection_fetch_from_buf(char *string, size_t len, connection_t *conn)$/;"	f
connection_fetch_from_buf_http	or/connection.c	/^connection_fetch_from_buf_http(connection_t *conn,$/;"	f
connection_fetch_from_buf_line	or/connection.c	/^connection_fetch_from_buf_line(connection_t *conn, char *data,$/;"	f
connection_fetch_from_buf_socks_client	or/connection.c	/^connection_fetch_from_buf_socks_client(connection_t *conn,$/;"	f	file:
connection_fetch_var_cell_from_buf	or/connection_or.c	/^connection_fetch_var_cell_from_buf(or_connection_t *or_conn, var_cell_t **out)$/;"	f	file:
connection_finished_connecting	or/connection.c	/^connection_finished_connecting(connection_t *conn)$/;"	f	file:
connection_finished_flushing	or/connection.c	/^connection_finished_flushing(connection_t *conn)$/;"	f	file:
connection_flush	or/connection.c	/^connection_flush(connection_t *conn)$/;"	f
connection_flushed_some	or/connection.c	/^connection_flushed_some(connection_t *conn)$/;"	f	file:
connection_free	or/connection.c	/^connection_free(connection_t *conn)$/;"	f
connection_free_all	or/connection.c	/^connection_free_all(void)$/;"	f
connection_get_by_global_id	or/connection.c	/^connection_get_by_global_id(uint64_t id)$/;"	f
connection_get_by_type	or/connection.c	/^connection_get_by_type(int type)$/;"	f
connection_get_by_type_addr_port_purpose	or/connection.c	/^connection_get_by_type_addr_port_purpose(int type,$/;"	f
connection_get_by_type_purpose	or/connection.c	/^connection_get_by_type_purpose(int type, int purpose)$/;"	f
connection_get_by_type_state	or/connection.c	/^connection_get_by_type_state(int type, int state)$/;"	f
connection_get_by_type_state_rendquery	or/connection.c	/^connection_get_by_type_state_rendquery(int type, int state,$/;"	f
connection_get_inbuf_len	or/connection.h	/^connection_get_inbuf_len(connection_t *conn)$/;"	f
connection_get_outbuf_len	or/connection.h	/^connection_get_outbuf_len(connection_t *conn)$/;"	f
connection_get_rate_limit_totals	or/connection.c	/^connection_get_rate_limit_totals(uint64_t *read_out, uint64_t *written_out)$/;"	f
connection_handle_event_cb	or/connection.c	/^connection_handle_event_cb(struct bufferevent *bufev, short event, void *arg)$/;"	f
connection_handle_listener_read	or/connection.c	/^connection_handle_listener_read(connection_t *conn, int new_type)$/;"	f	file:
connection_handle_read	or/connection.c	/^connection_handle_read(connection_t *conn)$/;"	f
connection_handle_read_cb	or/connection.c	/^connection_handle_read_cb(struct bufferevent *bufev, void *arg)$/;"	f
connection_handle_read_impl	or/connection.c	/^connection_handle_read_impl(connection_t *conn)$/;"	f	file:
connection_handle_write	or/connection.c	/^connection_handle_write(connection_t *conn, int force)$/;"	f
connection_handle_write_cb	or/connection.c	/^connection_handle_write_cb(struct bufferevent *bufev, void *arg)$/;"	f
connection_handle_write_impl	or/connection.c	/^connection_handle_write_impl(connection_t *conn, int force)$/;"	f	file:
connection_in_array	or/main.c	/^connection_in_array(connection_t *conn)$/;"	f
connection_init	or/connection.c	/^connection_init(time_t now, connection_t *conn, int type, int socket_family)$/;"	f	file:
connection_init_accepted_conn	or/connection.c	/^connection_init_accepted_conn(connection_t *conn,$/;"	f	file:
connection_init_or_handshake_state	or/connection_or.c	/^connection_init_or_handshake_state(or_connection_t *conn, int started_here)$/;"	f
connection_is_listener	or/connection.c	/^connection_is_listener(connection_t *conn)$/;"	f
connection_is_on_closeable_list	or/main.c	/^connection_is_on_closeable_list(connection_t *conn)$/;"	f
connection_is_rate_limited	or/connection.c	/^connection_is_rate_limited(connection_t *conn)$/;"	f	file:
connection_is_reading	or/main.c	/^connection_is_reading(connection_t *conn)$/;"	f
connection_is_writing	or/main.c	/^connection_is_writing(connection_t *conn)$/;"	f
connection_link_connections	or/connection.c	/^connection_link_connections(connection_t *conn_a, connection_t *conn_b)$/;"	f
connection_listener_new	or/connection.c	/^connection_listener_new(const struct sockaddr *listensockaddr,$/;"	f	file:
connection_mark_all_noncontrol_connections	or/connection.c	/^connection_mark_all_noncontrol_connections(void)$/;"	f
connection_mark_all_noncontrol_listeners	or/connection.c	/^connection_mark_all_noncontrol_listeners(void)$/;"	f
connection_mark_and_flush	or/connection.h	/^#define connection_mark_and_flush(/;"	d
connection_mark_for_close	or/connection.h	/^#define connection_mark_for_close(/;"	d
connection_mark_unattached_ap	or/connection_edge.h	/^#define connection_mark_unattached_ap(/;"	d
connection_new	or/connection.c	/^connection_new(int type, int socket_family)$/;"	f
connection_or_about_to_close	or/connection_or.c	/^connection_or_about_to_close(or_connection_t *or_conn)$/;"	f
connection_or_check_valid_tls_handshake	or/connection_or.c	/^connection_or_check_valid_tls_handshake(or_connection_t *conn,$/;"	f	file:
connection_or_clear_identity_map	or/connection_or.c	/^connection_or_clear_identity_map(void)$/;"	f
connection_or_client_learned_peer_id	or/connection_or.c	/^connection_or_client_learned_peer_id(or_connection_t *conn,$/;"	f
connection_or_compute_authenticate_cell_body	or/connection_or.c	/^connection_or_compute_authenticate_cell_body(or_connection_t *conn,$/;"	f
connection_or_connect	or/connection_or.c	/^connection_or_connect(const tor_addr_t *_addr, uint16_t port,$/;"	f
connection_or_connect_failed	or/connection_or.c	/^connection_or_connect_failed(or_connection_t *conn,$/;"	f
connection_or_digest_is_known_relay	or/connection_or.c	/^connection_or_digest_is_known_relay(const char *id_digest)$/;"	f
connection_or_finished_connecting	or/connection_or.c	/^connection_or_finished_connecting(or_connection_t *or_conn)$/;"	f
connection_or_finished_flushing	or/connection_or.c	/^connection_or_finished_flushing(or_connection_t *conn)$/;"	f
connection_or_flush_from_first_active_circuit	or/relay.c	/^connection_or_flush_from_first_active_circuit(or_connection_t *conn, int max,$/;"	f
connection_or_flushed_some	or/connection_or.c	/^connection_or_flushed_some(or_connection_t *conn)$/;"	f
connection_or_get_for_extend	or/connection_or.c	/^connection_or_get_for_extend(const char *digest,$/;"	f
connection_or_get_state_description	or/connection_or.c	/^connection_or_get_state_description(or_connection_t *orconn,$/;"	f	file:
connection_or_group_set_badness	or/connection_or.c	/^connection_or_group_set_badness(or_connection_t *head, int force)$/;"	f	file:
connection_or_handle_event_cb	or/connection_or.c	/^connection_or_handle_event_cb(struct bufferevent *bufev, short event,$/;"	f	file:
connection_or_init_conn_from_address	or/connection_or.c	/^connection_or_init_conn_from_address(or_connection_t *conn,$/;"	f
connection_or_is_better	or/connection_or.c	/^connection_or_is_better(time_t now,$/;"	f	file:
connection_or_launch_v3_or_handshake	or/connection_or.c	/^connection_or_launch_v3_or_handshake(or_connection_t *conn)$/;"	f	file:
connection_or_nonopen_was_started_here	or/connection_or.c	/^connection_or_nonopen_was_started_here(or_connection_t *conn)$/;"	f
connection_or_note_state_when_broken	or/connection_or.c	/^connection_or_note_state_when_broken(or_connection_t *orconn)$/;"	f	file:
connection_or_process_cells_from_inbuf	or/connection_or.c	/^connection_or_process_cells_from_inbuf(or_connection_t *conn)$/;"	f	file:
connection_or_process_inbuf	or/connection_or.c	/^connection_or_process_inbuf(or_connection_t *conn)$/;"	f
connection_or_reached_eof	or/connection_or.c	/^connection_or_reached_eof(or_connection_t *conn)$/;"	f
connection_or_remove_from_identity_map	or/connection_or.c	/^connection_or_remove_from_identity_map(or_connection_t *conn)$/;"	f
connection_or_report_broken_states	or/connection_or.c	/^connection_or_report_broken_states(int severity, int domain)$/;"	f
connection_or_send_auth_challenge_cell	or/connection_or.c	/^connection_or_send_auth_challenge_cell(or_connection_t *conn)$/;"	f
connection_or_send_authenticate_cell	or/connection_or.c	/^connection_or_send_authenticate_cell(or_connection_t *conn, int authtype)$/;"	f
connection_or_send_certs_cell	or/connection_or.c	/^connection_or_send_certs_cell(or_connection_t *conn)$/;"	f
connection_or_send_destroy	or/connection_or.c	/^connection_or_send_destroy(circid_t circ_id, or_connection_t *conn, int reason)$/;"	f
connection_or_send_netinfo	or/connection_or.c	/^connection_or_send_netinfo(or_connection_t *conn)$/;"	f
connection_or_send_versions	or/connection_or.c	/^connection_or_send_versions(or_connection_t *conn, int v3_plus)$/;"	f
connection_or_set_bad_connections	or/connection_or.c	/^connection_or_set_bad_connections(const char *digest, int force)$/;"	f
connection_or_set_circid_type	or/connection_or.c	/^connection_or_set_circid_type(or_connection_t *conn,$/;"	f
connection_or_set_identity_digest	or/connection_or.c	/^connection_or_set_identity_digest(or_connection_t *conn, const char *digest)$/;"	f	file:
connection_or_set_state_open	or/connection_or.c	/^connection_or_set_state_open(or_connection_t *conn)$/;"	f
connection_or_tls_renegotiated_cb	or/connection_or.c	/^connection_or_tls_renegotiated_cb(tor_tls_t *tls, void *_conn)$/;"	f	file:
connection_or_unlink_all_active_circs	or/relay.c	/^connection_or_unlink_all_active_circs(or_connection_t *orconn)$/;"	f
connection_or_update_token_buckets	or/connection_or.c	/^connection_or_update_token_buckets(smartlist_t *conns,$/;"	f
connection_or_update_token_buckets_helper	or/connection_or.c	/^connection_or_update_token_buckets_helper(or_connection_t *conn, int reset,$/;"	f	file:
connection_or_write_cell_to_buf	or/connection_or.c	/^connection_or_write_cell_to_buf(const cell_t *cell, or_connection_t *conn)$/;"	f
connection_or_write_var_cell_to_buf	or/connection_or.c	/^connection_or_write_var_cell_to_buf(const var_cell_t *cell,$/;"	f
connection_outbuf_too_full	or/connection.c	/^connection_outbuf_too_full(connection_t *conn)$/;"	f
connection_printf_to_buf	or/control.c	/^connection_printf_to_buf(control_connection_t *conn, const char *format, ...)$/;"	f	file:
connection_process_inbuf	or/connection.c	/^connection_process_inbuf(connection_t *conn, int package_partial)$/;"	f	file:
connection_proxy_connect	or/connection.c	/^connection_proxy_connect(connection_t *conn, int type)$/;"	f
connection_proxy_state_to_string	or/connection.c	/^connection_proxy_state_to_string(int state)$/;"	f	file:
connection_reached_eof	or/connection.c	/^connection_reached_eof(connection_t *conn)$/;"	f	file:
connection_read_https_proxy_response	or/connection.c	/^connection_read_https_proxy_response(connection_t *conn)$/;"	f	file:
connection_read_proxy_handshake	or/connection.c	/^connection_read_proxy_handshake(connection_t *conn)$/;"	f
connection_read_to_buf	or/connection.c	/^connection_read_to_buf(connection_t *conn, ssize_t *max_to_read,$/;"	f	file:
connection_remove	or/main.c	/^connection_remove(connection_t *conn)$/;"	f
connection_send_socks5_connect	or/connection.c	/^connection_send_socks5_connect(connection_t *conn)$/;"	f	file:
connection_should_read_from_linked_conn	or/main.c	/^connection_should_read_from_linked_conn(connection_t *conn)$/;"	f	file:
connection_speaks_cells	or/connection.h	/^#define connection_speaks_cells(/;"	d
connection_start_reading	or/main.c	/^connection_start_reading(connection_t *conn)$/;"	f
connection_start_reading_from_linked_conn	or/main.c	/^connection_start_reading_from_linked_conn(connection_t *conn)$/;"	f	file:
connection_start_writing	or/main.c	/^connection_start_writing(connection_t *conn)$/;"	f
connection_state_is_connecting	or/connection.c	/^connection_state_is_connecting(connection_t *conn)$/;"	f
connection_state_is_open	or/connection.c	/^connection_state_is_open(connection_t *conn)$/;"	f
connection_stop_reading	or/main.c	/^connection_stop_reading(connection_t *conn)$/;"	f
connection_stop_reading_from_linked_conn	or/main.c	/^connection_stop_reading_from_linked_conn(connection_t *conn)$/;"	f
connection_stop_writing	or/main.c	/^connection_stop_writing(connection_t *conn)$/;"	f
connection_t	or/or.h	/^typedef struct connection_t {$/;"	s
connection_t	or/or.h	/^} connection_t;$/;"	t	typeref:struct:connection_t
connection_tls_continue_handshake	or/connection_or.c	/^connection_tls_continue_handshake(or_connection_t *conn)$/;"	f
connection_tls_finish_handshake	or/connection_or.c	/^connection_tls_finish_handshake(or_connection_t *conn)$/;"	f	file:
connection_tls_start_handshake	or/connection_or.c	/^connection_tls_start_handshake(or_connection_t *conn, int receiving)$/;"	f
connection_type_uses_bufferevent	or/connection.c	/^connection_type_uses_bufferevent(connection_t *conn)$/;"	f
connection_type_uses_bufferevent	or/connection.h	/^#define connection_type_uses_bufferevent(/;"	d
connection_unlink	or/main.c	/^connection_unlink(connection_t *conn)$/;"	f	file:
connection_unregister_events	or/main.c	/^connection_unregister_events(connection_t *conn)$/;"	f
connection_wants_to_flush	or/connection.c	/^connection_wants_to_flush(connection_t *conn)$/;"	f
connection_watch_events	or/main.c	/^connection_watch_events(connection_t *conn, watchable_events_t events)$/;"	f
connection_write_str_to_buf	or/control.c	/^connection_write_str_to_buf(const char *s, control_connection_t *conn)$/;"	f	file:
connection_write_to_buf	or/connection.h	/^connection_write_to_buf(const char *string, size_t len, connection_t *conn)$/;"	f
connection_write_to_buf_zlib	or/connection.h	/^connection_write_to_buf_zlib(const char *string, size_t len,$/;"	f
consensus	or/dirvote.c	/^  networkstatus_t *consensus;$/;"	m	struct:pending_consensus_t	file:
consensus	or/networkstatus.c	/^  networkstatus_t *consensus;$/;"	m	struct:consensus_waiting_for_certs_t	file:
consensus_dl_status	or/networkstatus.c	/^static download_status_t consensus_dl_status[N_CONSENSUS_FLAVORS];$/;"	v	file:
consensus_flavor_t	or/or.h	/^} consensus_flavor_t;$/;"	t	typeref:enum:__anon43
consensus_is_waiting_for_certs	or/networkstatus.c	/^consensus_is_waiting_for_certs(void)$/;"	f
consensus_method	or/or.h	/^  int consensus_method;$/;"	m	struct:networkstatus_t
consensus_method_is_supported	or/dirvote.c	/^consensus_method_is_supported(int method)$/;"	f	file:
consensus_waiting_for_certs	or/networkstatus.c	/^       consensus_waiting_for_certs[N_CONSENSUS_FLAVORS];$/;"	v	file:
consensus_waiting_for_certs_t	or/networkstatus.c	/^typedef struct consensus_waiting_for_certs_t {$/;"	s	file:
consensus_waiting_for_certs_t	or/networkstatus.c	/^} consensus_waiting_for_certs_t;$/;"	t	typeref:struct:consensus_waiting_for_certs_t	file:
consider_adding_dir_authorities	or/config.c	/^consider_adding_dir_authorities(const or_options_t *options,$/;"	f	file:
consider_hibernation	or/hibernate.c	/^consider_hibernation(time_t now)$/;"	f
consider_plaintext_ports	or/connection_edge.c	/^consider_plaintext_ports(entry_connection_t *conn, uint16_t port)$/;"	f	file:
consider_publishable_server	or/router.c	/^consider_publishable_server(int force)$/;"	f
consider_recording_trackhost	or/circuituse.c	/^consider_recording_trackhost(const entry_connection_t *conn,$/;"	f	file:
consider_republishing_rend_descriptors	or/rendservice.c	/^static int consider_republishing_rend_descriptors = 1;$/;"	v	file:
consider_testing_reachability	or/router.c	/^consider_testing_reachability(int test_or, int test_dir)$/;"	f
contact	or/or.h	/^  char *contact; \/**< Contact information for this voter. *\/$/;"	m	struct:networkstatus_voter_info_t
contact	or/or.h	/^  char *contact; \/**< How to contact directory admin? (may be NULL). *\/$/;"	m	struct:networkstatus_v2_t
contact_info	or/or.h	/^  char *contact_info; \/**< Declared contact info for this router. *\/$/;"	m	struct:__anon41
container_tests	test/test_containers.c	/^struct testcase_t container_tests[] = {$/;"	v	typeref:struct:testcase_t
context	common/tortls.c	/^  tor_tls_context_t *context; \/** A link to the context object for this tls. *\/$/;"	m	struct:tor_tls_t	file:
control_adjust_event_log_severity	or/control.c	/^control_adjust_event_log_severity(void)$/;"	f
control_connection_new	or/connection.c	/^control_connection_new(int socket_family)$/;"	f
control_connection_t	or/or.h	/^typedef struct control_connection_t {$/;"	s
control_connection_t	or/or.h	/^} control_connection_t;$/;"	t	typeref:struct:control_connection_t
control_event_address_mapped	or/control.c	/^control_event_address_mapped(const char *from, const char *to, time_t expires,$/;"	f
control_event_bandwidth_used	or/control.c	/^control_event_bandwidth_used(uint32_t n_read, uint32_t n_written)$/;"	f
control_event_bootstrap	or/control.c	/^control_event_bootstrap(bootstrap_status_t status, int progress)$/;"	f
control_event_bootstrap_problem	or/control.c	/^control_event_bootstrap_problem(const char *warn, int reason)$/;"	f
control_event_buildtimeout_set	or/control.c	/^control_event_buildtimeout_set(const circuit_build_times_t *cbt,$/;"	f
control_event_circuit_cannibalized	or/control.c	/^control_event_circuit_cannibalized(origin_circuit_t *circ,$/;"	f
control_event_circuit_purpose_changed	or/control.c	/^control_event_circuit_purpose_changed(origin_circuit_t *circ,$/;"	f
control_event_circuit_status	or/control.c	/^control_event_circuit_status(origin_circuit_t *circ, circuit_status_event_t tp,$/;"	f
control_event_circuit_status_minor	or/control.c	/^control_event_circuit_status_minor(origin_circuit_t *circ,$/;"	f	file:
control_event_client_status	or/control.c	/^control_event_client_status(int severity, const char *format, ...)$/;"	f
control_event_clients_seen	or/control.c	/^control_event_clients_seen(const char *controller_str)$/;"	f
control_event_conf_changed	or/control.c	/^control_event_conf_changed(smartlist_t *elements)$/;"	f
control_event_descriptors_changed	or/control.c	/^control_event_descriptors_changed(smartlist_t *routers)$/;"	f
control_event_general_status	or/control.c	/^control_event_general_status(int severity, const char *format, ...)$/;"	f
control_event_guard	or/control.c	/^control_event_guard(const char *nickname, const char *digest,$/;"	f
control_event_guard_deferred	or/circuitbuild.c	/^control_event_guard_deferred(void)$/;"	f	file:
control_event_is_interesting	or/control.c	/^control_event_is_interesting(int event)$/;"	f
control_event_logmsg	or/control.c	/^control_event_logmsg(int severity, uint32_t domain, const char *msg)$/;"	f
control_event_my_descriptor_changed	or/control.c	/^control_event_my_descriptor_changed(void)$/;"	f
control_event_networkstatus_changed	or/control.c	/^control_event_networkstatus_changed(smartlist_t *statuses)$/;"	f
control_event_networkstatus_changed_helper	or/control.c	/^control_event_networkstatus_changed_helper(smartlist_t *statuses,$/;"	f	file:
control_event_networkstatus_changed_single	or/control.c	/^control_event_networkstatus_changed_single(const routerstatus_t *rs)$/;"	f
control_event_newconsensus	or/control.c	/^control_event_newconsensus(const networkstatus_t *consensus)$/;"	f
control_event_or_authdir_new_descriptor	or/control.c	/^control_event_or_authdir_new_descriptor(const char *action,$/;"	f
control_event_or_conn_status	or/control.c	/^control_event_or_conn_status(or_connection_t *conn, or_conn_status_event_t tp,$/;"	f
control_event_server_status	or/control.c	/^control_event_server_status(int severity, const char *format, ...)$/;"	f
control_event_signal	or/control.c	/^control_event_signal(uintptr_t signal)$/;"	f
control_event_status	or/control.c	/^control_event_status(int type, int severity, const char *format, va_list args)$/;"	f	file:
control_event_stream_bandwidth	or/control.c	/^control_event_stream_bandwidth(edge_connection_t *edge_conn)$/;"	f
control_event_stream_bandwidth_used	or/control.c	/^control_event_stream_bandwidth_used(void)$/;"	f
control_event_stream_status	or/control.c	/^control_event_stream_status(entry_connection_t *conn, stream_status_event_t tp,$/;"	f
control_event_t	or/control.c	/^struct control_event_t {$/;"	s	file:
control_event_table	or/control.c	/^static const struct control_event_t control_event_table[] = {$/;"	v	typeref:struct:control_event_t	file:
control_ports_write_to_file	or/control.c	/^control_ports_write_to_file(void)$/;"	f
control_setconf_helper	or/control.c	/^control_setconf_helper(control_connection_t *conn, uint32_t len, char *body,$/;"	f	file:
control_update_global_event_mask	or/control.c	/^control_update_global_event_mask(void)$/;"	f
correct_time	or/rephist.c	/^correct_time(time_t t, time_t now, time_t stored_at, time_t started_measuring)$/;"	f	file:
correct_tm	common/compat.c	/^correct_tm(int islocal, const time_t *timep, struct tm *resultbuf,$/;"	f	file:
count	or/connection_or.c	/^  intptr_t count;$/;"	m	struct:broken_state_count_t	file:
count	or/directory.c	/^  uint64_t count; \/**< How many requests have we made? *\/$/;"	m	struct:request_t	file:
count_acceptable_nodes	or/circuitbuild.c	/^count_acceptable_nodes(smartlist_t *nodes)$/;"	f	file:
count_circuits	or/status.c	/^count_circuits(void)$/;"	f	file:
count_established_intro_points	or/rendservice.c	/^count_established_intro_points(const char *query)$/;"	f	file:
count_loading_descriptors_progress	or/routerlist.c	/^count_loading_descriptors_progress(void)$/;"	f
count_pending_general_client_circuits	or/circuituse.c	/^count_pending_general_client_circuits(void)$/;"	f	file:
count_usable_descriptors	or/routerlist.c	/^count_usable_descriptors(int *num_present, int *num_usable,$/;"	f	file:
counter	or/or.h	/^  unsigned counter; \/**< How many cells were inserted? *\/$/;"	m	struct:insertion_time_elem_t
counter0	common/aes.c	/^  uint32_t counter0;$/;"	m	struct:aes_cnt_cipher	file:
counter1	common/aes.c	/^  uint32_t counter1;$/;"	m	struct:aes_cnt_cipher	file:
counter2	common/aes.c	/^  uint32_t counter2;$/;"	m	struct:aes_cnt_cipher	file:
counter3	common/aes.c	/^  uint32_t counter3;$/;"	m	struct:aes_cnt_cipher	file:
countries	or/routerlist.c	/^  bitarray_t *countries;$/;"	m	struct:routerset_t	file:
country	or/geoip.c	/^  char country[3]; \/**< Two-letter country code. *\/$/;"	m	struct:c_hist_t	file:
country	or/geoip.c	/^  intptr_t country; \/**< An index into geoip_countries *\/$/;"	m	struct:geoip_entry_t	file:
country	or/or.h	/^  country_t country;$/;"	m	struct:node_t
country_idxplus1_by_lc_code	or/geoip.c	/^static strmap_t *country_idxplus1_by_lc_code = NULL;$/;"	v	file:
country_names	or/routerlist.c	/^  smartlist_t *country_names;$/;"	m	struct:routerset_t	file:
country_t	or/or.h	/^typedef int16_t country_t;$/;"	t
countrycode	or/geoip.c	/^  char countrycode[3];$/;"	m	struct:geoip_country_t	file:
cpath	or/or.h	/^  crypt_path_t *cpath;$/;"	m	struct:__anon46
cpath	or/or.h	/^  crypt_path_t *cpath;$/;"	m	struct:origin_circuit_t
cpath_build_state_t	or/or.h	/^} cpath_build_state_t;$/;"	t	typeref:struct:__anon47
cpath_is_on_circuit	or/circuituse.c	/^cpath_is_on_circuit(origin_circuit_t *circ, crypt_path_t *crypt_path)$/;"	f	file:
cpath_layer	or/or.h	/^  struct crypt_path_t *cpath_layer;$/;"	m	struct:edge_connection_t	typeref:struct:edge_connection_t::crypt_path_t
cpath_ref_decref	or/circuitlist.c	/^cpath_ref_decref(crypt_path_reference_t *cpath_ref)$/;"	f	file:
cpd_check_t	common/util.h	/^typedef unsigned int cpd_check_t;$/;"	t
cpu_init	or/cpuworker.c	/^cpu_init(void)$/;"	f
cpuworker_main	or/cpuworker.c	/^cpuworker_main(void *data)$/;"	f	file:
cpuworkers_rotate	or/cpuworker.c	/^cpuworkers_rotate(void)$/;"	f
create_managed_proxy_environment	or/transports.c	/^create_managed_proxy_environment(const managed_proxy_t *mp)$/;"	f	file:
create_unix_sockaddr	or/connection.c	/^create_unix_sockaddr(const char *listenaddress, char **readable_address,$/;"	f	file:
crypt_path_reference_t	or/or.h	/^} crypt_path_reference_t;$/;"	t	typeref:struct:__anon46
crypt_path_t	or/or.h	/^typedef struct crypt_path_t {$/;"	s
crypt_path_t	or/or.h	/^} crypt_path_t;$/;"	t	typeref:struct:crypt_path_t
crypto_cipher_crypt_inplace	common/crypto.c	/^crypto_cipher_crypt_inplace(crypto_cipher_t *env, char *buf, size_t len)$/;"	f
crypto_cipher_decrypt	common/crypto.c	/^crypto_cipher_decrypt(crypto_cipher_t *env, char *to,$/;"	f
crypto_cipher_decrypt_with_iv	common/crypto.c	/^crypto_cipher_decrypt_with_iv(const char *key,$/;"	f
crypto_cipher_encrypt	common/crypto.c	/^crypto_cipher_encrypt(crypto_cipher_t *env, char *to,$/;"	f
crypto_cipher_encrypt_with_iv	common/crypto.c	/^crypto_cipher_encrypt_with_iv(const char *key,$/;"	f
crypto_cipher_free	common/crypto.c	/^crypto_cipher_free(crypto_cipher_t *env)$/;"	f
crypto_cipher_get_key	common/crypto.c	/^crypto_cipher_get_key(crypto_cipher_t *env)$/;"	f
crypto_cipher_new	common/crypto.c	/^crypto_cipher_new(const char *key)$/;"	f
crypto_cipher_new_with_iv	common/crypto.c	/^crypto_cipher_new_with_iv(const char *key, const char *iv)$/;"	f
crypto_cipher_t	common/crypto.c	/^struct crypto_cipher_t$/;"	s	file:
crypto_cipher_t	common/crypto.h	/^typedef struct crypto_cipher_t crypto_cipher_t;$/;"	t	typeref:struct:crypto_cipher_t
crypto_dh_compute_secret	common/crypto.c	/^crypto_dh_compute_secret(int severity, crypto_dh_t *dh,$/;"	f
crypto_dh_free	common/crypto.c	/^crypto_dh_free(crypto_dh_t *dh)$/;"	f
crypto_dh_generate_public	common/crypto.c	/^crypto_dh_generate_public(crypto_dh_t *dh)$/;"	f
crypto_dh_get_bytes	common/crypto.c	/^crypto_dh_get_bytes(crypto_dh_t *dh)$/;"	f
crypto_dh_get_public	common/crypto.c	/^crypto_dh_get_public(crypto_dh_t *dh, char *pubkey, size_t pubkey_len)$/;"	f
crypto_dh_new	common/crypto.c	/^crypto_dh_new(int dh_type)$/;"	f
crypto_dh_t	common/crypto.c	/^struct crypto_dh_t {$/;"	s	file:
crypto_dh_t	common/crypto.h	/^typedef struct crypto_dh_t crypto_dh_t;$/;"	t	typeref:struct:crypto_dh_t
crypto_digest	common/crypto.c	/^crypto_digest(char *digest, const char *m, size_t len)$/;"	f
crypto_digest256	common/crypto.c	/^crypto_digest256(char *digest, const char *m, size_t len,$/;"	f
crypto_digest256_new	common/crypto.c	/^crypto_digest256_new(digest_algorithm_t algorithm)$/;"	f
crypto_digest_add_bytes	common/crypto.c	/^crypto_digest_add_bytes(crypto_digest_t *digest, const char *data,$/;"	f
crypto_digest_algorithm_get_name	common/crypto.c	/^crypto_digest_algorithm_get_name(digest_algorithm_t alg)$/;"	f
crypto_digest_algorithm_parse_name	common/crypto.c	/^crypto_digest_algorithm_parse_name(const char *name)$/;"	f
crypto_digest_all	common/crypto.c	/^crypto_digest_all(digests_t *ds_out, const char *m, size_t len)$/;"	f
crypto_digest_assign	common/crypto.c	/^crypto_digest_assign(crypto_digest_t *into,$/;"	f
crypto_digest_dup	common/crypto.c	/^crypto_digest_dup(const crypto_digest_t *digest)$/;"	f
crypto_digest_free	common/crypto.c	/^crypto_digest_free(crypto_digest_t *digest)$/;"	f
crypto_digest_get_digest	common/crypto.c	/^crypto_digest_get_digest(crypto_digest_t *digest,$/;"	f
crypto_digest_new	common/crypto.c	/^crypto_digest_new(void)$/;"	f
crypto_digest_t	common/crypto.c	/^struct crypto_digest_t {$/;"	s	file:
crypto_digest_t	common/crypto.h	/^typedef struct crypto_digest_t crypto_digest_t;$/;"	t	typeref:struct:crypto_digest_t
crypto_expand_key_material	common/crypto.c	/^crypto_expand_key_material(const char *key_in, size_t key_in_len,$/;"	f
crypto_generate_dynamic_dh_modulus	common/crypto.c	/^crypto_generate_dynamic_dh_modulus(void)$/;"	f	file:
crypto_get_rsa_padding	common/crypto.c	/^crypto_get_rsa_padding(int padding)$/;"	f	file:
crypto_get_rsa_padding_overhead	common/crypto.c	/^crypto_get_rsa_padding_overhead(int padding)$/;"	f	file:
crypto_get_stored_dynamic_dh_modulus	common/crypto.c	/^crypto_get_stored_dynamic_dh_modulus(const char *fname)$/;"	f	file:
crypto_global_cleanup	common/crypto.c	/^crypto_global_cleanup(void)$/;"	f
crypto_global_init	common/crypto.c	/^crypto_global_init(int useAccel, const char *accelName, const char *accelDir)$/;"	f
crypto_hmac_sha1	common/crypto.c	/^crypto_hmac_sha1(char *hmac_out,$/;"	f
crypto_hmac_sha256	common/crypto.c	/^crypto_hmac_sha256(char *hmac_out,$/;"	f
crypto_log_errors	common/crypto.c	/^crypto_log_errors(int severity, const char *doing)$/;"	f	file:
crypto_log_errors	tools/tor-gencert.c	/^crypto_log_errors(int severity, const char *doing)$/;"	f	file:
crypto_pk_asn1_decode	common/crypto.c	/^crypto_pk_asn1_decode(const char *str, size_t len)$/;"	f
crypto_pk_asn1_encode	common/crypto.c	/^crypto_pk_asn1_encode(crypto_pk_t *pk, char *dest, size_t dest_len)$/;"	f
crypto_pk_check_fingerprint_syntax	common/crypto.c	/^crypto_pk_check_fingerprint_syntax(const char *s)$/;"	f
crypto_pk_check_key	common/crypto.c	/^crypto_pk_check_key(crypto_pk_t *env)$/;"	f
crypto_pk_cmp_keys	common/crypto.c	/^crypto_pk_cmp_keys(crypto_pk_t *a, crypto_pk_t *b)$/;"	f
crypto_pk_copy_full	common/crypto.c	/^crypto_pk_copy_full(crypto_pk_t *env)$/;"	f
crypto_pk_dup_key	common/crypto.c	/^crypto_pk_dup_key(crypto_pk_t *env)$/;"	f
crypto_pk_free	common/crypto.c	/^crypto_pk_free(crypto_pk_t *env)$/;"	f
crypto_pk_generate_key	common/crypto.h	/^#define crypto_pk_generate_key(/;"	d
crypto_pk_generate_key_with_bits	common/crypto.c	/^crypto_pk_generate_key_with_bits(crypto_pk_t *env, int bits)$/;"	f
crypto_pk_get_all_digests	common/crypto.c	/^crypto_pk_get_all_digests(crypto_pk_t *pk, digests_t *digests_out)$/;"	f
crypto_pk_get_digest	common/crypto.c	/^crypto_pk_get_digest(crypto_pk_t *pk, char *digest_out)$/;"	f
crypto_pk_get_fingerprint	common/crypto.c	/^crypto_pk_get_fingerprint(crypto_pk_t *pk, char *fp_out, int add_space)$/;"	f
crypto_pk_key_is_private	common/crypto.c	/^crypto_pk_key_is_private(const crypto_pk_t *key)$/;"	f
crypto_pk_keysize	common/crypto.c	/^crypto_pk_keysize(crypto_pk_t *env)$/;"	f
crypto_pk_new	common/crypto.c	/^crypto_pk_new(void)$/;"	f
crypto_pk_num_bits	common/crypto.c	/^crypto_pk_num_bits(crypto_pk_t *env)$/;"	f
crypto_pk_private_decrypt	common/crypto.c	/^crypto_pk_private_decrypt(crypto_pk_t *env, char *to,$/;"	f
crypto_pk_private_hybrid_decrypt	common/crypto.c	/^crypto_pk_private_hybrid_decrypt(crypto_pk_t *env,$/;"	f
crypto_pk_private_sign	common/crypto.c	/^crypto_pk_private_sign(crypto_pk_t *env, char *to, size_t tolen,$/;"	f
crypto_pk_private_sign_digest	common/crypto.c	/^crypto_pk_private_sign_digest(crypto_pk_t *env, char *to, size_t tolen,$/;"	f
crypto_pk_public_checksig	common/crypto.c	/^crypto_pk_public_checksig(crypto_pk_t *env, char *to,$/;"	f
crypto_pk_public_checksig_digest	common/crypto.c	/^crypto_pk_public_checksig_digest(crypto_pk_t *env, const char *data,$/;"	f
crypto_pk_public_encrypt	common/crypto.c	/^crypto_pk_public_encrypt(crypto_pk_t *env, char *to, size_t tolen,$/;"	f
crypto_pk_public_exponent_ok	common/crypto.c	/^crypto_pk_public_exponent_ok(crypto_pk_t *env)$/;"	f
crypto_pk_public_hybrid_encrypt	common/crypto.c	/^crypto_pk_public_hybrid_encrypt(crypto_pk_t *env,$/;"	f
crypto_pk_read_private_key_from_filename	common/crypto.c	/^crypto_pk_read_private_key_from_filename(crypto_pk_t *env,$/;"	f
crypto_pk_read_private_key_from_string	common/crypto.c	/^crypto_pk_read_private_key_from_string(crypto_pk_t *env,$/;"	f
crypto_pk_read_public_key_from_string	common/crypto.c	/^crypto_pk_read_public_key_from_string(crypto_pk_t *env, const char *src,$/;"	f
crypto_pk_t	common/crypto.c	/^struct crypto_pk_t$/;"	s	file:
crypto_pk_t	common/crypto.h	/^typedef struct crypto_pk_t crypto_pk_t;$/;"	t	typeref:struct:crypto_pk_t
crypto_pk_write_key_to_string_impl	common/crypto.c	/^crypto_pk_write_key_to_string_impl(crypto_pk_t *env, char **dest,$/;"	f	file:
crypto_pk_write_private_key_to_filename	common/crypto.c	/^crypto_pk_write_private_key_to_filename(crypto_pk_t *env,$/;"	f
crypto_pk_write_private_key_to_string	common/crypto.c	/^crypto_pk_write_private_key_to_string(crypto_pk_t *env, char **dest,$/;"	f
crypto_pk_write_public_key_to_string	common/crypto.c	/^crypto_pk_write_public_key_to_string(crypto_pk_t *env, char **dest,$/;"	f
crypto_rand	common/crypto.c	/^crypto_rand(char *to, size_t n)$/;"	f
crypto_rand_double	common/crypto.c	/^crypto_rand_double(void)$/;"	f
crypto_rand_int	common/crypto.c	/^crypto_rand_int(unsigned int max)$/;"	f
crypto_rand_uint64	common/crypto.c	/^crypto_rand_uint64(uint64_t max)$/;"	f
crypto_random_hostname	common/crypto.c	/^crypto_random_hostname(int min_rand_len, int max_rand_len, const char *prefix,$/;"	f
crypto_seed_rng	common/crypto.c	/^crypto_seed_rng(int startup)$/;"	f
crypto_set_tls_dh_prime	common/crypto.c	/^crypto_set_tls_dh_prime(const char *dynamic_dh_modulus_fname)$/;"	f
crypto_store_dynamic_dh_modulus	common/crypto.c	/^crypto_store_dynamic_dh_modulus(const char *fname)$/;"	f	file:
crypto_tests	test/test_crypto.c	/^struct testcase_t crypto_tests[] = {$/;"	v	typeref:struct:testcase_t
crypto_thread_cleanup	common/crypto.c	/^crypto_thread_cleanup(void)$/;"	f
ctr_buf	common/aes.c	/^  } ctr_buf;$/;"	m	struct:aes_cnt_cipher	typeref:union:aes_cnt_cipher::__anon4	file:
ctx	common/tortls.c	/^  SSL_CTX *ctx;$/;"	m	struct:tor_tls_context_t	file:
cull_wedged_cpuworkers	or/cpuworker.c	/^cull_wedged_cpuworkers(void)$/;"	f	file:
cur_length	or/buffers.c	/^  int cur_length; \/**< How many chunks on the freelist now? *\/$/;"	m	struct:chunk_freelist_t	file:
cur_obs_idx	or/rephist.c	/^  int cur_obs_idx; \/**< Current position in obs. *\/$/;"	m	struct:bw_array_t	file:
cur_obs_time	or/rephist.c	/^  time_t cur_obs_time; \/**< Time represented in obs[cur_obs_idx] *\/$/;"	m	struct:bw_array_t	file:
cur_test_name	test/tinytest.c	/^const char *cur_test_name = NULL;$/;"	v
cur_test_outcome	test/tinytest.c	/^static enum outcome cur_test_outcome = 0;$/;"	v	typeref:enum:outcome	file:
cur_test_prefix	test/tinytest.c	/^const char *cur_test_prefix = NULL; \/**< prefix of the current test group *\/$/;"	v
curlen	common/sha256.c	/^    uint32_t state[8], curlen;$/;"	m	struct:sha256_state	file:
current_consensus	or/networkstatus.c	/^#define current_consensus /;"	d	file:
current_md_consensus	or/networkstatus.c	/^static networkstatus_t *current_md_consensus = NULL;$/;"	v	file:
current_ns_consensus	or/networkstatus.c	/^static networkstatus_t *current_ns_consensus = NULL;$/;"	v	file:
d	common/crypto.c	/^  } d; \/**< State for the digest we're using.  Only one member of the$/;"	m	struct:crypto_digest_t	typeref:union:crypto_digest_t::__anon9	file:
d	common/crypto.h	/^  char d[N_DIGEST_ALGORITHMS][DIGEST256_LEN];$/;"	m	struct:__anon11
daemon_filedes	common/util.c	/^static int daemon_filedes[2];$/;"	v	file:
data	common/compat.c	/^  void *data;$/;"	m	struct:tor_pthread_data_t	file:
data	common/compat.h	/^  const char *data; \/**< Mapping of the file's contents. *\/$/;"	m	struct:tor_mmap_t
data	common/compat_libevent.c	/^  void *data;$/;"	m	struct:periodic_timer_t	file:
data	or/buffers.c	/^  char *data; \/**< A pointer to the first byte of data stored in <b>mem<\/b>. *\/$/;"	m	struct:chunk_t	file:
data	or/eventdns.c	/^	void *data; \/* The contents of the RR *\/$/;"	m	struct:server_reply_item	file:
data	or/eventdns.c	/^	} data;$/;"	m	struct:reply	typeref:union:reply::__anon28	file:
data	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^  struct IGDdatas data;$/;"	m	struct:miniupnpc_state_t	typeref:struct:miniupnpc_state_t::IGDdatas
data_buffer	test/tinytest_demo.c	/^struct data_buffer {$/;"	s	file:
data_buffer_setup	test/tinytest_demo.c	/^struct testcase_setup_t data_buffer_setup = {$/;"	v	typeref:struct:testcase_setup_t
datalen	or/buffers.c	/^  size_t datalen; \/**< How many bytes is this buffer holding right now? *\/$/;"	m	struct:buf_t	file:
datalen	or/buffers.c	/^  size_t datalen; \/**< The number of bytes stored in this chunk *\/$/;"	m	struct:chunk_t	file:
datalen	or/eventdns.c	/^	u16 datalen; \/* Length of data; -1 if data is a label *\/$/;"	m	struct:server_reply_item	file:
days_per_month	common/util.c	/^static const int days_per_month[] =$/;"	v	file:
debug_ntoa	or/eventdns.c	/^debug_ntoa(u32 address)$/;"	f	file:
debug_ntop	or/eventdns.c	/^debug_ntop(const struct sockaddr *sa)$/;"	f	file:
decide_if_publishable_server	or/router.c	/^decide_if_publishable_server(void)$/;"	f	file:
decide_to_advertise_dirport	or/router.c	/^decide_to_advertise_dirport(const or_options_t *options, uint16_t dir_port)$/;"	f	file:
declared_family	or/or.h	/^  smartlist_t *declared_family; \/**< Nicknames of router which this router$/;"	m	struct:__anon41
decode_address_from_payload	or/relay.c	/^decode_address_from_payload(tor_addr_t *addr_out, const uint8_t *payload,$/;"	f
decode_escaped_string	or/control.c	/^decode_escaped_string(const char *start, size_t in_len_max,$/;"	f	file:
decode_hashed_passwords	or/control.c	/^decode_hashed_passwords(config_line_t *passwords)$/;"	f
default_chunk_size	or/buffers.c	/^  size_t default_chunk_size; \/**< Don't allocate any chunks smaller than$/;"	m	struct:buf_t	file:
default_random_bytes_fn	or/eventdns.c	/^default_random_bytes_fn(char *buf, size_t n)$/;"	f	file:
default_transaction_id_fn	or/eventdns.c	/^default_transaction_id_fn(void)$/;"	f	file:
del_timeout_event	or/eventdns.c	/^#define del_timeout_event(/;"	d	file:
delete_log	common/log.c	/^delete_log(logfile_t *victim)$/;"	f	file:
deliver_window	or/or.h	/^  int deliver_window; \/**< How many cells are we willing to deliver originating$/;"	m	struct:crypt_path_t
deliver_window	or/or.h	/^  int deliver_window; \/**< How many more relay cells can end at me? *\/$/;"	m	struct:edge_connection_t
deliver_window	or/or.h	/^  int deliver_window;$/;"	m	struct:circuit_t
demo_tests	test/tinytest_demo.c	/^struct testcase_t demo_tests[] = {$/;"	v	typeref:struct:testcase_t
desc	or/control.c	/^  const char *desc; \/**< Description of the variable. *\/$/;"	m	struct:getinfo_item_t	file:
desc	or/or.h	/^  char *desc; \/**< Service descriptor *\/$/;"	m	struct:rend_cache_entry_t
desc	or/rendservice.c	/^  rend_service_descriptor_t *desc; \/**< Current hidden service descriptor. *\/$/;"	m	struct:rend_service_t	file:
desc_by_eid_map	or/or.h	/^  struct digest_sd_map_t *desc_by_eid_map;$/;"	m	struct:__anon44	typeref:struct:__anon44::digest_sd_map_t
desc_clean_since	or/router.c	/^static time_t desc_clean_since = 0;$/;"	v	file:
desc_digest_map	or/or.h	/^  digestmap_t *desc_digest_map;$/;"	m	struct:networkstatus_t
desc_digest_map	or/or.h	/^  struct digest_sd_map_t *desc_digest_map;$/;"	m	struct:__anon44	typeref:struct:__anon44::digest_sd_map_t
desc_dirty_reason	or/router.c	/^static const char *desc_dirty_reason = NULL;$/;"	v	file:
desc_extrainfo	or/router.c	/^static extrainfo_t *desc_extrainfo = NULL;$/;"	v	file:
desc_gen_reason	or/router.c	/^static const char *desc_gen_reason = NULL;$/;"	v	file:
desc_get_store	or/routerlist.c	/^desc_get_store(routerlist_t *rl, const signed_descriptor_t *sd)$/;"	f	file:
desc_id	or/or.h	/^  char desc_id[DIGEST_LEN]; \/**< Descriptor ID. *\/$/;"	m	struct:rend_encoded_v2_service_descriptor_t
desc_is_dirty	or/rendservice.c	/^  time_t desc_is_dirty; \/**< Time at which changes to the hidden service$/;"	m	struct:rend_service_t	file:
desc_needs_upload	or/router.c	/^static int desc_needs_upload = 0;$/;"	v	file:
desc_routerinfo	or/router.c	/^static routerinfo_t *desc_routerinfo = NULL;$/;"	v	file:
desc_store	or/or.h	/^  desc_store_t desc_store;$/;"	m	struct:__anon44
desc_store_t	or/or.h	/^typedef struct desc_store_t {$/;"	s
desc_store_t	or/or.h	/^} desc_store_t;$/;"	t	typeref:struct:desc_store_t
desc_str	or/or.h	/^  char *desc_str; \/**< Descriptor string. *\/$/;"	m	struct:rend_encoded_v2_service_descriptor_t
desc_token_table	or/routerparse.c	/^static token_rule_t desc_token_table[] = {$/;"	v	file:
description	or/config.c	/^  const char *description;$/;"	m	struct:config_var_description_t	file:
description	or/or.h	/^  char *description;$/;"	m	struct:trusted_dir_server_t
description	or/or.h	/^  const char *description;$/;"	m	struct:desc_store_t
description	or/routerlist.c	/^  char *description;$/;"	m	struct:routerset_t	file:
descriptor_cookie	or/or.h	/^  char descriptor_cookie[REND_DESC_COOKIE_LEN];$/;"	m	struct:rend_authorized_client_t
descriptor_cookie	or/or.h	/^  char descriptor_cookie[REND_DESC_COOKIE_LEN];$/;"	m	struct:rend_data_t
descriptor_cookie	or/or.h	/^  char descriptor_cookie[REND_DESC_COOKIE_LEN];$/;"	m	struct:rend_service_authorization_t
descriptor_digest	or/or.h	/^  char descriptor_digest[DIGEST256_LEN];$/;"	m	struct:routerstatus_t
desired_path_len	or/or.h	/^  int desired_path_len;$/;"	m	struct:__anon47
dest_address	or/or.h	/^  char *dest_address;$/;"	m	struct:origin_circuit_t
dest_port	or/or.h	/^  uint16_t dest_port;$/;"	m	struct:origin_circuit_t
destroy_chunks	common/mempool.c	/^destroy_chunks(mp_chunk_t *chunk)$/;"	f	file:
detached_get_digests	or/routerparse.c	/^detached_get_digests(ns_detached_signatures_t *sigs, const char *flavor_name)$/;"	f	file:
detached_get_signatures	or/routerparse.c	/^detached_get_signatures(ns_detached_signatures_t *sigs,$/;"	f	file:
detect_compression_method	common/torgzip.c	/^detect_compression_method(const char *in, size_t in_len)$/;"	f
dh	common/crypto.c	/^  DH *dh; \/**< The openssl DH object *\/$/;"	m	struct:crypto_dh_t	file:
dh_handshake_state	or/or.h	/^  crypto_dh_t *dh_handshake_state;$/;"	m	struct:crypt_path_t
dh_param_g	common/crypto.c	/^static BIGNUM *dh_param_g = NULL;$/;"	v	file:
dh_param_p	common/crypto.c	/^static BIGNUM *dh_param_p = NULL;$/;"	v	file:
dh_param_p_tls	common/crypto.c	/^static BIGNUM *dh_param_p_tls = NULL;$/;"	v	file:
did_circs_fail_last_period	or/circuituse.c	/^static int did_circs_fail_last_period = 0;$/;"	v	file:
did_last_state_file_write_fail	or/config.c	/^did_last_state_file_write_fail(void)$/;"	f
digest	or/dirvote.c	/^  const char *digest;$/;"	m	struct:dir_src_ent_t	file:
digest	or/or.h	/^  char digest[DIGEST256_LEN];$/;"	m	struct:microdesc_t
digest	or/or.h	/^  char digest[DIGEST_LEN]; \/**< Digest of identity key. *\/$/;"	m	struct:trusted_dir_server_t
digest256_from_base64	common/crypto.c	/^digest256_from_base64(char *digest, const char *d64)$/;"	f
digest256_to_base64	common/crypto.c	/^digest256_to_base64(char *d64, const char *digest)$/;"	f
digest_algorithm_t	common/crypto.h	/^} digest_algorithm_t;$/;"	t	typeref:enum:__anon10
digest_from_base64	common/crypto.c	/^digest_from_base64(char *digest, const char *d64)$/;"	f
digest_received	or/or.h	/^  crypto_digest_t *digest_received;$/;"	m	struct:or_handshake_state_t
digest_received_data	or/or.h	/^  unsigned int digest_received_data : 1;$/;"	m	struct:or_handshake_state_t
digest_sent	or/or.h	/^  crypto_digest_t *digest_sent;$/;"	m	struct:or_handshake_state_t
digest_sent_data	or/or.h	/^  unsigned int digest_sent_data : 1;$/;"	m	struct:or_handshake_state_t
digest_to_base64	common/crypto.c	/^digest_to_base64(char *d64, const char *digest)$/;"	f
digestmap_assert_ok	common/container.c	/^digestmap_assert_ok(const digestmap_t *map)$/;"	f
digestmap_entries_eq	common/container.c	/^digestmap_entries_eq(const digestmap_entry_t *a, const digestmap_entry_t *b)$/;"	f	file:
digestmap_entry_hash	common/container.c	/^digestmap_entry_hash(const digestmap_entry_t *a)$/;"	f	file:
digestmap_free	common/container.c	/^digestmap_free(digestmap_t *map, void (*free_val)(void*))$/;"	f
digestmap_get	common/container.c	/^digestmap_get(const digestmap_t *map, const char *key)$/;"	f
digestmap_isempty	common/container.c	/^digestmap_isempty(const digestmap_t *map)$/;"	f
digestmap_iter_done	common/container.c	/^digestmap_iter_done(digestmap_iter_t *iter)$/;"	f
digestmap_iter_get	common/container.c	/^digestmap_iter_get(digestmap_iter_t *iter, const char **keyp, void **valp)$/;"	f
digestmap_iter_init	common/container.c	/^digestmap_iter_init(digestmap_t *map)$/;"	f
digestmap_iter_next	common/container.c	/^digestmap_iter_next(digestmap_t *map, digestmap_iter_t *iter)$/;"	f
digestmap_iter_next_rmv	common/container.c	/^digestmap_iter_next_rmv(digestmap_t *map, digestmap_iter_t *iter)$/;"	f
digestmap_new	common/container.c	/^digestmap_new(void)$/;"	f
digestmap_remove	common/container.c	/^digestmap_remove(digestmap_t *map, const char *key)$/;"	f
digestmap_set	common/container.c	/^digestmap_set(digestmap_t *map, const char *key, void *val)$/;"	f
digestmap_size	common/container.c	/^digestmap_size(const digestmap_t *map)$/;"	f
digests	or/or.h	/^  digests_t digests; \/**< Digests of this object (networkstatus only) *\/$/;"	m	struct:cached_dir_t
digests	or/or.h	/^  digests_t digests;$/;"	m	struct:networkstatus_t
digests	or/or.h	/^  strmap_t *digests; \/**< Map from flavor name to digestset_t *\/$/;"	m	struct:ns_detached_signatures_t
digests	or/routerlist.c	/^  digestmap_t *digests;$/;"	m	struct:routerset_t	file:
digests_t	common/crypto.h	/^} digests_t;$/;"	t	typeref:struct:__anon11
digestset_add	common/container.h	/^digestset_add(digestset_t *set, const char *digest)$/;"	f
digestset_free	common/container.c	/^digestset_free(digestset_t *set)$/;"	f
digestset_isin	common/container.h	/^digestset_isin(const digestset_t *set, const char *digest)$/;"	f
digestset_t	common/container.h	/^} digestset_t;$/;"	t	typeref:struct:__anon8
digit_to_num	common/util.c	/^digit_to_num(char d)$/;"	f	file:
dir	or/or.h	/^  char *dir; \/**< Contents of this object, NUL-terminated. *\/$/;"	m	struct:cached_dir_t
dir_conn_purpose_to_string	or/directory.c	/^dir_conn_purpose_to_string(int purpose)$/;"	f	file:
dir_connection_new	or/connection.c	/^dir_connection_new(int socket_family)$/;"	f
dir_connection_t	or/or.h	/^typedef struct dir_connection_t {$/;"	s
dir_connection_t	or/or.h	/^} dir_connection_t;$/;"	t	typeref:struct:dir_connection_t
dir_footer_token_table	or/routerparse.c	/^static token_rule_t dir_footer_token_table[] = {$/;"	v	file:
dir_info_status	or/routerlist.c	/^static char dir_info_status[128] = "";$/;"	v	file:
dir_key_certificate_table	or/routerparse.c	/^static token_rule_t dir_key_certificate_table[] = {$/;"	v	file:
dir_len	or/or.h	/^  size_t dir_len; \/**< Length of <b>dir<\/b> (not counting its NUL). *\/$/;"	m	struct:cached_dir_t
dir_microdesc_download_failed	or/directory.c	/^dir_microdesc_download_failed(smartlist_t *failed,$/;"	f	file:
dir_networkstatus_download_failed	or/directory.c	/^dir_networkstatus_download_failed(smartlist_t *failed, int status_code)$/;"	f	file:
dir_policy	or/policies.c	/^static smartlist_t *dir_policy = NULL;$/;"	v	file:
dir_policy_permits_address	or/policies.c	/^dir_policy_permits_address(const tor_addr_t *addr)$/;"	f
dir_port	or/or.h	/^  uint16_t dir_port; \/**< Directory port for this router. *\/$/;"	m	struct:routerstatus_t
dir_port	or/or.h	/^  uint16_t dir_port; \/**< Directory port of this voter *\/$/;"	m	struct:networkstatus_voter_info_t
dir_port	or/or.h	/^  uint16_t dir_port; \/**< Directory port. *\/$/;"	m	struct:trusted_dir_server_t
dir_port	or/or.h	/^  uint16_t dir_port; \/**< Port for HTTP directory connections. *\/$/;"	m	struct:__anon41
dir_port	or/or.h	/^  uint16_t dir_port;$/;"	m	struct:authority_cert_t
dir_read_array	or/rephist.c	/^static bw_array_t *dir_read_array = NULL;$/;"	v	file:
dir_routerdesc_download_failed	or/directory.c	/^dir_routerdesc_download_failed(smartlist_t *failed, int status_code,$/;"	f	file:
dir_signing_key_is_trusted	or/routerparse.c	/^dir_signing_key_is_trusted(crypto_pk_t *key)$/;"	f	file:
dir_split_resource_into_fingerprint_pairs	or/directory.c	/^dir_split_resource_into_fingerprint_pairs(const char *res,$/;"	f
dir_split_resource_into_fingerprints	or/directory.c	/^dir_split_resource_into_fingerprints(const char *resource,$/;"	f
dir_spool_src	or/or.h	/^  } dir_spool_src : 3;$/;"	m	struct:dir_connection_t	typeref:enum:dir_connection_t::__anon37
dir_src_ent_t	or/dirvote.c	/^typedef struct dir_src_ent_t {$/;"	s	file:
dir_src_ent_t	or/dirvote.c	/^} dir_src_ent_t;$/;"	t	typeref:struct:dir_src_ent_t	file:
dir_tests	test/test_dir.c	/^struct testcase_t dir_tests[] = {$/;"	v	typeref:struct:testcase_t
dir_token_table	or/routerparse.c	/^static token_rule_t dir_token_table[] = {$/;"	v	file:
dir_write_array	or/rephist.c	/^static bw_array_t *dir_write_array = NULL;$/;"	v	file:
dir_z	or/or.h	/^  char *dir_z; \/**< Compressed contents of this object. *\/$/;"	m	struct:cached_dir_t
dir_z_len	or/or.h	/^  size_t dir_z_len; \/**< Length of <b>dir_z<\/b>. *\/$/;"	m	struct:cached_dir_t
dirconn_direct	or/or.h	/^  unsigned int dirconn_direct:1; \/**< Is this dirconn direct, or via Tor? *\/$/;"	m	struct:dir_connection_t
directories_have_accepted_server_descriptor	or/directory.c	/^directories_have_accepted_server_descriptor(void)$/;"	f
directory	or/rendservice.c	/^  char *directory; \/**< where in the filesystem it stores it *\/$/;"	m	struct:rend_service_t	file:
directory_all_unreachable	or/main.c	/^directory_all_unreachable(time_t now)$/;"	f
directory_caches_dir_info	or/dirserv.c	/^directory_caches_dir_info(const or_options_t *options)$/;"	f
directory_caches_v1_dir_info	or/dirserv.h	/^#define directory_caches_v1_dir_info(/;"	d
directory_caches_v2_dir_info	or/dirserv.c	/^directory_caches_v2_dir_info(const or_options_t *options)$/;"	f
directory_clean_last_hid_serv_requests	or/rendclient.c	/^directory_clean_last_hid_serv_requests(time_t now)$/;"	f	file:
directory_command_should_use_begindir	or/directory.c	/^directory_command_should_use_begindir(const or_options_t *options,$/;"	f	file:
directory_conn_is_self_reachability_test	or/directory.c	/^directory_conn_is_self_reachability_test(dir_connection_t *conn)$/;"	f	file:
directory_dump_request_log	or/directory.c	/^directory_dump_request_log(void)$/;"	f
directory_fetches_dir_info_early	or/dirserv.c	/^directory_fetches_dir_info_early(const or_options_t *options)$/;"	f
directory_fetches_dir_info_later	or/dirserv.c	/^directory_fetches_dir_info_later(const or_options_t *options)$/;"	f
directory_fetches_from_authorities	or/dirserv.c	/^directory_fetches_from_authorities(const or_options_t *options)$/;"	f
directory_get_consensus_url	or/directory.c	/^directory_get_consensus_url(int supports_conditional_consensus,$/;"	f	file:
directory_get_from_all_authorities	or/directory.c	/^directory_get_from_all_authorities(uint8_t dir_purpose,$/;"	f
directory_get_from_dirserver	or/directory.c	/^directory_get_from_dirserver(uint8_t dir_purpose, uint8_t router_purpose,$/;"	f
directory_get_from_hs_dir	or/rendclient.c	/^directory_get_from_hs_dir(const char *desc_id, const rend_data_t *rend_query)$/;"	f	file:
directory_handle_command	or/directory.c	/^directory_handle_command(dir_connection_t *conn)$/;"	f	file:
directory_handle_command_get	or/directory.c	/^directory_handle_command_get(dir_connection_t *conn, const char *headers,$/;"	f	file:
directory_handle_command_post	or/directory.c	/^directory_handle_command_post(dir_connection_t *conn, const char *headers,$/;"	f	file:
directory_info_has_arrived	or/main.c	/^directory_info_has_arrived(time_t now, int from_cache)$/;"	f
directory_initiate_command	or/directory.c	/^directory_initiate_command(const char *address, const tor_addr_t *_addr,$/;"	f
directory_initiate_command_rend	or/directory.c	/^directory_initiate_command_rend(const char *address, const tor_addr_t *_addr,$/;"	f	file:
directory_initiate_command_routerstatus	or/directory.c	/^directory_initiate_command_routerstatus(const routerstatus_t *status,$/;"	f
directory_initiate_command_routerstatus_rend	or/directory.c	/^directory_initiate_command_routerstatus_rend(const routerstatus_t *status,$/;"	f
directory_keyword	or/routerparse.c	/^} directory_keyword;$/;"	t	typeref:enum:__anon69	file:
directory_permits_begindir_requests	or/dirserv.c	/^directory_permits_begindir_requests(const or_options_t *options)$/;"	f
directory_permits_controller_requests	or/dirserv.c	/^directory_permits_controller_requests(const or_options_t *options)$/;"	f
directory_post_to_dirservers	or/directory.c	/^directory_post_to_dirservers(uint8_t dir_purpose, uint8_t router_purpose,$/;"	f
directory_post_to_hs_dir	or/rendservice.c	/^directory_post_to_hs_dir(rend_service_descriptor_t *renddesc,$/;"	f	file:
directory_remove_invalid	or/dirserv.c	/^directory_remove_invalid(void)$/;"	f	file:
directory_send_command	or/directory.c	/^directory_send_command(dir_connection_t *conn,$/;"	f	file:
directory_set_dirty	or/dirserv.c	/^directory_set_dirty(void)$/;"	f
directory_token_t	or/routerparse.c	/^typedef struct directory_token_t {$/;"	s	file:
directory_token_t	or/routerparse.c	/^} directory_token_t;$/;"	t	typeref:struct:directory_token_t	file:
directory_too_idle_to_fetch_descriptors	or/dirserv.c	/^directory_too_idle_to_fetch_descriptors(const or_options_t *options,$/;"	f
dirinfo_type_t	or/or.h	/^} dirinfo_type_t;$/;"	t	typeref:enum:__anon45
dirnum	common/OpenBSD_malloc_Linux.c	/^	u_long		dirnum;$/;"	m	struct:pdinfo	file:
dirreq_id	or/geoip.c	/^  uint64_t dirreq_id;$/;"	m	struct:dirreq_map_entry_t	file:
dirreq_id	or/or.h	/^  uint64_t dirreq_id;$/;"	m	struct:circuit_t
dirreq_id	or/or.h	/^  uint64_t dirreq_id;$/;"	m	struct:connection_t
dirreq_map_ent_eq	or/geoip.c	/^dirreq_map_ent_eq(const dirreq_map_entry_t *a,$/;"	f	file:
dirreq_map_ent_hash	or/geoip.c	/^dirreq_map_ent_hash(const dirreq_map_entry_t *entry)$/;"	f	file:
dirreq_map_entry_t	or/geoip.c	/^typedef struct dirreq_map_entry_t {$/;"	s	file:
dirreq_map_entry_t	or/geoip.c	/^} dirreq_map_entry_t;$/;"	t	typeref:struct:dirreq_map_entry_t	file:
dirreq_state_t	or/or.h	/^} dirreq_state_t;$/;"	t	typeref:enum:__anon62
dirreq_type_t	or/or.h	/^} dirreq_type_t;$/;"	t	typeref:enum:__anon61
dirserv_add_descriptor	or/dirserv.c	/^dirserv_add_descriptor(routerinfo_t *ri, const char **msg, const char *source)$/;"	f
dirserv_add_extrainfo	or/dirserv.c	/^dirserv_add_extrainfo(extrainfo_t *ei, const char **msg)$/;"	f	file:
dirserv_add_multiple_descriptors	or/dirserv.c	/^dirserv_add_multiple_descriptors(const char *desc, uint8_t purpose,$/;"	f
dirserv_add_own_fingerprint	or/dirserv.c	/^dirserv_add_own_fingerprint(const char *nickname, crypto_pk_t *pk)$/;"	f
dirserv_clear_old_networkstatuses	or/dirserv.c	/^dirserv_clear_old_networkstatuses(time_t cutoff)$/;"	f
dirserv_clear_old_v1_info	or/dirserv.c	/^dirserv_clear_old_v1_info(time_t now)$/;"	f
dirserv_compute_performance_thresholds	or/dirserv.c	/^dirserv_compute_performance_thresholds(routerlist_t *rl)$/;"	f	file:
dirserv_dump_directory_to_string	or/dirserv.c	/^dirserv_dump_directory_to_string(char **dir_out,$/;"	f
dirserv_estimate_data_size	or/dirserv.c	/^dirserv_estimate_data_size(smartlist_t *fps, int is_serverdescs,$/;"	f
dirserv_estimate_microdesc_size	or/dirserv.c	/^dirserv_estimate_microdesc_size(const smartlist_t *fps, int compressed)$/;"	f
dirserv_free_all	or/dirserv.c	/^dirserv_free_all(void)$/;"	f
dirserv_free_fingerprint_list	or/dirserv.c	/^dirserv_free_fingerprint_list(void)$/;"	f
dirserv_generate_networkstatus_vote_obj	or/dirserv.c	/^dirserv_generate_networkstatus_vote_obj(crypto_pk_t *private_key,$/;"	f
dirserv_get_consensus	or/dirserv.c	/^dirserv_get_consensus(const char *flavor_name)$/;"	f
dirserv_get_directory	or/dirserv.c	/^dirserv_get_directory(void)$/;"	f
dirserv_get_name_status	or/dirserv.c	/^dirserv_get_name_status(const char *id_digest, const char *nickname)$/;"	f	file:
dirserv_get_networkstatus_v2	or/dirserv.c	/^dirserv_get_networkstatus_v2(smartlist_t *result,$/;"	f
dirserv_get_networkstatus_v2_fingerprints	or/dirserv.c	/^dirserv_get_networkstatus_v2_fingerprints(smartlist_t *result,$/;"	f
dirserv_get_nickname_by_digest	or/dirserv.c	/^dirserv_get_nickname_by_digest(const char *digest)$/;"	f
dirserv_get_routerdesc_fingerprints	or/dirserv.c	/^dirserv_get_routerdesc_fingerprints(smartlist_t *fps_out, const char *key,$/;"	f
dirserv_get_routerdescs	or/dirserv.c	/^dirserv_get_routerdescs(smartlist_t *descs_out, const char *key,$/;"	f
dirserv_get_runningrouters	or/dirserv.c	/^dirserv_get_runningrouters(void)$/;"	f
dirserv_get_status_impl	or/dirserv.c	/^dirserv_get_status_impl(const char *id_digest, const char *nickname,$/;"	f	file:
dirserv_have_any_microdesc	or/dirserv.c	/^dirserv_have_any_microdesc(const smartlist_t *fps)$/;"	f
dirserv_have_any_serverdesc	or/dirserv.c	/^dirserv_have_any_serverdesc(smartlist_t *fps, int spool_src)$/;"	f
dirserv_load_fingerprint_file	or/dirserv.c	/^dirserv_load_fingerprint_file(void)$/;"	f
dirserv_orconn_tls_done	or/dirserv.c	/^dirserv_orconn_tls_done(const char *address,$/;"	f
dirserv_pick_cached_dir_obj	or/dirserv.c	/^dirserv_pick_cached_dir_obj(cached_dir_t *cache_src,$/;"	f	file:
dirserv_read_measured_bandwidths	or/dirserv.c	/^dirserv_read_measured_bandwidths(const char *from_file,$/;"	f
dirserv_regenerate_directory	or/dirserv.c	/^dirserv_regenerate_directory(void)$/;"	f	file:
dirserv_remove_old_statuses	or/dirserv.c	/^dirserv_remove_old_statuses(smartlist_t *fps, time_t cutoff)$/;"	f
dirserv_router_get_status	or/dirserv.c	/^dirserv_router_get_status(const routerinfo_t *router, const char **msg)$/;"	f
dirserv_router_has_valid_address	or/dirserv.c	/^dirserv_router_has_valid_address(routerinfo_t *ri)$/;"	f	file:
dirserv_set_cached_consensus_networkstatus	or/dirserv.c	/^dirserv_set_cached_consensus_networkstatus(const char *networkstatus,$/;"	f
dirserv_set_cached_directory	or/dirserv.c	/^dirserv_set_cached_directory(const char *directory, time_t published,$/;"	f
dirserv_set_cached_networkstatus_v2	or/dirserv.c	/^dirserv_set_cached_networkstatus_v2(const char *networkstatus,$/;"	f
dirserv_set_node_flags_from_authoritative_status	or/dirserv.c	/^dirserv_set_node_flags_from_authoritative_status(node_t *node,$/;"	f
dirserv_set_router_is_running	or/dirserv.c	/^dirserv_set_router_is_running(routerinfo_t *router, time_t now)$/;"	f
dirserv_should_launch_reachability_test	or/dirserv.c	/^dirserv_should_launch_reachability_test(const routerinfo_t *ri,$/;"	f
dirserv_single_reachability_test	or/dirserv.c	/^dirserv_single_reachability_test(time_t now, routerinfo_t *router)$/;"	f
dirserv_test_reachability	or/dirserv.c	/^dirserv_test_reachability(time_t now)$/;"	f
dirserv_thinks_router_is_hs_dir	or/dirserv.c	/^dirserv_thinks_router_is_hs_dir(const routerinfo_t *router,$/;"	f	file:
dirserv_thinks_router_is_unreliable	or/dirserv.c	/^dirserv_thinks_router_is_unreliable(time_t now,$/;"	f	file:
dirserv_would_reject_router	or/dirserv.c	/^dirserv_would_reject_router(const routerstatus_t *rs)$/;"	f
dirvote_act	or/dirvote.c	/^dirvote_act(const or_options_t *options, time_t now)$/;"	f
dirvote_add_signatures	or/dirvote.c	/^dirvote_add_signatures(const char *detached_signatures_body,$/;"	f
dirvote_add_signatures_to_all_pending_consensuses	or/dirvote.c	/^dirvote_add_signatures_to_all_pending_consensuses($/;"	f	file:
dirvote_add_signatures_to_pending_consensus	or/dirvote.c	/^dirvote_add_signatures_to_pending_consensus($/;"	f	file:
dirvote_add_vote	or/dirvote.c	/^dirvote_add_vote(const char *vote_body, const char **msg_out, int *status_out)$/;"	f
dirvote_clear_pending_consensuses	or/dirvote.c	/^dirvote_clear_pending_consensuses(void)$/;"	f	file:
dirvote_clear_votes	or/dirvote.c	/^dirvote_clear_votes(int all_votes)$/;"	f	file:
dirvote_compute_consensuses	or/dirvote.c	/^dirvote_compute_consensuses(void)$/;"	f	file:
dirvote_compute_params	or/dirvote.c	/^dirvote_compute_params(smartlist_t *votes, int method, int total_authorities)$/;"	f
dirvote_create_microdescriptor	or/dirvote.c	/^dirvote_create_microdescriptor(const routerinfo_t *ri)$/;"	f
dirvote_fetch_missing_signatures	or/dirvote.c	/^dirvote_fetch_missing_signatures(void)$/;"	f	file:
dirvote_fetch_missing_votes	or/dirvote.c	/^dirvote_fetch_missing_votes(void)$/;"	f	file:
dirvote_format_microdesc_vote_line	or/dirvote.c	/^dirvote_format_microdesc_vote_line(char *out, size_t out_len,$/;"	f
dirvote_free_all	or/dirvote.c	/^dirvote_free_all(void)$/;"	f
dirvote_get_pending_consensus	or/dirvote.c	/^dirvote_get_pending_consensus(consensus_flavor_t flav)$/;"	f
dirvote_get_pending_detached_signatures	or/dirvote.c	/^dirvote_get_pending_detached_signatures(void)$/;"	f
dirvote_get_preferred_voting_intervals	or/dirvote.c	/^dirvote_get_preferred_voting_intervals(vote_timing_t *timing_out)$/;"	f
dirvote_get_start_of_next_interval	or/dirvote.c	/^dirvote_get_start_of_next_interval(time_t now, int interval)$/;"	f
dirvote_get_vote	or/dirvote.c	/^dirvote_get_vote(const char *fp, int flags)$/;"	f
dirvote_perform_vote	or/dirvote.c	/^dirvote_perform_vote(void)$/;"	f	file:
dirvote_publish_consensus	or/dirvote.c	/^dirvote_publish_consensus(void)$/;"	f	file:
dirvote_recalculate_timing	or/dirvote.c	/^dirvote_recalculate_timing(const or_options_t *options, time_t now)$/;"	f
disable_broken_connection_counts	or/connection_or.c	/^static int disable_broken_connection_counts = 0;$/;"	v	file:
disable_control_logging	or/control.c	/^disable_control_logging(void)$/;"	f
disable_iocp	common/compat_libevent.h	/^  int disable_iocp;$/;"	m	struct:tor_libevent_cfg
disable_log_messages	or/control.c	/^static int disable_log_messages = 0;$/;"	v	file:
dist_delay	or/or.h	/^  int dist_delay;$/;"	m	struct:vote_timing_t
dist_seconds	or/or.h	/^  int dist_seconds;$/;"	m	struct:networkstatus_t
dl_failed	or/networkstatus.c	/^  int dl_failed;$/;"	m	struct:consensus_waiting_for_certs_t	file:
dl_status	or/or.h	/^  download_status_t dl_status;$/;"	m	struct:routerstatus_t
dl_status	or/routerlist.c	/^  download_status_t dl_status;$/;"	m	struct:cert_list_t	file:
dmalloc_strdup	common/util.c	/^ #define dmalloc_strdup(/;"	d	file:
dn_indicates_v3_cert	common/tortls.c	/^dn_indicates_v3_cert(X509_NAME *name)$/;"	f	file:
dns_cache_entry_count	or/dns.c	/^dns_cache_entry_count(void)$/;"	f	file:
dns_cancel_pending_resolve	or/dns.c	/^dns_cancel_pending_resolve(const char *address)$/;"	f
dns_clip_ttl	or/dns.c	/^dns_clip_ttl(uint32_t ttl)$/;"	f
dns_found_answer	or/dns.c	/^dns_found_answer(const char *address, uint8_t is_reverse, uint32_t addr,$/;"	f	file:
dns_free_all	or/dns.c	/^dns_free_all(void)$/;"	f
dns_get_expiry_ttl	or/dns.c	/^dns_get_expiry_ttl(uint32_t ttl)$/;"	f	file:
dns_init	or/dns.c	/^dns_init(void)$/;"	f
dns_is_completely_invalid	or/dns.c	/^static int dns_is_completely_invalid = 0;$/;"	v	file:
dns_launch_correctness_checks	or/dns.c	/^dns_launch_correctness_checks(void)$/;"	f
dns_launch_wildcard_checks	or/dns.c	/^dns_launch_wildcard_checks(void)$/;"	f	file:
dns_question_class	or/eventdns.h	/^	int dns_question_class;$/;"	m	struct:evdns_server_question
dns_reset	or/dns.c	/^dns_reset(void)$/;"	f
dns_reset_correctness_checks	or/dns.c	/^dns_reset_correctness_checks(void)$/;"	f
dns_resolve	or/dns.c	/^dns_resolve(edge_connection_t *exitconn)$/;"	f
dns_resolve_impl	or/dns.c	/^dns_resolve_impl(edge_connection_t *exitconn, int is_resolve,$/;"	f	file:
dns_seems_to_be_broken	or/dns.c	/^dns_seems_to_be_broken(void)$/;"	f
dns_server_port	or/or.h	/^  struct evdns_server_port *dns_server_port;$/;"	m	struct:listener_connection_t	typeref:struct:listener_connection_t::evdns_server_port
dns_server_request	or/or.h	/^  struct evdns_server_request *dns_server_request;$/;"	m	struct:entry_connection_t	typeref:struct:entry_connection_t::evdns_server_request
dns_servers_relaunch_checks	or/main.c	/^dns_servers_relaunch_checks(void)$/;"	f
dns_wildcard_list	or/dns.c	/^static smartlist_t *dns_wildcard_list = NULL;$/;"	v	file:
dns_wildcard_notice_given	or/dns.c	/^static int dns_wildcard_notice_given = 0;$/;"	v	file:
dns_wildcard_one_notice_given	or/dns.c	/^static int dns_wildcard_one_notice_given = 0;$/;"	v	file:
dns_wildcard_response_count	or/dns.c	/^static strmap_t *dns_wildcard_response_count = NULL;$/;"	v	file:
dns_wildcarded_test_address_list	or/dns.c	/^static smartlist_t *dns_wildcarded_test_address_list = NULL;$/;"	v	file:
dns_wildcarded_test_address_notice_given	or/dns.c	/^static int dns_wildcarded_test_address_notice_given = 0;$/;"	v	file:
dnslabel_clear	or/eventdns.c	/^dnslabel_clear(struct dnslabel_table *table)$/;"	f	file:
dnslabel_entry	or/eventdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	s	file:
dnslabel_table	or/eventdns.c	/^struct dnslabel_table {$/;"	s	file:
dnslabel_table_add	or/eventdns.c	/^dnslabel_table_add(struct dnslabel_table *table, const char *label, off_t pos)$/;"	f	file:
dnslabel_table_get_pos	or/eventdns.c	/^dnslabel_table_get_pos(const struct dnslabel_table *table, const char *label)$/;"	f	file:
dnslabel_table_init	or/eventdns.c	/^dnslabel_table_init(struct dnslabel_table *table)$/;"	f	file:
dnsname_to_labels	or/eventdns.c	/^dnsname_to_labels(u8 *const buf, size_t buf_len, off_t j,$/;"	f	file:
dnsserv_close_listener	or/dnsserv.c	/^dnsserv_close_listener(connection_t *conn)$/;"	f
dnsserv_configure_listener	or/dnsserv.c	/^dnsserv_configure_listener(connection_t *conn)$/;"	f
dnsserv_launch_request	or/dnsserv.c	/^dnsserv_launch_request(const char *name, int reverse)$/;"	f
dnsserv_reject_request	or/dnsserv.c	/^dnsserv_reject_request(entry_connection_t *conn)$/;"	f
dnsserv_resolved	or/dnsserv.c	/^dnsserv_resolved(entry_connection_t *conn,$/;"	f
do_hash_password	or/main.c	/^do_hash_password(void)$/;"	f
do_hup	or/main.c	/^do_hup(void)$/;"	f	file:
do_list_fingerprint	or/main.c	/^do_list_fingerprint(void)$/;"	f
do_main_loop	or/main.c	/^do_main_loop(void)$/;"	f
do_not_cache	or/or.h	/^  unsigned int do_not_cache : 1;$/;"	m	struct:signed_descriptor_t
do_resolve	tools/tor-resolve.c	/^do_resolve(const char *hostname, uint32_t sockshost, uint16_t socksport,$/;"	f	file:
document_signature_dup	or/networkstatus.c	/^document_signature_dup(const document_signature_t *sig)$/;"	f
document_signature_free	or/networkstatus.c	/^document_signature_free(document_signature_t *sig)$/;"	f
document_signature_t	or/or.h	/^typedef struct document_signature_t {$/;"	s
document_signature_t	or/or.h	/^} document_signature_t;$/;"	t	typeref:struct:document_signature_t
domain	common/log.c	/^  log_domain_mask_t domain; \/**< The domain of the message *\/$/;"	m	struct:pending_cb_message_t	file:
domain_list	common/log.c	/^static const char *domain_list[] = {$/;"	v	file:
domain_to_string	common/log.c	/^domain_to_string(log_domain_mask_t domain, char *buf, size_t buflen)$/;"	f	file:
down_since	or/rephist.c	/^  time_t down_since;$/;"	m	struct:or_history_t	file:
download_schedule_t	or/or.h	/^} download_schedule_t;$/;"	t	typeref:enum:__anon40
download_status_failed	or/directory.h	/^#define download_status_failed(/;"	d
download_status_get_n_failures	or/directory.c	/^download_status_get_n_failures(const download_status_t *dls)$/;"	f
download_status_increment_failure	or/directory.c	/^download_status_increment_failure(download_status_t *dls, int status_code,$/;"	f
download_status_is_ready	or/directory.h	/^download_status_is_ready(download_status_t *dls, time_t now,$/;"	f
download_status_map_update_from_v2_networkstatus	or/networkstatus.c	/^download_status_map_update_from_v2_networkstatus(void)$/;"	f	file:
download_status_mark_impossible	or/directory.h	/^download_status_mark_impossible(download_status_t *dl)$/;"	f
download_status_reset	or/directory.c	/^download_status_reset(download_status_t *dls)$/;"	f
download_status_t	or/or.h	/^typedef struct download_status_t {$/;"	s
download_status_t	or/or.h	/^} download_status_t;$/;"	t	typeref:struct:download_status_t
downtime	or/rephist.c	/^  unsigned long downtime;$/;"	m	struct:or_history_t	file:
dst_wildcard	or/connection_edge.c	/^  unsigned dst_wildcard:1;$/;"	m	struct:__anon22	file:
dump_cell_pool_usage	or/relay.c	/^dump_cell_pool_usage(int severity)$/;"	f
dump_desc	or/routerparse.c	/^dump_desc(const char *desc, const char *type)$/;"	f	file:
dump_distinct_digest_count	or/routerparse.c	/^dump_distinct_digest_count(int severity)$/;"	f
dump_dns_mem_usage	or/dns.c	/^dump_dns_mem_usage(int severity)$/;"	f
dump_microdescriptor	or/microdesc.c	/^dump_microdescriptor(FILE *f, microdesc_t *md, size_t *annotation_len_out)$/;"	f	file:
dump_pk_ops	or/rephist.c	/^dump_pk_ops(int severity)$/;"	f
dump_routerlist_mem_usage	or/routerlist.c	/^dump_routerlist_mem_usage(int severity)$/;"	f
dumpmemusage	or/main.c	/^dumpmemusage(int severity)$/;"	f	file:
dumpstats	or/main.c	/^dumpstats(int severity)$/;"	f	file:
dup_onion_keys	or/router.c	/^dup_onion_keys(crypto_pk_t **key, crypto_pk_t **last)$/;"	f
duration	or/routerlist.c	/^  int duration;$/;"	m	struct:duration_idx_t	file:
duration_idx_t	or/routerlist.c	/^struct duration_idx_t {$/;"	s	file:
e	common/procmon.c	/^  struct event *e;$/;"	m	struct:tor_process_monitor_t	typeref:struct:tor_process_monitor_t::event	file:
eat_whitespace	common/util.c	/^eat_whitespace(const char *s)$/;"	f
eat_whitespace_eos	common/util.c	/^eat_whitespace_eos(const char *s, const char *eos)$/;"	f
eat_whitespace_eos_no_nl	common/util.c	/^eat_whitespace_eos_no_nl(const char *s, const char *eos)$/;"	f
eat_whitespace_no_nl	common/util.c	/^eat_whitespace_no_nl(const char *s)$/;"	f
edge_blocked_on_circ	or/or.h	/^  unsigned int edge_blocked_on_circ:1;$/;"	m	struct:edge_connection_t
edge_connection_new	or/connection.c	/^edge_connection_new(int type, int socket_family)$/;"	f
edge_connection_t	or/or.h	/^typedef struct edge_connection_t {$/;"	s
edge_connection_t	or/or.h	/^} edge_connection_t;$/;"	t	typeref:struct:edge_connection_t
edge_has_sent_end	or/or.h	/^  unsigned int edge_has_sent_end:1; \/**< For debugging; only used on edge$/;"	m	struct:edge_connection_t
edge_of_accounting_period_containing	or/hibernate.c	/^edge_of_accounting_period_containing(time_t now, int get_end)$/;"	f	file:
edge_reason_is_retriable	or/relay.c	/^edge_reason_is_retriable(int reason)$/;"	f	file:
ei_dl_status	or/or.h	/^  download_status_t ei_dl_status;$/;"	m	struct:signed_descriptor_t
empty_chunks	common/mempool.h	/^  struct mp_chunk_t *empty_chunks;$/;"	m	struct:mp_pool_t	typeref:struct:mp_pool_t::mp_chunk_t
enable_control_logging	or/control.c	/^enable_control_logging(void)$/;"	f
enabled	test/bench.c	/^  int enabled;$/;"	m	struct:benchmark_t	file:
encoded	common/tortls.c	/^  uint8_t *encoded;$/;"	m	struct:tor_cert_t	file:
encoded_len	common/tortls.c	/^  size_t encoded_len;$/;"	m	struct:tor_cert_t	file:
end_reason	or/or.h	/^  uint16_t end_reason;$/;"	m	struct:edge_connection_t
enough_mtbf_info	or/dirserv.c	/^static int enough_mtbf_info = 0;$/;"	v	file:
ensure_bandwidth_cap	or/config.c	/^ensure_bandwidth_cap(uint64_t *value, const char *desc, char **msg)$/;"	f	file:
ensure_request_map_initialized	or/directory.c	/^ensure_request_map_initialized(void)$/;"	f	file:
enter_v3_handshake_with_cell	or/command.c	/^enter_v3_handshake_with_cell(var_cell_t *cell, or_connection_t *conn)$/;"	f	file:
entries	or/or.h	/^  short_policy_entry_t entries[FLEXIBLE_ARRAY_MEMBER];$/;"	m	struct:short_policy_t
entries	or/or.h	/^  smartlist_t *entries; \/**< List of routerstatus_t*.   This list is kept$/;"	m	struct:networkstatus_v2_t
entries_known_but_down	or/circuitbuild.c	/^entries_known_but_down(const or_options_t *options)$/;"	f
entries_retry_all	or/circuitbuild.c	/^entries_retry_all(const or_options_t *options)$/;"	f
entries_retry_helper	or/circuitbuild.c	/^entries_retry_helper(const or_options_t *options, int act)$/;"	f	file:
entry_connection_new	or/connection.c	/^entry_connection_new(int type, int socket_family)$/;"	f
entry_connection_t	or/or.h	/^typedef struct entry_connection_t {$/;"	s
entry_connection_t	or/or.h	/^} entry_connection_t;$/;"	t	typeref:struct:entry_connection_t
entry_guard_free	or/circuitbuild.c	/^entry_guard_free(entry_guard_t *e)$/;"	f	file:
entry_guard_register_connect_status	or/circuitbuild.c	/^entry_guard_register_connect_status(const char *digest, int succeeded,$/;"	f
entry_guard_set_status	or/circuitbuild.c	/^entry_guard_set_status(entry_guard_t *e, const node_t *node,$/;"	f	file:
entry_guard_t	or/circuitbuild.c	/^} entry_guard_t;$/;"	t	typeref:struct:__anon18	file:
entry_guards	or/circuitbuild.c	/^static smartlist_t *entry_guards = NULL;$/;"	v	file:
entry_guards_changed	or/circuitbuild.c	/^entry_guards_changed(void)$/;"	f	file:
entry_guards_compute_status	or/circuitbuild.c	/^entry_guards_compute_status(const or_options_t *options, time_t now)$/;"	f
entry_guards_dirty	or/circuitbuild.c	/^static int entry_guards_dirty = 0;$/;"	v	file:
entry_guards_free_all	or/circuitbuild.c	/^entry_guards_free_all(void)$/;"	f
entry_guards_parse_state	or/circuitbuild.c	/^entry_guards_parse_state(or_state_t *state, int set, char **msg)$/;"	f
entry_guards_set_from_config	or/circuitbuild.c	/^entry_guards_set_from_config(const or_options_t *options)$/;"	f	file:
entry_guards_update_state	or/circuitbuild.c	/^entry_guards_update_state(or_state_t *state)$/;"	f
entry_is_live	or/circuitbuild.c	/^entry_is_live(entry_guard_t *e, int need_uptime, int need_capacity,$/;"	f	file:
entry_is_time_to_retry	or/circuitbuild.c	/^entry_is_time_to_retry(entry_guard_t *e, time_t now)$/;"	f	file:
entry_list_is_constrained	or/circuitbuild.c	/^entry_list_is_constrained(const or_options_t *options)$/;"	f
entry_nodes_should_be_added	or/circuitbuild.c	/^entry_nodes_should_be_added(void)$/;"	f
environment_variable_names_equal	common/util.c	/^environment_variable_names_equal(const char *s1, const char *s2)$/;"	f
errno_to_orconn_end_reason	or/reasons.c	/^errno_to_orconn_end_reason(int e)$/;"	f
errno_to_stream_end_reason	or/reasons.c	/^errno_to_stream_end_reason(int e)$/;"	f
error	or/routerparse.c	/^  char *error;                 \/**< For _ERR tokens only. *\/$/;"	m	struct:directory_token_t	file:
error_is_eagain	or/eventdns.c	/^#define error_is_eagain(/;"	d	file:
error_is_eagain	or/eventdns.c	/^error_is_eagain(int err)$/;"	f	file:
esc_for_log	common/util.c	/^esc_for_log(const char *s)$/;"	f
esc_router_info	or/routerlist.c	/^esc_router_info(const routerinfo_t *router)$/;"	f
escaped	common/util.c	/^escaped(const char *s)$/;"	f
escaped_safe_str	or/config.c	/^escaped_safe_str(const char *address)$/;"	f
escaped_safe_str_client	or/config.c	/^escaped_safe_str_client(const char *address)$/;"	f
ev	common/compat_libevent.c	/^  struct event *ev;$/;"	m	struct:periodic_timer_t	typeref:struct:periodic_timer_t::event	file:
evaluate_ctr_for_aes	common/aes.c	/^evaluate_ctr_for_aes(void)$/;"	f
evaluate_evp_for_aes	common/aes.c	/^evaluate_evp_for_aes(int force_val)$/;"	f
evbuffer_inbuf_callback	or/connection.c	/^evbuffer_inbuf_callback(struct evbuffer *buf,$/;"	f	file:
evbuffer_outbuf_callback	or/connection.c	/^evbuffer_outbuf_callback(struct evbuffer *buf,$/;"	f	file:
evdns_add_server_port	or/eventdns.c	/^evdns_add_server_port(tor_socket_t socket, int is_tcp, evdns_request_callback_fn_type cb, void *user_data)$/;"	f
evdns_base_clear_nameservers_and_suspend	or/dns.c	/^#define evdns_base_clear_nameservers_and_suspend(/;"	d	file:
evdns_base_config_windows_nameservers	or/dns.c	/^#define evdns_base_config_windows_nameservers(/;"	d	file:
evdns_base_count_nameservers	or/dns.c	/^#define evdns_base_count_nameservers(/;"	d	file:
evdns_base_new	or/dns.c	/^#define evdns_base_new(/;"	d	file:
evdns_base_resolv_conf_parse	or/dns.c	/^#define evdns_base_resolv_conf_parse(/;"	d	file:
evdns_base_resolve_ipv4	or/dns.c	/^#define evdns_base_resolve_ipv4(/;"	d	file:
evdns_base_resolve_reverse	or/dns.c	/^#define evdns_base_resolve_reverse(/;"	d	file:
evdns_base_resolve_reverse_ipv6	or/dns.c	/^#define evdns_base_resolve_reverse_ipv6(/;"	d	file:
evdns_base_resume	or/dns.c	/^#define evdns_base_resume(/;"	d	file:
evdns_base_search_clear	or/dns.c	/^#define evdns_base_search_clear(/;"	d	file:
evdns_base_set_default_outgoing_bind_address	or/dns.c	/^#define evdns_base_set_default_outgoing_bind_address(/;"	d	file:
evdns_base_set_option_	or/dns.c	/^#define evdns_base_set_option_ /;"	d	file:
evdns_base_set_option_	or/dns.c	/^#define evdns_base_set_option_(/;"	d	file:
evdns_callback	or/dns.c	/^evdns_callback(int result, char type, int count, int ttl, void *addresses,$/;"	f	file:
evdns_callback_type	or/eventdns.h	/^typedef void (*evdns_callback_type) (int result, char type, int count, int ttl, void *addresses, void *arg);$/;"	t
evdns_clear_nameservers_and_suspend	or/eventdns.c	/^evdns_clear_nameservers_and_suspend(void)$/;"	f
evdns_close_server_port	or/eventdns.c	/^evdns_close_server_port(struct evdns_server_port *port)$/;"	f
evdns_config_windows_nameservers	or/eventdns.c	/^evdns_config_windows_nameservers(void)$/;"	f
evdns_count_nameservers	or/eventdns.c	/^evdns_count_nameservers(void)$/;"	f
evdns_debug_log_fn_type	or/eventdns.h	/^typedef void (*evdns_debug_log_fn_type)(int is_warning, const char *msg);$/;"	t
evdns_err_is_transient	or/dns.c	/^evdns_err_is_transient(int err)$/;"	f	file:
evdns_err_to_string	or/eventdns.c	/^evdns_err_to_string(int err)$/;"	f
evdns_get_orig_address	or/dnsserv.c	/^evdns_get_orig_address(const struct evdns_server_request *req,$/;"	f	file:
evdns_init	or/eventdns.c	/^evdns_init(void)$/;"	f
evdns_log_cb	or/dns.c	/^evdns_log_cb(int warn, const char *msg)$/;"	f	file:
evdns_log_fn	or/eventdns.c	/^static evdns_debug_log_fn_type evdns_log_fn = NULL;$/;"	v	file:
evdns_nameserver_add	or/eventdns.c	/^evdns_nameserver_add(uint32_t address) {$/;"	f
evdns_nameserver_ip_add	or/eventdns.c	/^evdns_nameserver_ip_add(const char *ip_as_string) {$/;"	f
evdns_nameserver_ip_add_line	or/eventdns.c	/^evdns_nameserver_ip_add_line(const char *ips) {$/;"	f	file:
evdns_nameserver_sockaddr_add	or/eventdns.c	/^evdns_nameserver_sockaddr_add(const struct sockaddr *sa, socklen_t len)$/;"	f
evdns_request	or/eventdns.c	/^struct evdns_request {$/;"	s	file:
evdns_request_callback_fn_type	or/eventdns.h	/^typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, void *);$/;"	t
evdns_request_data_build	or/eventdns.c	/^evdns_request_data_build(const char *const name, const size_t name_len,$/;"	f	file:
evdns_request_insert	or/eventdns.c	/^evdns_request_insert(struct evdns_request *req, struct evdns_request **head) {$/;"	f	file:
evdns_request_len	or/eventdns.c	/^evdns_request_len(const size_t name_len) {$/;"	f	file:
evdns_request_timeout_callback	or/eventdns.c	/^evdns_request_timeout_callback(int fd, short events, void *arg) {$/;"	f	file:
evdns_request_transmit	or/eventdns.c	/^evdns_request_transmit(struct evdns_request *req) {$/;"	f	file:
evdns_request_transmit_to	or/eventdns.c	/^evdns_request_transmit_to(struct evdns_request *req, struct nameserver *server) {$/;"	f	file:
evdns_requests_pump_waiting_queue	or/eventdns.c	/^evdns_requests_pump_waiting_queue(void) {$/;"	f	file:
evdns_resolv_conf_parse	or/eventdns.c	/^evdns_resolv_conf_parse(int flags, const char *const filename) {$/;"	f
evdns_resolv_set_defaults	or/eventdns.c	/^evdns_resolv_set_defaults(int flags) {$/;"	f	file:
evdns_resolve_ipv4	or/eventdns.c	/^int evdns_resolve_ipv4(const char *name, int flags,$/;"	f
evdns_resolve_ipv6	or/eventdns.c	/^int evdns_resolve_ipv6(const char *name, int flags,$/;"	f
evdns_resolve_reverse	or/eventdns.c	/^int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_resolve_reverse_ipv6	or/eventdns.c	/^int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr) {$/;"	f
evdns_resume	or/eventdns.c	/^evdns_resume(void)$/;"	f
evdns_search_add	or/eventdns.c	/^evdns_search_add(const char *domain) {$/;"	f
evdns_search_clear	or/eventdns.c	/^evdns_search_clear(void) {$/;"	f
evdns_search_ndots_set	or/eventdns.c	/^evdns_search_ndots_set(const int ndots) {$/;"	f
evdns_server_callback	or/dnsserv.c	/^evdns_server_callback(struct evdns_server_request *req, void *data_)$/;"	f	file:
evdns_server_callback	or/eventdns.c	/^evdns_server_callback(struct evdns_server_request *req, void *data)$/;"	f
evdns_server_port	or/eventdns.c	/^struct evdns_server_port {$/;"	s	file:
evdns_server_question	or/eventdns.h	/^struct evdns_server_question {$/;"	s
evdns_server_request	or/eventdns.h	/^struct evdns_server_request {$/;"	s
evdns_server_request_add_a_reply	or/eventdns.c	/^evdns_server_request_add_a_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f
evdns_server_request_add_aaaa_reply	or/eventdns.c	/^evdns_server_request_add_aaaa_reply(struct evdns_server_request *req, const char *name, int n, const void *addrs, int ttl)$/;"	f
evdns_server_request_add_cname_reply	or/eventdns.c	/^evdns_server_request_add_cname_reply(struct evdns_server_request *req, const char *name, const char *cname, int ttl)$/;"	f
evdns_server_request_add_ptr_reply	or/eventdns.c	/^evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)$/;"	f
evdns_server_request_add_reply	or/eventdns.c	/^evdns_server_request_add_reply(struct evdns_server_request *_req, int section, const char *name, int type, int class, int ttl, int datalen, int is_name, const char *data)$/;"	f
evdns_server_request_drop	or/eventdns.c	/^evdns_server_request_drop(struct evdns_server_request *_req)$/;"	f
evdns_server_request_format_response	or/eventdns.c	/^evdns_server_request_format_response(struct server_request *req, int err)$/;"	f	file:
evdns_server_request_get_requesting_addr	or/eventdns.c	/^evdns_server_request_get_requesting_addr(struct evdns_server_request *_req, struct sockaddr *sa, int addr_len)$/;"	f
evdns_server_request_respond	or/eventdns.c	/^evdns_server_request_respond(struct evdns_server_request *_req, int err)$/;"	f
evdns_set_default_outgoing_bind_address	or/eventdns.c	/^evdns_set_default_outgoing_bind_address(const struct sockaddr *addr,$/;"	f
evdns_set_log_fn	or/eventdns.c	/^evdns_set_log_fn(evdns_debug_log_fn_type fn)$/;"	f
evdns_set_option	or/eventdns.c	/^evdns_set_option(const char *option, const char *val, int flags)$/;"	f
evdns_set_random_bytes_fn	or/eventdns.c	/^evdns_set_random_bytes_fn(void (*fn)(char *, size_t))$/;"	f
evdns_set_transaction_id_fn	or/eventdns.c	/^evdns_set_transaction_id_fn(uint16_t (*fn)(void))$/;"	f
evdns_shutdown	or/eventdns.c	/^evdns_shutdown(int fail_requests)$/;"	f
evdns_transmit	or/eventdns.c	/^evdns_transmit(void) {$/;"	f	file:
evdns_wildcard_check_callback	or/dns.c	/^evdns_wildcard_check_callback(int result, char type, int count, int ttl,$/;"	f	file:
event	or/eventdns.c	/^	struct event event; \/* Read\/write event *\/$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::event	file:
event	or/eventdns.c	/^	struct event event;$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:
event_code	or/control.c	/^  uint16_t event_code;$/;"	m	struct:control_event_t	file:
event_format_t	or/control.c	/^typedef int event_format_t;$/;"	t	file:
event_mask	or/or.h	/^  uint32_t event_mask; \/**< Bitfield: which events does this controller$/;"	m	struct:control_connection_t
event_mask_t	or/control.c	/^typedef uint32_t event_mask_t;$/;"	t	file:
event_name	or/control.c	/^  const char *event_name;$/;"	m	struct:control_event_t	file:
event_to_log_severity	or/control.c	/^event_to_log_severity(int event)$/;"	f	file:
evp	common/aes.c	/^    EVP_CIPHER_CTX evp;$/;"	m	union:aes_cnt_cipher::__anon3	file:
evp	common/aes.c	/^  EVP_CIPHER_CTX evp;$/;"	m	struct:aes_cnt_cipher	file:
evp_block128_fn	common/aes.c	/^static void evp_block128_fn(const uint8_t in[16],$/;"	f	file:
evutil_socket_t	common/compat_libevent.h	/^#define evutil_socket_t /;"	d
ewma_enabled	or/relay.c	/^static int ewma_enabled = 0;$/;"	v	file:
ewma_scale_factor	or/relay.c	/^static double ewma_scale_factor = 0.1;$/;"	v	file:
exit_bytes_read	or/rephist.c	/^static uint64_t *exit_bytes_read = NULL;$/;"	v	file:
exit_bytes_written	or/rephist.c	/^static uint64_t *exit_bytes_written = NULL;$/;"	v	file:
exit_function	or/main.c	/^exit_function(void)$/;"	f	file:
exit_policy	or/or.h	/^  short_policy_t *exit_policy;$/;"	m	struct:microdesc_t
exit_policy	or/or.h	/^  smartlist_t *exit_policy; \/**< What streams will this OR permit$/;"	m	struct:__anon41
exit_policy_is_general_exit	or/policies.c	/^exit_policy_is_general_exit(smartlist_t *policy)$/;"	f
exit_policy_is_general_exit_helper	or/policies.c	/^exit_policy_is_general_exit_helper(smartlist_t *policy, int port)$/;"	f	file:
exit_policy_remove_redundancies	or/policies.c	/^exit_policy_remove_redundancies(smartlist_t *dest)$/;"	f	file:
exit_streams	or/rephist.c	/^static uint32_t *exit_streams = NULL;$/;"	v	file:
exitsummary	or/or.h	/^  char *exitsummary; \/**< exit policy summary -$/;"	m	struct:routerstatus_t
expand_abbrev	or/config.c	/^expand_abbrev(const config_format_t *fmt, const char *option, int command_line,$/;"	f	file:
expand_filename	common/util.c	/^expand_filename(const char *filename)$/;"	f
expected_bandwidth_usage	or/hibernate.c	/^static uint64_t expected_bandwidth_usage = 0;$/;"	v	file:
expire	or/dns.c	/^  time_t expire; \/**< Remove items from cache after this time. *\/$/;"	m	struct:cached_resolve_t	file:
expires	or/connection_edge.c	/^  time_t expires;$/;"	m	struct:__anon22	file:
expires	or/or.h	/^  time_t expires;$/;"	m	struct:authority_cert_t
expiry_time	or/or.h	/^  time_t expiry_time;$/;"	m	struct:__anon47
extend_info	or/or.h	/^  extend_info_t *extend_info; \/**< Extend info of this introduction point. *\/$/;"	m	struct:rend_intro_point_t
extend_info	or/or.h	/^  extend_info_t *extend_info;$/;"	m	struct:crypt_path_t
extend_info_alloc	or/circuitbuild.c	/^extend_info_alloc(const char *nickname, const char *digest,$/;"	f
extend_info_describe	or/router.c	/^extend_info_describe(const extend_info_t *ei)$/;"	f
extend_info_dup	or/circuitbuild.c	/^extend_info_dup(extend_info_t *info)$/;"	f
extend_info_free	or/circuitbuild.c	/^extend_info_free(extend_info_t *info)$/;"	f
extend_info_from_node	or/circuitbuild.c	/^extend_info_from_node(const node_t *node, int for_direct_connect)$/;"	f
extend_info_from_router	or/circuitbuild.c	/^extend_info_from_router(const routerinfo_t *r, int for_direct_connect)$/;"	f
extend_info_get_description	or/router.c	/^extend_info_get_description(char *buf, const extend_info_t *ei)$/;"	f
extend_info_t	or/or.h	/^typedef struct extend_info_t {$/;"	s
extend_info_t	or/or.h	/^} extend_info_t;$/;"	t	typeref:struct:extend_info_t
external_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t external_port;$/;"	m	struct:__anon72
extra	or/config.c	/^  config_var_t *extra;$/;"	m	struct:__anon21	file:
extra_info_digest	or/or.h	/^  char extra_info_digest[DIGEST_LEN];$/;"	m	struct:signed_descriptor_t
extra_info_map	or/or.h	/^  struct digest_ei_map_t *extra_info_map;$/;"	m	struct:__anon44	typeref:struct:__anon44::digest_ei_map_t
extract_escaped_string	or/control.c	/^extract_escaped_string(const char *start, size_t in_len_max,$/;"	f	file:
extrainfo_dump_to_string	or/router.c	/^extrainfo_dump_to_string(char **s_out, extrainfo_t *extrainfo,$/;"	f
extrainfo_free	or/routerlist.c	/^extrainfo_free(extrainfo_t *extrainfo)$/;"	f
extrainfo_get_by_descriptor_digest	or/routerlist.c	/^extrainfo_get_by_descriptor_digest(const char *digest)$/;"	f
extrainfo_insert	or/routerlist.c	/^extrainfo_insert(routerlist_t *rl, extrainfo_t *ei)$/;"	f	file:
extrainfo_is_bogus	or/or.h	/^  unsigned int extrainfo_is_bogus : 1;$/;"	m	struct:signed_descriptor_t
extrainfo_parse_entry_from_string	or/routerparse.c	/^extrainfo_parse_entry_from_string(const char *s, const char *end,$/;"	f
extrainfo_store	or/or.h	/^  desc_store_t extrainfo_store;$/;"	m	struct:__anon44
extrainfo_t	or/or.h	/^typedef struct extrainfo_t {$/;"	s
extrainfo_t	or/or.h	/^} extrainfo_t;$/;"	t	typeref:struct:extrainfo_t
extrainfo_token_table	or/routerparse.c	/^static token_rule_t extrainfo_token_table[] = {$/;"	v	file:
f_crypto	or/or.h	/^  crypto_cipher_t *f_crypto;$/;"	m	struct:crypt_path_t
f_digest	or/or.h	/^  crypto_digest_t *f_digest; \/* for integrity checking *\/$/;"	m	struct:crypt_path_t
failed_times	or/eventdns.c	/^	int failed_times;  \/* number of times which we have given this server a chance *\/$/;"	m	struct:nameserver	file:
failure_count	or/or.h	/^  int failure_count;$/;"	m	struct:__anon47
fake_status	or/or.h	/^  routerstatus_t fake_status; \/**< Used when we need to pass this trusted$/;"	m	struct:trusted_dir_server_t
family	common/address.h	/^  sa_family_t family;$/;"	m	struct:tor_addr_t
family	or/or.h	/^  smartlist_t *family;$/;"	m	struct:microdesc_t
fascist_firewall_allows_address_dir	or/policies.c	/^fascist_firewall_allows_address_dir(const tor_addr_t *addr, uint16_t port)$/;"	f
fascist_firewall_allows_address_or	or/policies.c	/^fascist_firewall_allows_address_or(const tor_addr_t *addr, uint16_t port)$/;"	f
fascist_firewall_allows_node	or/policies.c	/^fascist_firewall_allows_node(const node_t *node)$/;"	f
fascist_firewall_allows_or	or/policies.c	/^fascist_firewall_allows_or(const routerinfo_t *ri)$/;"	f
fast_bandwidth	or/dirserv.c	/^static uint32_t fast_bandwidth = 0;$/;"	v	file:
fast_client_handshake	or/onion.c	/^fast_client_handshake(const uint8_t *handshake_state,\/*DIGEST_LEN bytes*\/$/;"	f
fast_handshake_state	or/or.h	/^  uint8_t fast_handshake_state[DIGEST_LEN];$/;"	m	struct:crypt_path_t
fast_memcmp	common/di_ops.h	/^#define fast_memcmp(/;"	d
fast_memcmpstart	common/util.c	/^fast_memcmpstart(const void *mem, size_t memlen,$/;"	f
fast_memeq	common/di_ops.h	/^#define fast_memeq(/;"	d
fast_memneq	common/di_ops.h	/^#define fast_memneq(/;"	d
fast_server_handshake	or/onion.c	/^fast_server_handshake(const uint8_t *key_in, \/* DIGEST_LEN bytes *\/$/;"	f
fd	common/compat.c	/^  int fd;$/;"	m	struct:tor_lockfile_t	file:
fd	common/log.c	/^  int fd; \/**< fd to receive log messages, or -1 for none. *\/$/;"	m	struct:logfile_t	file:
fd	common/util.c	/^  int fd; \/**< fd for the open file. *\/$/;"	m	struct:open_file_t	file:
fdopen_file	common/util.c	/^fdopen_file(open_file_t *file_data)$/;"	f
fetch_bridge_descriptors	or/circuitbuild.c	/^fetch_bridge_descriptors(const or_options_t *options, time_t now)$/;"	f
fetch_from_buf	or/buffers.c	/^fetch_from_buf(char *string, size_t string_len, buf_t *buf)$/;"	f
fetch_from_buf_http	or/buffers.c	/^fetch_from_buf_http(buf_t *buf,$/;"	f
fetch_from_buf_line	or/buffers.c	/^fetch_from_buf_line(buf_t *buf, char *data_out, size_t *data_len)$/;"	f
fetch_from_buf_socks	or/buffers.c	/^fetch_from_buf_socks(buf_t *buf, socks_request_t *req,$/;"	f
fetch_from_buf_socks_client	or/buffers.c	/^fetch_from_buf_socks_client(buf_t *buf, int state, char **reason)$/;"	f
fetch_from_evbuffer_http	or/buffers.c	/^fetch_from_evbuffer_http(struct evbuffer *buf,$/;"	f
fetch_from_evbuffer_socks	or/buffers.c	/^fetch_from_evbuffer_socks(struct evbuffer *buf, socks_request_t *req,$/;"	f
fetch_from_evbuffer_socks_client	or/buffers.c	/^fetch_from_evbuffer_socks_client(struct evbuffer *buf, int state,$/;"	f
fetch_missing_signatures	or/dirvote.c	/^  time_t fetch_missing_signatures;$/;"	m	struct:__anon25	file:
fetch_missing_votes	or/dirvote.c	/^  time_t fetch_missing_votes;$/;"	m	struct:__anon25	file:
fetch_public_ip	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  int fetch_public_ip;$/;"	m	struct:natpmp_state_t
fetch_public_ip	tools/tor-fw-helper/tor-fw-helper.h	/^  int (*fetch_public_ip)(tor_fw_options_t *options, void *backend_state);$/;"	m	struct:tor_fw_backend_t
fetch_public_ip	tools/tor-fw-helper/tor-fw-helper.h	/^  int fetch_public_ip;$/;"	m	struct:__anon72
fetch_status	or/circuitbuild.c	/^  download_status_t fetch_status;$/;"	m	struct:__anon19	file:
fetch_var_cell_from_buf	or/buffers.c	/^fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto)$/;"	f
fetch_var_cell_from_evbuffer	or/buffers.c	/^fetch_var_cell_from_evbuffer(struct evbuffer *buf, var_cell_t **out,$/;"	f
file_handle	common/compat.h	/^  HANDLE file_handle;$/;"	m	struct:tor_mmap_t
file_status	common/util.c	/^file_status(const char *fname)$/;"	f
file_status_t	common/util.h	/^typedef enum { FN_ERROR, FN_NOENT, FN_FILE, FN_DIR } file_status_t;$/;"	t	typeref:enum:__anon17
filename	common/compat.c	/^  char *filename;$/;"	m	struct:tor_lockfile_t	file:
filename	common/log.c	/^  char *filename; \/**< Filename to open. *\/$/;"	m	struct:logfile_t	file:
filename	common/util.c	/^  char *filename; \/**< Name of the original file. *\/$/;"	m	struct:open_file_t	file:
find_all_by_keyword	or/routerparse.c	/^find_all_by_keyword(smartlist_t *s, directory_keyword k)$/;"	f	file:
find_all_exitpolicy	or/routerparse.c	/^find_all_exitpolicy(smartlist_t *s)$/;"	f	file:
find_benchmark	test/bench.c	/^find_benchmark(const char *name)$/;"	f	file:
find_bridge_by_digest	or/circuitbuild.c	/^find_bridge_by_digest(const char *digest)$/;"	f	file:
find_by_keyword	or/routerparse.c	/^#define find_by_keyword(/;"	d	file:
find_dir_signing_key	or/routerparse.c	/^find_dir_signing_key(const char *str, const char *eos)$/;"	f	file:
find_dl_schedule_and_len	or/directory.c	/^find_dl_schedule_and_len(download_status_t *dls, int server,$/;"	f	file:
find_element_starting_with	or/control.c	/^find_element_starting_with(smartlist_t *sl, int start_at, const char *prefix)$/;"	f	file:
find_flashcard_path	or/main.c	/^find_flashcard_path(PWCHAR path, size_t size)$/;"	f
find_intro_circuit	or/rendservice.c	/^find_intro_circuit(rend_intro_point_t *intro, const char *pk_digest)$/;"	f	file:
find_intro_point	or/rendservice.c	/^find_intro_point(origin_circuit_t *circ)$/;"	f	file:
find_largest_max	or/rephist.c	/^find_largest_max(bw_array_t *b)$/;"	f	file:
find_next_with	or/rephist.c	/^find_next_with(smartlist_t *sl, int i, const char *prefix)$/;"	f	file:
find_opt_by_keyword	or/routerparse.c	/^find_opt_by_keyword(smartlist_t *s, directory_keyword keyword)$/;"	f	file:
find_start_of_next_microdesc	or/routerparse.c	/^find_start_of_next_microdesc(const char *s, const char *eos)$/;"	f	file:
find_start_of_next_router_or_extrainfo	or/routerparse.c	/^find_start_of_next_router_or_extrainfo(const char **s_ptr,$/;"	f	file:
find_start_of_next_routerstatus	or/routerparse.c	/^find_start_of_next_routerstatus(const char *s)$/;"	f	file:
find_str_at_start_of_line	common/util.c	/^find_str_at_start_of_line(const char *haystack, const char *needle)$/;"	f
find_torrc_filename	or/config.c	/^find_torrc_filename(int argc, char **argv,$/;"	f	file:
find_transport_by_bridge_addrport	or/circuitbuild.c	/^find_transport_by_bridge_addrport(const tor_addr_t *addr, uint16_t port,$/;"	f
find_whitespace	common/util.c	/^find_whitespace(const char *s)$/;"	f
find_whitespace_eos	common/util.c	/^find_whitespace_eos(const char *s, const char *eos)$/;"	f
fingerprint_list	or/dirserv.c	/^static authdir_config_t *fingerprint_list = NULL;$/;"	v	file:
fingerprint_stack	or/or.h	/^  smartlist_t *fingerprint_stack;$/;"	m	struct:dir_connection_t
finish_daemon	common/util.c	/^finish_daemon(const char *cp)$/;"	f
finish_daemon	common/util.c	/^finish_daemon(const char *desired_cwd)$/;"	f
finish_daemon_called	common/util.c	/^static int finish_daemon_called = 0;$/;"	v	file:
finish_writing_to_file	common/util.c	/^finish_writing_to_file(open_file_t *file_data)$/;"	f
finish_writing_to_file_impl	common/util.c	/^finish_writing_to_file_impl(open_file_t *file_data, int abort_write)$/;"	f	file:
firewall_is_fascist_or	or/policies.c	/^firewall_is_fascist_or(void)$/;"	f
first	common/memarea.c	/^  memarea_chunk_t *first; \/**< Top of the chunk stack: never NULL. *\/$/;"	m	struct:memarea_t	file:
first	or/or.h	/^  char first[DIGEST_LEN];$/;"	m	struct:__anon57
first	or/or.h	/^  struct insertion_time_elem_t *first; \/**< First element in queue. *\/$/;"	m	struct:insertion_time_queue_t	typeref:struct:insertion_time_queue_t::insertion_time_elem_t
first_free	common/mempool.c	/^  mp_allocated_t *first_free;$/;"	m	struct:mp_chunk_t	file:
flags	or/eventdns.h	/^	int flags;$/;"	m	struct:evdns_server_request
flags	or/or.h	/^  uint64_t flags; \/**< Bit-field for all recognized flags; index into$/;"	m	struct:vote_routerstatus_t
flags	test/tinytest.h	/^	unsigned long flags; \/**< Bitfield of TT_* flags. *\/$/;"	m	struct:testcase_t
flavor	or/or.h	/^  consensus_flavor_t flavor : 8; \/**< If a consensus, what kind? *\/$/;"	m	struct:networkstatus_t
flush_buf	or/buffers.c	/^flush_buf(tor_socket_t s, buf_t *buf, size_t sz, size_t *buf_flushlen)$/;"	f
flush_buf_tls	or/buffers.c	/^flush_buf_tls(tor_tls_t *tls, buf_t *buf, size_t flushlen,$/;"	f
flush_chunk	or/buffers.c	/^flush_chunk(tor_socket_t s, buf_t *buf, chunk_t *chunk, size_t sz,$/;"	f	file:
flush_chunk_tls	or/buffers.c	/^flush_chunk_tls(tor_tls_t *tls, buf_t *buf, chunk_t *chunk,$/;"	f	file:
flush_pending_log_callbacks	common/log.c	/^flush_pending_log_callbacks(void)$/;"	f
fmt_addr	common/address.c	/^fmt_addr(const tor_addr_t *addr)$/;"	f
fmt_addr32	common/address.c	/^fmt_addr32(uint32_t addr)$/;"	f
fn	or/control.c	/^  getinfo_helper_t fn; \/**< The function that knows the answer: NULL if$/;"	m	struct:getinfo_item_t	file:
fn	test/bench.c	/^  bench_fn fn;$/;"	m	struct:benchmark_t	file:
fn	test/tinytest.h	/^	testcase_fn fn; \/**< The function to run to implement this case. *\/$/;"	m	struct:testcase_t
fname_alt_base	or/or.h	/^  const char *fname_alt_base;$/;"	m	struct:desc_store_t
fname_base	or/or.h	/^  const char *fname_base;$/;"	m	struct:desc_store_t
format_bridge_stats_controller	or/geoip.c	/^format_bridge_stats_controller(time_t now)$/;"	f	file:
format_helper_exit_status	common/util.c	/^format_helper_exit_status(unsigned char child_state, int saved_errno,$/;"	f
format_iso_time	common/util.c	/^format_iso_time(char *buf, time_t t)$/;"	f
format_iso_time_nospace	common/util.c	/^format_iso_time_nospace(char *buf, time_t t)$/;"	f
format_iso_time_nospace_usec	common/util.c	/^format_iso_time_nospace_usec(char *buf, const struct timeval *tv)$/;"	f
format_local_iso_time	common/util.c	/^format_local_iso_time(char *buf, time_t t)$/;"	f
format_msg	common/log.c	/^format_msg(char *buf, size_t buf_len,$/;"	f	file:
format_networkstatus_vote	or/dirvote.c	/^format_networkstatus_vote(crypto_pk_t *private_signing_key,$/;"	f
format_node_description	or/router.c	/^format_node_description(char *buf,$/;"	f
format_rfc1123_time	common/util.c	/^format_rfc1123_time(char *buf, time_t t)$/;"	f
format_time_interval	common/util.c	/^format_time_interval(char *out, size_t out_len, long interval)$/;"	f
format_versions_list	or/dirserv.c	/^format_versions_list(config_line_t *ln)$/;"	f	file:
format_win32_error	common/compat.c	/^format_win32_error(DWORD err)$/;"	f
format_win_cmdline_argument	common/util.c	/^format_win_cmdline_argument(const char *arg)$/;"	f	file:
fp_by_name	or/dirserv.c	/^  strmap_t *fp_by_name; \/**< Map from lc nickname to fingerprint. *\/$/;"	m	struct:authdir_config_t	file:
fp_pair_t	or/or.h	/^} fp_pair_t;$/;"	t	typeref:struct:__anon57
fragile	or/or.h	/^  unsigned int fragile:1;$/;"	m	struct:config_line_t
free	common/OpenBSD_malloc_Linux.c	/^	u_short		free;	\/* How many free chunks *\/$/;"	m	struct:pginfo	file:
free	common/OpenBSD_malloc_Linux.c	/^free(void *ptr)$/;"	f
free_bytes	common/OpenBSD_malloc_Linux.c	/^free_bytes(void *ptr, u_long index, struct pginfo * info)$/;"	f	file:
free_cell_pool	or/relay.c	/^free_cell_pool(void)$/;"	f
free_execve_args	or/transports.c	/^free_execve_args(char **arg)$/;"	f	file:
free_list	common/OpenBSD_malloc_Linux.c	/^static struct pgfree free_list;$/;"	v	typeref:struct:pgfree	file:
free_or_history	or/rephist.c	/^free_or_history(void *_hist)$/;"	f	file:
free_pages	common/OpenBSD_malloc_Linux.c	/^free_pages(void *ptr, u_long index, struct pginfo * info)$/;"	f	file:
free_pregenerated_keys	test/test.c	/^free_pregenerated_keys(void)$/;"	f	file:
freelist	common/memarea.c	/^static memarea_chunk_t *freelist = NULL;$/;"	v	file:
freelist_len	common/memarea.c	/^static int freelist_len=0;$/;"	v	file:
freelists	or/buffers.c	/^static chunk_freelist_t freelists[] = {$/;"	v	file:
fresh_until	or/or.h	/^  time_t fresh_until; \/**< Time before which this is the most recent vote or$/;"	m	struct:networkstatus_t
fresh_until	or/or.h	/^  time_t fresh_until;$/;"	m	struct:ns_detached_signatures_t
full	or/config.c	/^  const char *full;$/;"	m	struct:config_abbrev_t	file:
full_chunks	common/mempool.h	/^  struct mp_chunk_t *full_chunks;$/;"	m	struct:mp_pool_t	typeref:struct:mp_pool_t::mp_chunk_t
func	common/compat.c	/^  void (*func)(void *);$/;"	m	struct:tor_pthread_data_t	file:
g_alignment	common/OpenBSD_malloc_Linux.c	/^static size_t g_alignment = 0;$/;"	v	file:
gen_mutex	common/OpenBSD_malloc_Linux.c	/^static pthread_mutex_t gen_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
generate_certificate	tools/tor-gencert.c	/^generate_certificate(void)$/;"	f	file:
generate_key	tools/tor-gencert.c	/^generate_key(int bits)$/;"	f	file:
generate_ri_from_rs	test/test_dir.c	/^generate_ri_from_rs(const vote_routerstatus_t *vrs)$/;"	f	file:
generate_runningrouters	or/dirserv.c	/^generate_runningrouters(void)$/;"	f	file:
generate_signing_key	tools/tor-gencert.c	/^generate_signing_key(void)$/;"	f	file:
generate_v2_networkstatus_opinion	or/dirserv.c	/^generate_v2_networkstatus_opinion(void)$/;"	f	file:
generic_buffer_add	or/buffers.h	/^#define generic_buffer_add(/;"	d
generic_buffer_clear	or/buffers.h	/^#define generic_buffer_clear(/;"	d
generic_buffer_free	or/buffers.h	/^#define generic_buffer_free(/;"	d
generic_buffer_get	or/buffers.h	/^#define generic_buffer_get(/;"	d
generic_buffer_len	or/buffers.h	/^#define generic_buffer_len(/;"	d
generic_buffer_new	or/buffers.h	/^#define generic_buffer_new(/;"	d
generic_buffer_set_to_copy	or/buffers.c	/^generic_buffer_set_to_copy(generic_buffer_t **output,$/;"	f
generic_buffer_t	or/or.h	/^#define generic_buffer_t /;"	d
geoip_add_entry	or/geoip.c	/^geoip_add_entry(uint32_t low, uint32_t high, const char *country)$/;"	f	file:
geoip_bridge_stats_init	or/geoip.c	/^geoip_bridge_stats_init(time_t now)$/;"	f
geoip_bridge_stats_term	or/geoip.c	/^geoip_bridge_stats_term(void)$/;"	f
geoip_bridge_stats_write	or/geoip.c	/^geoip_bridge_stats_write(time_t now)$/;"	f
geoip_change_dirreq_state	or/geoip.c	/^geoip_change_dirreq_state(uint64_t dirreq_id, dirreq_type_t type,$/;"	f
geoip_client_action_t	or/or.h	/^} geoip_client_action_t;$/;"	t	typeref:enum:__anon59
geoip_countries	or/geoip.c	/^static smartlist_t *geoip_countries = NULL;$/;"	v	file:
geoip_country_t	or/geoip.c	/^typedef struct geoip_country_t {$/;"	s	file:
geoip_country_t	or/geoip.c	/^} geoip_country_t;$/;"	t	typeref:struct:geoip_country_t	file:
geoip_db_digest	or/geoip.c	/^geoip_db_digest(void)$/;"	f
geoip_determine_shares	or/geoip.c	/^geoip_determine_shares(time_t now)$/;"	f	file:
geoip_digest	or/geoip.c	/^static char geoip_digest[DIGEST_LEN];$/;"	v	file:
geoip_dirreq_stats_init	or/geoip.c	/^geoip_dirreq_stats_init(time_t now)$/;"	f
geoip_dirreq_stats_term	or/geoip.c	/^geoip_dirreq_stats_term(void)$/;"	f
geoip_dirreq_stats_write	or/geoip.c	/^geoip_dirreq_stats_write(time_t now)$/;"	f
geoip_entries	or/geoip.c	/^static smartlist_t *geoip_entries = NULL;$/;"	v	file:
geoip_entry_stats_init	or/geoip.c	/^geoip_entry_stats_init(time_t now)$/;"	f
geoip_entry_stats_term	or/geoip.c	/^geoip_entry_stats_term(void)$/;"	f
geoip_entry_stats_write	or/geoip.c	/^geoip_entry_stats_write(time_t now)$/;"	f
geoip_entry_t	or/geoip.c	/^typedef struct geoip_entry_t {$/;"	s	file:
geoip_entry_t	or/geoip.c	/^} geoip_entry_t;$/;"	t	typeref:struct:geoip_entry_t	file:
geoip_format_bridge_stats	or/geoip.c	/^geoip_format_bridge_stats(time_t now)$/;"	f
geoip_format_dirreq_stats	or/geoip.c	/^geoip_format_dirreq_stats(time_t now)$/;"	f
geoip_format_entry_stats	or/geoip.c	/^geoip_format_entry_stats(time_t now)$/;"	f
geoip_free_all	or/geoip.c	/^geoip_free_all(void)$/;"	f
geoip_get_bridge_stats_controller	or/geoip.c	/^geoip_get_bridge_stats_controller(time_t now)$/;"	f
geoip_get_bridge_stats_extrainfo	or/geoip.c	/^geoip_get_bridge_stats_extrainfo(time_t now)$/;"	f
geoip_get_client_history	or/geoip.c	/^geoip_get_client_history(geoip_client_action_t action)$/;"	f
geoip_get_country	or/geoip.c	/^geoip_get_country(const char *country)$/;"	f
geoip_get_country_by_addr	or/geoip.c	/^geoip_get_country_by_addr(const tor_addr_t *addr)$/;"	f
geoip_get_country_by_ip	or/geoip.c	/^geoip_get_country_by_ip(uint32_t ipaddr)$/;"	f
geoip_get_country_name	or/geoip.c	/^geoip_get_country_name(country_t num)$/;"	f
geoip_get_dirreq_history	or/geoip.c	/^geoip_get_dirreq_history(geoip_client_action_t action,$/;"	f	file:
geoip_get_mean_shares	or/geoip.c	/^geoip_get_mean_shares(time_t now, double *v2_share_out,$/;"	f	file:
geoip_get_n_countries	or/geoip.c	/^geoip_get_n_countries(void)$/;"	f
geoip_get_request_history	or/geoip.c	/^geoip_get_request_history(geoip_client_action_t action)$/;"	f
geoip_is_loaded	or/geoip.c	/^geoip_is_loaded(void)$/;"	f
geoip_load_file	or/geoip.c	/^geoip_load_file(const char *filename, const or_options_t *options)$/;"	f
geoip_note_client_seen	or/geoip.c	/^geoip_note_client_seen(geoip_client_action_t action,$/;"	f
geoip_note_ns_response	or/geoip.c	/^geoip_note_ns_response(geoip_client_action_t action,$/;"	f
geoip_ns_response_t	or/or.h	/^} geoip_ns_response_t;$/;"	t	typeref:enum:__anon60
geoip_parse_entry	or/geoip.c	/^geoip_parse_entry(const char *line)$/;"	f
geoip_remove_old_clients	or/geoip.c	/^geoip_remove_old_clients(time_t cutoff)$/;"	f
geoip_reset_dirreq_stats	or/geoip.c	/^geoip_reset_dirreq_stats(time_t now)$/;"	f
geoip_reset_entry_stats	or/geoip.c	/^geoip_reset_entry_stats(time_t now)$/;"	f
geoip_start_dirreq	or/geoip.c	/^geoip_start_dirreq(uint64_t dirreq_id, size_t response_size,$/;"	f
get_assigned_option	or/config.c	/^get_assigned_option(const config_format_t *fmt, const void *options,$/;"	f	file:
get_bindaddr_for_server_proxy	or/transports.c	/^get_bindaddr_for_server_proxy(const managed_proxy_t *mp)$/;"	f	file:
get_bytes_read	or/main.c	/^get_bytes_read(void)$/;"	f
get_bytes_written	or/main.c	/^get_bytes_written(void)$/;"	f
get_cert_list	or/routerlist.c	/^get_cert_list(const char *id_digest)$/;"	f	file:
get_circ	or/control.c	/^get_circ(const char *id)$/;"	f	file:
get_configured_bridge_by_addr_port_digest	or/circuitbuild.c	/^get_configured_bridge_by_addr_port_digest(const tor_addr_t *addr,$/;"	f	file:
get_configured_bridge_by_routerinfo	or/circuitbuild.c	/^get_configured_bridge_by_routerinfo(const routerinfo_t *ri)$/;"	f	file:
get_configured_ports	or/config.c	/^get_configured_ports(void)$/;"	f
get_connection_array	or/main.c	/^get_connection_array(void)$/;"	f
get_cookie_file	or/control.c	/^get_cookie_file(void)$/;"	f	file:
get_current_process_environment_variables	common/util.c	/^get_current_process_environment_variables(void)$/;"	f
get_datadir_fname	or/config.h	/^#define get_datadir_fname(/;"	d
get_datadir_fname2	or/config.h	/^#define get_datadir_fname2(/;"	d
get_datadir_fname2_suffix	or/config.h	/^#define get_datadir_fname2_suffix(/;"	d
get_datadir_fname_suffix	or/config.h	/^#define get_datadir_fname_suffix(/;"	d
get_default_conf_file	or/config.c	/^get_default_conf_file(int defaults_file)$/;"	f	file:
get_detached_signatures_from_pending_consensuses	or/dirvote.c	/^get_detached_signatures_from_pending_consensuses(pending_consensus_t *pending,$/;"	f	file:
get_detached_sigs	test/test_dir.c	/^get_detached_sigs(networkstatus_t *ns, networkstatus_t *ns2)$/;"	f	file:
get_digest	tools/tor-gencert.c	/^get_digest(EVP_PKEY *pkey, char *out)$/;"	f	file:
get_dir_info_status_string	or/routerlist.c	/^get_dir_info_status_string(void)$/;"	f
get_dirportfrontpage	or/config.c	/^get_dirportfrontpage(void)$/;"	f
get_effective_bwburst	or/config.c	/^get_effective_bwburst(const or_options_t *options)$/;"	f
get_effective_bwrate	or/config.c	/^get_effective_bwrate(const or_options_t *options)$/;"	f
get_environment	common/compat.c	/^get_environment(void)$/;"	f
get_escaped_string_length	or/control.c	/^get_escaped_string_length(const char *start, size_t in_len_max,$/;"	f	file:
get_fingerprint	tools/tor-gencert.c	/^get_fingerprint(EVP_PKEY *pkey, char *out)$/;"	f	file:
get_first_advertised_port_by_type_af	or/config.c	/^get_first_advertised_port_by_type_af(int listener_type, int address_family)$/;"	f
get_fname	test/test.c	/^get_fname(const char *name)$/;"	f
get_freelist	or/buffers.c	/^get_freelist(size_t alloc)$/;"	f	file:
get_frequent_members	or/dirvote.c	/^get_frequent_members(smartlist_t *out, smartlist_t *in, int min)$/;"	f	file:
get_interface_address	common/address.c	/^get_interface_address(int severity, uint32_t *addr)$/;"	f
get_interface_address6	common/address.c	/^get_interface_address6(int severity, sa_family_t family, tor_addr_t *addr)$/;"	f
get_interface_addresses_raw	common/address.c	/^get_interface_addresses_raw(int severity)$/;"	f	file:
get_last_hid_serv_requests	or/rendclient.c	/^get_last_hid_serv_requests(void)$/;"	f	file:
get_link_history	or/rephist.c	/^get_link_history(const char *from_id, const char *to_id)$/;"	f	file:
get_managed_proxy_by_argv_and_type	or/transports.c	/^get_managed_proxy_by_argv_and_type(char **proxy_argv, int is_server)$/;"	f	file:
get_microdesc_cache	or/microdesc.c	/^get_microdesc_cache(void)$/;"	f
get_min_log_level	common/log.c	/^get_min_log_level(void)$/;"	f
get_most_frequent_member	or/dirvote.c	/^#define get_most_frequent_member(/;"	d	file:
get_my_v3_authority_cert	or/router.c	/^get_my_v3_authority_cert(void)$/;"	f
get_my_v3_authority_signing_key	or/router.c	/^get_my_v3_authority_signing_key(void)$/;"	f
get_my_v3_legacy_cert	or/router.c	/^get_my_v3_legacy_cert(void)$/;"	f
get_my_v3_legacy_signing_key	or/router.c	/^get_my_v3_legacy_signing_key(void)$/;"	f
get_n_authorities	or/routerlist.c	/^get_n_authorities(dirinfo_type_t type)$/;"	f
get_n_open_sockets	common/compat.c	/^get_n_open_sockets(void)$/;"	f
get_n_v2_authorities	or/routerlist.c	/^#define get_n_v2_authorities(/;"	d	file:
get_net_param_from_list	or/networkstatus.c	/^get_net_param_from_list(smartlist_t *net_params, const char *param_name,$/;"	f	file:
get_next_token	or/routerparse.c	/^get_next_token(memarea_t *area,$/;"	f	file:
get_num_cpus	or/config.c	/^get_num_cpus(const or_options_t *options)$/;"	f
get_onion_key	or/router.c	/^get_onion_key(void)$/;"	f
get_onion_key_set_at	or/router.c	/^get_onion_key_set_at(void)$/;"	f
get_options	or/config.c	/^get_options(void)$/;"	f
get_options_mutable	or/config.c	/^get_options_mutable(void)$/;"	f
get_or_history	or/rephist.c	/^get_or_history(const char* id)$/;"	f	file:
get_or_state	or/config.c	/^get_or_state(void)$/;"	f
get_parent_directory	common/compat.c	/^get_parent_directory(char *fname)$/;"	f
get_pf_socket	or/connection_edge.c	/^get_pf_socket(void)$/;"	f
get_platform_str	or/router.c	/^get_platform_str(char *platform, size_t len)$/;"	f
get_possible_sybil_list	or/dirserv.c	/^get_possible_sybil_list(const smartlist_t *routers)$/;"	f	file:
get_primary_dir_port	or/config.h	/^#define get_primary_dir_port(/;"	d
get_primary_or_port	or/config.h	/^#define get_primary_or_port(/;"	d
get_proxy_addrport	or/connection.c	/^get_proxy_addrport(tor_addr_t *addr, uint16_t *port, int *proxy_type,$/;"	f
get_proxy_type	or/connection.c	/^get_proxy_type(void)$/;"	f	file:
get_scale_factor	or/relay.c	/^get_scale_factor(unsigned from_tick, unsigned to_tick)$/;"	f	file:
get_seconds_valid	or/rendcommon.c	/^get_seconds_valid(time_t now, const char *service_id)$/;"	f	file:
get_secret_id_part_bytes	or/rendcommon.c	/^get_secret_id_part_bytes(char *secret_id_part, uint32_t time_period,$/;"	f	file:
get_server_identity_key	or/router.c	/^get_server_identity_key(void)$/;"	f
get_signed_descriptor_by_fp	or/dirserv.c	/^get_signed_descriptor_by_fp(const char *fp, int extrainfo,$/;"	f	file:
get_signewnym_epoch	or/main.c	/^get_signewnym_epoch(void)$/;"	f
get_stability	or/rephist.c	/^get_stability(or_history_t *hist, time_t when)$/;"	f	file:
get_stored_bindaddr_for_server_transport	or/config.c	/^get_stored_bindaddr_for_server_transport(const char *transport)$/;"	f
get_stream	or/control.c	/^get_stream(const char *id)$/;"	f	file:
get_string_from_pipe	common/util.c	/^get_string_from_pipe(FILE *stream, char *buf_out, size_t count)$/;"	f
get_time_period	or/rendcommon.c	/^get_time_period(time_t now, uint8_t deviation, const char *service_id)$/;"	f	file:
get_tlsclient_identity_key	or/router.c	/^get_tlsclient_identity_key(void)$/;"	f
get_token_arguments	or/routerparse.c	/^get_token_arguments(memarea_t *area, directory_token_t *tok,$/;"	f	file:
get_torrc_fname	or/config.c	/^get_torrc_fname(int defaults_fname)$/;"	f
get_total_weighted_time	or/rephist.c	/^get_total_weighted_time(or_history_t *hist, time_t when)$/;"	f	file:
get_transport_bindaddr	or/config.c	/^get_transport_bindaddr(const char *line, const char *transport)$/;"	f	file:
get_transport_in_state_by_name	or/config.c	/^get_transport_in_state_by_name(const char *transport)$/;"	f	file:
get_uint16	common/compat.c	/^get_uint16(const void *cp)$/;"	f
get_uint32	common/compat.c	/^get_uint32(const void *cp)$/;"	f
get_uint64	common/compat.c	/^get_uint64(const void *cp)$/;"	f
get_uint8	common/compat.h	/^#define get_uint8(/;"	d
get_uname	common/compat.c	/^get_uname(void)$/;"	f
get_unique_circ_id_by_conn	or/circuitbuild.c	/^get_unique_circ_id_by_conn(or_connection_t *conn)$/;"	f	file:
get_unique_stream_id_by_circ	or/connection_edge.c	/^get_unique_stream_id_by_circ(origin_circuit_t *circ)$/;"	f	file:
get_uptime	or/main.c	/^get_uptime(void)$/;"	f
get_user_homedir	common/compat.c	/^get_user_homedir(const char *username)$/;"	f
get_version	or/config.c	/^get_version(void)$/;"	f
get_voter	or/dirvote.c	/^get_voter(const networkstatus_t *vote)$/;"	f	file:
get_weighted_fractional_uptime	or/rephist.c	/^get_weighted_fractional_uptime(or_history_t *hist, time_t when)$/;"	f	file:
get_windows_conf_root	or/config.c	/^get_windows_conf_root(void)$/;"	f	file:
getargs_helper	or/control.c	/^getargs_helper(const char *command, control_connection_t *conn,$/;"	f	file:
getinfo_helper_accounting	or/hibernate.c	/^getinfo_helper_accounting(control_connection_t *conn,$/;"	f
getinfo_helper_config	or/config.c	/^getinfo_helper_config(control_connection_t *conn,$/;"	f
getinfo_helper_dir	or/control.c	/^getinfo_helper_dir(control_connection_t *control_conn,$/;"	f	file:
getinfo_helper_entry_guards	or/circuitbuild.c	/^getinfo_helper_entry_guards(control_connection_t *conn,$/;"	f
getinfo_helper_events	or/control.c	/^getinfo_helper_events(control_connection_t *control_conn,$/;"	f	file:
getinfo_helper_geoip	or/geoip.c	/^getinfo_helper_geoip(control_connection_t *control_conn,$/;"	f
getinfo_helper_listeners	or/control.c	/^getinfo_helper_listeners(control_connection_t *control_conn,$/;"	f	file:
getinfo_helper_misc	or/control.c	/^getinfo_helper_misc(control_connection_t *conn, const char *question,$/;"	f	file:
getinfo_helper_networkstatus	or/networkstatus.c	/^getinfo_helper_networkstatus(control_connection_t *conn,$/;"	f
getinfo_helper_policies	or/policies.c	/^getinfo_helper_policies(control_connection_t *conn,$/;"	f
getinfo_helper_t	or/control.c	/^typedef int (*getinfo_helper_t)(control_connection_t *,$/;"	t	file:
getinfo_item_t	or/control.c	/^typedef struct getinfo_item_t {$/;"	s	file:
getinfo_item_t	or/control.c	/^} getinfo_item_t;$/;"	t	typeref:struct:getinfo_item_t	file:
getinfo_items	or/control.c	/^static const getinfo_item_t getinfo_items[] = {$/;"	v	file:
git_tag	or/or.h	/^  char git_tag[DIGEST_LEN];$/;"	m	struct:tor_version_t
git_tag_len	or/or.h	/^  int git_tag_len;$/;"	m	struct:tor_version_t
global_bind_addr_is_set	or/eventdns.c	/^static int global_bind_addr_is_set = 0;$/;"	v	file:
global_bind_address	or/eventdns.c	/^static struct sockaddr_storage global_bind_address;$/;"	v	typeref:struct:sockaddr_storage	file:
global_bind_addrlen	or/eventdns.c	/^static socklen_t global_bind_addrlen = 0;$/;"	v	file:
global_circuitlist	or/circuitlist.c	/^circuit_t *global_circuitlist=NULL;$/;"	v
global_cmdline_options	or/config.c	/^static config_line_t *global_cmdline_options = NULL;$/;"	v	file:
global_default_options	or/config.c	/^static or_options_t *global_default_options = NULL;$/;"	v	file:
global_dirfrontpagecontents	or/config.c	/^static char *global_dirfrontpagecontents = NULL;$/;"	v	file:
global_event_mask	or/control.c	/^static event_mask_t global_event_mask = 0;$/;"	v	file:
global_good_nameservers	or/eventdns.c	/^static int global_good_nameservers = 0;$/;"	v	file:
global_identifier	or/or.h	/^  uint32_t global_identifier;$/;"	m	struct:origin_circuit_t
global_identifier	or/or.h	/^  uint64_t global_identifier;$/;"	m	struct:connection_t
global_max_nameserver_timeout	or/eventdns.c	/^static int global_max_nameserver_timeout = 3;$/;"	v	file:
global_max_reissues	or/eventdns.c	/^static int global_max_reissues = 1;	\/* a reissue occurs when we get some errors from the server *\/$/;"	v	file:
global_max_requests_inflight	or/eventdns.c	/^static int global_max_requests_inflight = 64;$/;"	v	file:
global_max_retransmits	or/eventdns.c	/^static int global_max_retransmits = 3;	\/* number of times we'll retransmit a request which timed out *\/$/;"	v	file:
global_nameserver_timeouts	or/eventdns.c	/^static const struct timeval global_nameserver_timeouts[] = {{10, 0}, {60, 0}, {300, 0}, {900, 0}, {3600, 0}};$/;"	v	typeref:struct:timeval	file:
global_nameserver_timeouts_length	or/eventdns.c	/^static const int global_nameserver_timeouts_length = (int)(sizeof(global_nameserver_timeouts)\/sizeof(struct timeval));$/;"	v	file:
global_options	or/config.c	/^static or_options_t *global_options = NULL;$/;"	v	file:
global_randomize_case	or/eventdns.c	/^static int global_randomize_case = 1;$/;"	v	file:
global_rate_limit	or/connection.c	/^static struct bufferevent_rate_limit_group *global_rate_limit = NULL;$/;"	v	typeref:struct:bufferevent_rate_limit_group	file:
global_read_bucket	or/main.c	/^int global_read_bucket; \/**< Max number of bytes I can read this second. *\/$/;"	v
global_relayed_read_bucket	or/main.c	/^int global_relayed_read_bucket;$/;"	v
global_relayed_write_bucket	or/main.c	/^int global_relayed_write_bucket;$/;"	v
global_requests_inflight	or/eventdns.c	/^static int global_requests_inflight = 0;$/;"	v	file:
global_requests_waiting	or/eventdns.c	/^static int global_requests_waiting = 0;$/;"	v	file:
global_search_state	or/eventdns.c	/^static struct search_state *global_search_state = NULL;$/;"	v	typeref:struct:search_state	file:
global_state	or/config.c	/^static or_state_t *global_state = NULL;$/;"	v	file:
global_timeout	or/eventdns.c	/^static struct timeval global_timeout = {5, 0};	\/* 5 seconds *\/$/;"	v	typeref:struct:timeval	file:
global_write_bucket	or/main.c	/^int global_write_bucket; \/**< Max number of bytes I can write this second. *\/$/;"	v
global_write_bucket_low	or/connection.c	/^global_write_bucket_low(connection_t *conn, size_t attempt, int priority)$/;"	f
good_signature	or/or.h	/^  unsigned int good_signature : 1; \/**< Set to true if we've verified the sig$/;"	m	struct:document_signature_t
got_auth	or/or.h	/^  unsigned int got_auth : 1; \/**< Have we received any authentication data? *\/$/;"	m	struct:socks_request_t
got_hup	or/transports.h	/^  unsigned int got_hup : 1;$/;"	m	struct:__anon71
got_libevent_error	or/main.c	/^got_libevent_error(void)$/;"	f	file:
got_renegotiate	common/tortls.c	/^  unsigned int got_renegotiate:1;$/;"	m	struct:tor_tls_t	file:
groups	test/tinytest_demo.c	/^struct testgroup_t groups[] = {$/;"	v	typeref:struct:testgroup_t
guard_bandwidth_excluding_exits	or/dirserv.c	/^static uint32_t guard_bandwidth_excluding_exits = 0;$/;"	v	file:
guard_bandwidth_including_exits	or/dirserv.c	/^static uint32_t guard_bandwidth_including_exits = 0;$/;"	v	file:
guard_tk	or/dirserv.c	/^static long guard_tk = 0;$/;"	v	file:
guard_wfu	or/dirserv.c	/^static double guard_wfu = 0.0;$/;"	v	file:
gzip_is_supported	common/torgzip.c	/^static int gzip_is_supported = -1;$/;"	v	file:
hStatus	or/ntmain.c	/^static SERVICE_STATUS_HANDLE hStatus;$/;"	v	file:
handle_control_attachstream	or/control.c	/^handle_control_attachstream(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_authchallenge	or/control.c	/^handle_control_authchallenge(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_authenticate	or/control.c	/^handle_control_authenticate(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_closecircuit	or/control.c	/^handle_control_closecircuit(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_closestream	or/control.c	/^handle_control_closestream(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_extendcircuit	or/control.c	/^handle_control_extendcircuit(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_getconf	or/control.c	/^handle_control_getconf(control_connection_t *conn, uint32_t body_len,$/;"	f	file:
handle_control_getinfo	or/control.c	/^handle_control_getinfo(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_loadconf	or/control.c	/^handle_control_loadconf(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_mapaddress	or/control.c	/^handle_control_mapaddress(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_postdescriptor	or/control.c	/^handle_control_postdescriptor(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_protocolinfo	or/control.c	/^handle_control_protocolinfo(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_redirectstream	or/control.c	/^handle_control_redirectstream(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_resetconf	or/control.c	/^handle_control_resetconf(control_connection_t *conn, uint32_t len, char *body)$/;"	f	file:
handle_control_resolve	or/control.c	/^handle_control_resolve(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_saveconf	or/control.c	/^handle_control_saveconf(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_setcircuitpurpose	or/control.c	/^handle_control_setcircuitpurpose(control_connection_t *conn,$/;"	f	file:
handle_control_setconf	or/control.c	/^handle_control_setconf(control_connection_t *conn, uint32_t len, char *body)$/;"	f	file:
handle_control_setevents	or/control.c	/^handle_control_setevents(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_signal	or/control.c	/^handle_control_signal(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_takeownership	or/control.c	/^handle_control_takeownership(control_connection_t *conn, uint32_t len,$/;"	f	file:
handle_control_usefeature	or/control.c	/^handle_control_usefeature(control_connection_t *conn,$/;"	f	file:
handle_finished_proxy	or/transports.c	/^handle_finished_proxy(managed_proxy_t *mp)$/;"	f	file:
handle_getinfo_helper	or/control.c	/^handle_getinfo_helper(control_connection_t *control_conn,$/;"	f	file:
handle_methods_done	or/transports.c	/^handle_methods_done(const managed_proxy_t *mp)$/;"	f	file:
handle_proxy_line	or/transports.c	/^handle_proxy_line(const char *line, managed_proxy_t *mp)$/;"	f
handle_signals	or/main.c	/^handle_signals(int is_parent)$/;"	f
handshake_digest	or/or.h	/^  char handshake_digest[DIGEST_LEN]; \/**< Stores KH for the handshake. *\/$/;"	m	struct:or_circuit_t
handshake_digest	or/or.h	/^  char handshake_digest[DIGEST_LEN];\/* KH in tor-spec.txt *\/$/;"	m	struct:crypt_path_t
handshake_state	or/or.h	/^  or_handshake_state_t *handshake_state; \/**< If we are setting this connection$/;"	m	struct:or_connection_t
has_accepted_serverdesc	or/or.h	/^  unsigned int has_accepted_serverdesc:1;$/;"	m	struct:trusted_dir_server_t
has_bandwidth	or/or.h	/^  unsigned int has_bandwidth:1; \/**< The vote\/consensus had bw info *\/$/;"	m	struct:routerstatus_t
has_dns_init_failed	or/dns.c	/^has_dns_init_failed(void)$/;"	f
has_exitsummary	or/or.h	/^  unsigned int has_exitsummary:1; \/**< The vote\/consensus had exit summaries *\/$/;"	m	struct:routerstatus_t
has_finished	or/or.h	/^  unsigned int has_finished : 1; \/**< Has the SOCKS handshake finished? Used to$/;"	m	struct:socks_request_t
has_measured_bw	or/or.h	/^  unsigned int has_measured_bw:1; \/**< The vote\/consensus had a measured bw *\/$/;"	m	struct:routerstatus_t
has_opened	or/or.h	/^  unsigned int has_opened : 1;$/;"	m	struct:origin_circuit_t
hash_list_members	or/dirvote.c	/^hash_list_members(char *digest_out, size_t len_out,$/;"	f	file:
have_answer	or/eventdns.c	/^	unsigned int have_answer;$/;"	m	struct:reply	file:
have_built_consensus	or/dirvote.c	/^  int have_built_consensus;$/;"	m	struct:__anon25	file:
have_computed_timeout	or/or.h	/^  int have_computed_timeout;$/;"	m	struct:__anon54
have_failed	test/test.c	/^int have_failed = 0;$/;"	v
have_fetched_missing_signatures	or/dirvote.c	/^  int have_fetched_missing_signatures;$/;"	m	struct:__anon25	file:
have_fetched_missing_votes	or/dirvote.c	/^  int have_fetched_missing_votes;$/;"	m	struct:__anon25	file:
have_lockfile	or/main.c	/^have_lockfile(void)$/;"	f
have_min_dir_info	or/routerlist.c	/^static int have_min_dir_info = 0;$/;"	v	file:
have_performed_bandwidth_test	or/circuituse.c	/^static int have_performed_bandwidth_test = 0;$/;"	v	file:
have_published_consensus	or/dirvote.c	/^  int have_published_consensus;$/;"	m	struct:__anon25	file:
have_sent_protocolinfo	or/or.h	/^  unsigned int have_sent_protocolinfo:1;$/;"	m	struct:control_connection_t
have_voted	or/dirvote.c	/^  int have_voted;$/;"	m	struct:__anon25	file:
have_warned_about_new_version	or/networkstatus.c	/^static int have_warned_about_new_version = 0;$/;"	v	file:
have_warned_about_old_version	or/networkstatus.c	/^static int have_warned_about_old_version = 0;$/;"	v	file:
head	or/buffers.c	/^  chunk_t *head; \/**< First chunk in the list, or NULL for none. *\/$/;"	m	struct:buf_t	file:
head	or/buffers.c	/^  chunk_t *head; \/**< First chunk on the freelist. *\/$/;"	m	struct:chunk_freelist_t	file:
head	or/eventdns.c	/^	struct search_domain *head;$/;"	m	struct:search_state	typeref:struct:search_state::search_domain	file:
head	or/or.h	/^  packed_cell_t *head; \/**< The first cell, or NULL if the queue is empty. *\/$/;"	m	struct:cell_queue_t
heap_index	or/or.h	/^  int heap_index;$/;"	m	struct:__anon48
held_by_nodes	or/or.h	/^  unsigned int held_by_nodes;$/;"	m	struct:microdesc_t
held_in_map	or/or.h	/^  unsigned int held_in_map : 1;$/;"	m	struct:microdesc_t
help	tools/tor-fw-helper/tor-fw-helper.h	/^  int help;$/;"	m	struct:__anon72
hex_decode_digit	common/util.c	/^hex_decode_digit(char c)$/;"	f
hex_digest_nickname_decode	or/routerlist.c	/^hex_digest_nickname_decode(const char *hexdigest,$/;"	f
hex_digest_nickname_matches	or/routerlist.c	/^hex_digest_nickname_matches(const char *hexdigest, const char *identity_digest,$/;"	f	file:
hex_str	common/util.c	/^hex_str(const char *from, size_t fromlen)$/;"	f
hexdigest_to_digest	or/routerlist.c	/^hexdigest_to_digest(const char *hexdigest, char *digest)$/;"	f
hibernate_begin	or/hibernate.c	/^hibernate_begin(hibernate_state_t new_state, time_t now)$/;"	f	file:
hibernate_begin_shutdown	or/hibernate.c	/^hibernate_begin_shutdown(void)$/;"	f
hibernate_end	or/hibernate.c	/^hibernate_end(hibernate_state_t new_state)$/;"	f	file:
hibernate_end_time	or/hibernate.c	/^static time_t hibernate_end_time = 0;$/;"	v	file:
hibernate_end_time_elapsed	or/hibernate.c	/^hibernate_end_time_elapsed(time_t now)$/;"	f	file:
hibernate_go_dormant	or/hibernate.c	/^hibernate_go_dormant(time_t now)$/;"	f	file:
hibernate_hard_limit_reached	or/hibernate.c	/^hibernate_hard_limit_reached(void)$/;"	f	file:
hibernate_set_state_for_testing_	or/hibernate.c	/^hibernate_set_state_for_testing_(hibernate_state_t newstate)$/;"	f
hibernate_soft_limit_reached	or/hibernate.c	/^hibernate_soft_limit_reached(void)$/;"	f	file:
hibernate_state	or/hibernate.c	/^static hibernate_state_t hibernate_state = HIBERNATE_STATE_INITIAL;$/;"	v	file:
hibernate_state_t	or/hibernate.h	/^} hibernate_state_t;$/;"	t	typeref:enum:__anon33
hid_serv_acting_as_directory	or/routerlist.c	/^hid_serv_acting_as_directory(void)$/;"	f
hid_serv_get_responsible_directories	or/routerlist.c	/^hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,$/;"	f
hid_serv_responsible_for_desc_id	or/routerlist.c	/^hid_serv_responsible_for_desc_id(const char *query)$/;"	f
history_map	or/rephist.c	/^static digestmap_t *history_map = NULL;$/;"	v	file:
hold_open_until_flushed	or/or.h	/^  unsigned int hold_open_until_flushed:1; \/**< Despite this connection's being$/;"	m	struct:connection_t
hostname	or/dns.c	/^    char *hostname; \/**< Hostname for <b>address<\/b> (if a reverse lookup) *\/$/;"	m	union:cached_resolve_t::__anon26	file:
hostname_address	or/connection_edge.c	/^  char *hostname_address;$/;"	m	struct:__anon23	file:
hostname_in_track_host_exits	or/circuituse.c	/^hostname_in_track_host_exits(const or_options_t *options, const char *address)$/;"	f
hostname_type_t	or/connection_edge.h	/^typedef enum hostname_type_t {$/;"	g
hostname_type_t	or/connection_edge.h	/^} hostname_type_t;$/;"	t	typeref:enum:hostname_type_t
hproc	common/procmon.c	/^  HANDLE hproc;$/;"	m	struct:tor_process_monitor_t	file:
hs_circ_has_timed_out	or/or.h	/^  unsigned int hs_circ_has_timed_out : 1;$/;"	m	struct:origin_circuit_t
hs_service_side_rend_circ_has_been_relaunched	or/or.h	/^  unsigned int hs_service_side_rend_circ_has_been_relaunched : 1;$/;"	m	struct:origin_circuit_t
ht_ent	or/or.h	/^  HT_ENTRY(node_t) ht_ent;$/;"	m	struct:node_t
ht_improve_hash	common/ht.h	/^ht_improve_hash(unsigned h)$/;"	f
ht_string_hash	common/ht.h	/^ht_string_hash(const char *s)$/;"	f
http_get_header	or/directory.c	/^http_get_header(const char *headers, const char *which)$/;"	f	file:
http_set_address_origin	or/directory.c	/^http_set_address_origin(const char *headers, connection_t *conn)$/;"	f	file:
id	common/tortls.c	/^typedef struct cipher_info_t { unsigned id; const char *name; } cipher_info_t;$/;"	m	struct:cipher_info_t	file:
id_cert	or/or.h	/^  tor_cert_t *id_cert;$/;"	m	struct:or_handshake_state_t
identity	or/circuitbuild.c	/^  char identity[DIGEST_LEN];$/;"	m	struct:__anon18	file:
identity	or/circuitbuild.c	/^  char identity[DIGEST_LEN];$/;"	m	struct:__anon19	file:
identity	or/or.h	/^  char identity[DIGEST_LEN];$/;"	m	struct:node_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN]; \/**< Digest of signing key. *\/$/;"	m	struct:networkstatus_v2_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN]; \/**< Digest of the router's identity$/;"	m	struct:routerstatus_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN]; \/**< Hash of the public RSA key for$/;"	m	struct:dir_connection_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN]; \/**< Hash of this router's identity key. *\/$/;"	m	struct:extend_info_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN];$/;"	m	struct:document_signature_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN];$/;"	m	struct:networkstatus_voter_info_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN];$/;"	m	struct:or_connection_t
identity_digest	or/or.h	/^  char identity_digest[DIGEST_LEN];$/;"	m	struct:signed_descriptor_t
identity_key	or/or.h	/^  crypto_pk_t *identity_key;$/;"	m	struct:authority_cert_t
identity_key	tools/tor-gencert.c	/^EVP_PKEY *identity_key = NULL;$/;"	v
identity_key_file	tools/tor-gencert.c	/^char *identity_key_file = NULL;$/;"	v
identity_map	or/or.h	/^  struct digest_ri_map_t *identity_map;$/;"	m	struct:__anon44	typeref:struct:__anon44::digest_ri_map_t
identity_pkey	or/or.h	/^  crypto_pk_t *identity_pkey;  \/**< Public RSA key for signing. *\/$/;"	m	struct:__anon41
idx	or/routerlist.c	/^  int idx;$/;"	m	struct:duration_idx_t	file:
idx	test/test_containers.c	/^  int idx;$/;"	m	struct:pq_entry_t	file:
ifree	common/OpenBSD_malloc_Linux.c	/^ifree(void *ptr)$/;"	f	file:
imalloc	common/OpenBSD_malloc_Linux.c	/^imalloc(size_t size)$/;"	f	file:
in6_addr	common/address.h	/^    struct in6_addr in6_addr;$/;"	m	union:tor_addr_t::__anon1	typeref:struct:tor_addr_t::__anon1::in6_addr
in6_addr	common/compat.h	/^struct in6_addr$/;"	s
in6_addr	or/eventdns.c	/^struct in6_addr {$/;"	s	file:
in6_u	common/compat.h	/^  } in6_u;$/;"	m	struct:in6_addr	typeref:union:in6_addr::__anon6
in_addr	common/address.h	/^    struct in_addr in_addr;$/;"	m	union:tor_addr_t::__anon1	typeref:struct:tor_addr_t::__anon1::in_addr
in_chunk	common/mempool.c	/^  mp_chunk_t *in_chunk;$/;"	m	struct:mp_allocated_t	file:
in_flushed_some	or/or.h	/^  unsigned int in_flushed_some:1;$/;"	m	struct:connection_t
in_main_thread	common/compat.c	/^in_main_thread(void)$/;"	f
in_tinytest_main	test/tinytest.c	/^static int in_tinytest_main = 0; \/**< true if we're in tinytest_main().*\/$/;"	v	file:
inbuf	or/or.h	/^  buf_t *inbuf; \/**< Buffer holding data read over this connection. *\/$/;"	m	struct:connection_t
inbuf_reached_eof	or/or.h	/^  unsigned int inbuf_reached_eof:1; \/**< Boolean: did read() return 0 on this$/;"	m	struct:connection_t
incoming_cmd	or/or.h	/^  char *incoming_cmd;$/;"	m	struct:control_connection_t
incoming_cmd_cur_len	or/or.h	/^  uint32_t incoming_cmd_cur_len;$/;"	m	struct:control_connection_t
incoming_cmd_len	or/or.h	/^  uint32_t incoming_cmd_len;$/;"	m	struct:control_connection_t
increment_virtual_addr	or/connection_edge.c	/^increment_virtual_addr(void)$/;"	f	file:
index2ptr	common/OpenBSD_malloc_Linux.c	/^#define	index2ptr(/;"	d	file:
inet_aton	or/eventdns.c	/^#define inet_aton(/;"	d	file:
inform_testing_reachability	or/circuitbuild.c	/^inform_testing_reachability(void)$/;"	f
init	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  int init; \/**< Have we been initialized? *\/$/;"	m	struct:natpmp_state_t
init	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^  int init;$/;"	m	struct:miniupnpc_state_t
init	tools/tor-fw-helper/tor-fw-helper.h	/^  int (*init)(tor_fw_options_t *options, void *backend_state);$/;"	m	struct:tor_fw_backend_t
init_backends	tools/tor-fw-helper/tor-fw-helper.c	/^init_backends(tor_fw_options_t *options, backends_t *backends)$/;"	f	file:
init_cache_map	or/dns.c	/^init_cache_map(void)$/;"	f	file:
init_cell_pool	or/relay.c	/^init_cell_pool(void)$/;"	f
init_circuit_base	or/circuitlist.c	/^init_circuit_base(circuit_t *circ)$/;"	f	file:
init_cookie_authentication	or/control.c	/^init_cookie_authentication(int enabled)$/;"	f
init_dh_param	common/crypto.c	/^init_dh_param(void)$/;"	f	file:
init_geoip_countries	or/geoip.c	/^init_geoip_countries(void)$/;"	f	file:
init_key_from_file	or/router.c	/^init_key_from_file(const char *fname, int generate, int severity)$/;"	f
init_keys	or/router.c	/^init_keys(void)$/;"	f
init_libevent	or/config.c	/^init_libevent(const or_options_t *options)$/;"	f	file:
init_logging	common/log.c	/^init_logging(void)$/;"	f
init_nodelist	or/nodelist.c	/^init_nodelist(void)$/;"	f	file:
init_v3_authority_keys	or/router.c	/^init_v3_authority_keys(void)$/;"	f	file:
initiate_descriptor_downloads	or/routerlist.c	/^initiate_descriptor_downloads(const routerstatus_t *source,$/;"	f	file:
initvalue	or/config.c	/^  const char *initvalue; \/**< String (or null) describing initial value. *\/$/;"	m	struct:config_var_t	file:
inline	or/eventdns_tor.h	/^#define inline /;"	d
input_so_far	common/torgzip.c	/^  size_t input_so_far;$/;"	m	struct:tor_zlib_state_t	file:
insertion_time	or/or.h	/^  uint32_t insertion_time; \/**< When were cells inserted (in 10 ms steps$/;"	m	struct:insertion_time_elem_t
insertion_time_elem_t	or/or.h	/^typedef struct insertion_time_elem_t {$/;"	s
insertion_time_elem_t	or/or.h	/^} insertion_time_elem_t;$/;"	t	typeref:struct:insertion_time_elem_t
insertion_time_queue_t	or/or.h	/^typedef struct insertion_time_queue_t {$/;"	s
insertion_time_queue_t	or/or.h	/^} insertion_time_queue_t;$/;"	t	typeref:struct:insertion_time_queue_t
insertion_times	or/or.h	/^  insertion_time_queue_t *insertion_times; \/**< Insertion times of cells. *\/$/;"	m	struct:cell_queue_t
inspect_evbuffer	or/buffers.c	/^inspect_evbuffer(struct evbuffer *buf, char **data_out, size_t n,$/;"	f	file:
int16_t	common/torint.h	/^typedef signed int int16_t;$/;"	t
int16_t	common/torint.h	/^typedef signed short int16_t;$/;"	t
int32_t	common/torint.h	/^typedef signed int int32_t;$/;"	t
int32_t	common/torint.h	/^typedef signed long int32_t;$/;"	t
int64_t	common/torint.h	/^typedef signed __int64 int64_t;$/;"	t
int64_t	common/torint.h	/^typedef signed long int64_t;$/;"	t
int64_t	common/torint.h	/^typedef signed long long int64_t;$/;"	t
int8_t	common/torint.h	/^typedef signed char int8_t;$/;"	t
integrity	or/or.h	/^  char integrity[4]; \/**< Used to tell whether cell is corrupted. *\/$/;"	m	struct:__anon36
internal_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t internal_port;$/;"	m	struct:__anon72
interval_end_time	or/hibernate.c	/^static time_t interval_end_time = 0;$/;"	v	file:
interval_start_time	or/hibernate.c	/^static time_t interval_start_time = 0;$/;"	v	file:
interval_starts	or/dirvote.c	/^  time_t interval_starts;$/;"	m	struct:__anon25	file:
interval_wakeup_time	or/hibernate.c	/^static time_t interval_wakeup_time = 0;$/;"	v	file:
intptr_t	common/torint.h	/^typedef int32_t intptr_t;$/;"	t
intptr_t	common/torint.h	/^typedef int64_t intptr_t;$/;"	t
intro_key	or/or.h	/^  crypto_pk_t *intro_key; \/**< Introduction key that replaces the service$/;"	m	struct:rend_intro_point_t
intro_key	or/or.h	/^  crypto_pk_t *intro_key;$/;"	m	struct:origin_circuit_t
intro_nodes	or/or.h	/^  smartlist_t *intro_nodes;$/;"	m	struct:rend_service_descriptor_t
intro_nodes	or/rendservice.c	/^  smartlist_t *intro_nodes; \/**< List of rend_intro_point_t's we have,$/;"	m	struct:rend_service_t	file:
intro_period_started	or/rendservice.c	/^  time_t intro_period_started; \/**< Start of the current period to build$/;"	m	struct:rend_service_t	file:
intro_point_accepted_intro_count	or/rendservice.c	/^intro_point_accepted_intro_count(rend_intro_point_t *intro)$/;"	f	file:
intro_point_should_expire_now	or/rendservice.c	/^intro_point_should_expire_now(rend_intro_point_t *intro,$/;"	f	file:
invalid_router_usage_t	or/or.h	/^typedef enum invalid_router_usage_t {$/;"	g
invalid_router_usage_t	or/or.h	/^} invalid_router_usage_t;$/;"	t	typeref:enum:invalid_router_usage_t
ip_address_changed	or/main.c	/^ip_address_changed(int at_interface)$/;"	f
ip_high	or/geoip.c	/^  uint32_t ip_high; \/**< The highest IP in the range, in host order *\/$/;"	m	struct:geoip_entry_t	file:
ip_low	or/geoip.c	/^  uint32_t ip_low; \/**< The lowest IP in the range, in host order *\/$/;"	m	struct:geoip_entry_t	file:
ipo_token_table	or/routerparse.c	/^static token_rule_t ipo_token_table[] = {$/;"	v	file:
ipv4_address	or/connection_edge.c	/^  char *ipv4_address;$/;"	m	struct:__anon23	file:
ipv4_only	or/or.h	/^  unsigned int ipv4_only : 1;$/;"	m	struct:port_cfg_t
ipv6_addr	or/or.h	/^  tor_addr_t ipv6_addr;$/;"	m	struct:__anon41
ipv6_only	or/or.h	/^  unsigned int ipv6_only : 1;$/;"	m	struct:port_cfg_t
ipv6_orport	or/or.h	/^  uint16_t ipv6_orport;$/;"	m	struct:__anon41
ipv6_preferred	or/or.h	/^  unsigned int ipv6_preferred:1;$/;"	m	struct:__anon41
irealloc	common/OpenBSD_malloc_Linux.c	/^irealloc(void *ptr, size_t size)$/;"	f	file:
isServer	common/tortls.c	/^  unsigned int isServer:1; \/**< True iff this is a server-side connection *\/$/;"	m	struct:tor_tls_t	file:
is_accept	or/or.h	/^  unsigned int is_accept : 1;$/;"	m	struct:short_policy_t
is_an_entry_guard	or/circuitbuild.c	/^is_an_entry_guard(const char *digest)$/;"	f	file:
is_ancient	or/or.h	/^  unsigned int is_ancient : 1;$/;"	m	struct:origin_circuit_t
is_annotation	or/routerparse.c	/^  int is_annotation;$/;"	m	struct:token_rule_t	file:
is_authority	or/or.h	/^  unsigned int is_authority:1; \/**< True iff this router is an authority. *\/$/;"	m	struct:routerstatus_t
is_bad_directory	or/or.h	/^  unsigned int is_bad_directory:1; \/**< Do we think this directory is junky,$/;"	m	struct:node_t
is_bad_directory	or/or.h	/^  unsigned int is_bad_directory:1; \/**< Do we think this directory is junky,$/;"	m	struct:routerstatus_t
is_bad_exit	or/or.h	/^  unsigned int is_bad_exit:1; \/**< Do we think this exit is censored, borked,$/;"	m	struct:node_t
is_bad_exit	or/or.h	/^  unsigned int is_bad_exit:1; \/**< True iff this node is a bad choice for$/;"	m	struct:routerstatus_t
is_bad_for_new_circs	or/or.h	/^  unsigned int is_bad_for_new_circs:1;$/;"	m	struct:or_connection_t
is_canonical	or/or.h	/^  unsigned int is_canonical:1; \/**< True iff this policy is the canonical$/;"	m	struct:addr_policy_t
is_canonical	or/or.h	/^  unsigned int is_canonical:1;$/;"	m	struct:or_connection_t
is_compression_bomb	common/torgzip.c	/^is_compression_bomb(size_t size_in, size_t size_out)$/;"	f	file:
is_connection_with_client	or/or.h	/^  unsigned int is_connection_with_client:1;$/;"	m	struct:or_connection_t
is_cross_certified	or/or.h	/^  uint8_t is_cross_certified;$/;"	m	struct:authority_cert_t
is_dns_request	or/or.h	/^  unsigned int is_dns_request:1;$/;"	m	struct:edge_connection_t
is_exit	or/or.h	/^  unsigned int is_exit:1; \/**< Do we think this is an OK exit? *\/$/;"	m	struct:node_t
is_exit	or/or.h	/^  unsigned int is_exit:1; \/**< True iff this router is a good exit. *\/$/;"	m	struct:routerstatus_t
is_extrainfo	or/or.h	/^  unsigned int is_extrainfo : 1;$/;"	m	struct:signed_descriptor_t
is_fast	or/or.h	/^  unsigned int is_fast:1; \/** Do we think this is a fast OR? *\/$/;"	m	struct:node_t
is_fast	or/or.h	/^  unsigned int is_fast:1; \/**< True iff this router has good bandwidth. *\/$/;"	m	struct:routerstatus_t
is_first_hop	or/or.h	/^  unsigned int is_first_hop : 1;$/;"	m	struct:or_circuit_t
is_flagged_running	or/or.h	/^  unsigned int is_flagged_running:1;$/;"	m	struct:routerstatus_t
is_for_p_conn	or/or.h	/^  unsigned int is_for_p_conn : 1;$/;"	m	struct:__anon48
is_gzip_supported	common/torgzip.c	/^is_gzip_supported(void)$/;"	f
is_hibernating	or/or.h	/^  unsigned int is_hibernating:1; \/**< Whether the router claims to be$/;"	m	struct:__anon41
is_hs_dir	or/or.h	/^  unsigned int is_hs_dir:1; \/**< True iff this router is a hidden service$/;"	m	struct:node_t
is_hs_dir	or/or.h	/^  unsigned int is_hs_dir:1; \/**< True iff this router is a v2-or-later hidden$/;"	m	struct:routerstatus_t
is_internal	or/or.h	/^  unsigned int is_internal : 1;$/;"	m	struct:__anon47
is_internal_IP	common/address.c	/^is_internal_IP(uint32_t ip, int for_listening)$/;"	f
is_keyval_pair	or/control.c	/^is_keyval_pair(const char *s)$/;"	f	file:
is_legacy	or/dirvote.c	/^  int is_legacy;$/;"	m	struct:dir_src_ent_t	file:
is_legal_hexdigest	or/router.c	/^is_legal_hexdigest(const char *s)$/;"	f
is_legal_nickname	or/router.c	/^is_legal_nickname(const char *s)$/;"	f
is_legal_nickname_or_hexdigest	or/router.c	/^is_legal_nickname_or_hexdigest(const char *s)$/;"	f
is_local_addr	or/config.c	/^is_local_addr(const tor_addr_t *addr)$/;"	f
is_name	or/eventdns.c	/^	char is_name; \/* True iff data is a label *\/$/;"	m	struct:server_reply_item	file:
is_named	or/or.h	/^  unsigned int is_named:1; \/**< True iff "nickname" belongs to this router. *\/$/;"	m	struct:routerstatus_t
is_or_protocol_version_known	or/connection_or.c	/^is_or_protocol_version_known(uint16_t v)$/;"	f
is_outgoing	or/or.h	/^  unsigned int is_outgoing:1;$/;"	m	struct:or_connection_t
is_owning_control_connection	or/or.h	/^  unsigned int is_owning_control_connection:1;$/;"	m	struct:control_connection_t
is_possible_guard	or/or.h	/^  unsigned int is_possible_guard:1; \/**< Do we think this is an OK guard? *\/$/;"	m	struct:node_t
is_possible_guard	or/or.h	/^  unsigned int is_possible_guard:1; \/**< True iff this router would be a good$/;"	m	struct:routerstatus_t
is_prefix	or/control.c	/^  int is_prefix; \/** Must varname match exactly, or must it be a prefix? *\/$/;"	m	struct:getinfo_item_t	file:
is_private	or/or.h	/^  unsigned int is_private:1; \/**< True iff this is the pseudo-address,$/;"	m	struct:addr_policy_t
is_reverse	or/dns.c	/^  uint8_t is_reverse; \/**< Is this a reverse (addr-to-hostname) lookup? *\/$/;"	m	struct:cached_resolve_t	file:
is_router_version_good_for_possible_guard	or/dirserv.c	/^is_router_version_good_for_possible_guard(const char *platform)$/;"	f	file:
is_running	or/or.h	/^  unsigned int is_running:1; \/**< As far as we know, is this OR currently$/;"	m	struct:node_t
is_running	or/or.h	/^  unsigned int is_running:1; \/**< True iff we think this server is running. *\/$/;"	m	struct:trusted_dir_server_t
is_sensitive_dir_purpose	or/directory.c	/^is_sensitive_dir_purpose(uint8_t dir_purpose)$/;"	f	file:
is_server	or/transports.h	/^  int is_server; \/* is it a server proxy? *\/$/;"	m	struct:__anon71
is_stable	or/or.h	/^  unsigned int is_stable:1; \/** Do we think this is a stable OR? *\/$/;"	m	struct:node_t
is_stable	or/or.h	/^  unsigned int is_stable:1; \/**< True iff this router stays up a long time. *\/$/;"	m	struct:routerstatus_t
is_syslog	common/log.c	/^  int is_syslog; \/**< Boolean: send messages to syslog. *\/$/;"	m	struct:logfile_t	file:
is_temporary	common/log.c	/^  int is_temporary; \/**< Boolean: close after initializing logging subsystem.*\/$/;"	m	struct:logfile_t	file:
is_test_address	or/dns.c	/^is_test_address(const char *address)$/;"	f	file:
is_transparent_ap	or/or.h	/^  unsigned int is_transparent_ap:1;$/;"	m	struct:entry_connection_t
is_unix_addr	or/or.h	/^  unsigned is_unix_addr : 1; \/**< True iff this is an AF_UNIX address. *\/$/;"	m	struct:port_cfg_t
is_unnamed	or/or.h	/^  unsigned int is_unnamed:1; \/**< True iff "nickname" belongs to another$/;"	m	struct:routerstatus_t
is_v2_dir	or/or.h	/^  unsigned int is_v2_dir:1; \/**< True iff this router can serve directory$/;"	m	struct:routerstatus_t
is_valid	or/or.h	/^  unsigned int is_valid:1; \/**< Has a trusted dirserver validated this OR?$/;"	m	struct:node_t
is_valid	or/or.h	/^  unsigned int is_valid:1; \/**< True iff this router isn't invalid. *\/$/;"	m	struct:routerstatus_t
is_valid_initial_command	or/control.c	/^is_valid_initial_command(control_connection_t *conn, const char *cmd)$/;"	f	file:
isolation_any_streams_attached	or/or.h	/^  unsigned int isolation_any_streams_attached : 1;$/;"	m	struct:origin_circuit_t
isolation_flags	or/or.h	/^  uint8_t isolation_flags; \/**< Zero or more isolation flags *\/$/;"	m	struct:port_cfg_t
isolation_flags	or/or.h	/^  uint8_t isolation_flags;$/;"	m	struct:entry_connection_t
isolation_flags	or/or.h	/^  uint8_t isolation_flags;$/;"	m	struct:listener_connection_t
isolation_flags_mixed	or/or.h	/^  uint8_t isolation_flags_mixed;$/;"	m	struct:origin_circuit_t
isolation_values_set	or/or.h	/^  unsigned int isolation_values_set : 1;$/;"	m	struct:origin_circuit_t
ispowerof2	common/OpenBSD_malloc_Linux.c	/^static int ispowerof2 (size_t a) {$/;"	f	file:
issetugid	common/OpenBSD_malloc_Linux.c	/^static int issetugid(void)$/;"	f	file:
it_pool	or/relay.c	/^static mp_pool_t *it_pool = NULL;$/;"	v	file:
item_alloc_size	common/mempool.h	/^  size_t item_alloc_size;$/;"	m	struct:mp_pool_t
iv	common/crypto.c	/^  char iv[CIPHER_IV_LEN]; \/**< The initial IV. *\/$/;"	m	struct:crypto_cipher_t	file:
journal_fname	or/microdesc.c	/^  char *journal_fname;$/;"	m	struct:microdesc_cache_t	file:
journal_len	or/microdesc.c	/^  size_t journal_len;$/;"	m	struct:microdesc_cache_t	file:
journal_len	or/or.h	/^  size_t journal_len;$/;"	m	struct:desc_store_t
kb_to_bytes	or/routerlist.c	/^kb_to_bytes(uint32_t bw)$/;"	f	file:
key	common/aes.c	/^  } key;$/;"	m	struct:aes_cnt_cipher	typeref:union:aes_cnt_cipher::__anon3	file:
key	common/crypto.c	/^  RSA *key; \/**< The key itself *\/$/;"	m	struct:crypto_pk_t	file:
key	common/crypto.c	/^  char key[CIPHER_KEY_LEN]; \/**< The raw key. *\/$/;"	m	struct:crypto_cipher_t	file:
key	or/or.h	/^  char *key;$/;"	m	struct:config_line_t
key	or/routerparse.c	/^  crypto_pk_t *key;        \/**< For public keys only.  Heap-allocated. *\/$/;"	m	struct:directory_token_t	file:
key_lock	or/router.c	/^static tor_mutex_t *key_lock=NULL;$/;"	v	file:
key_to_string	tools/tor-gencert.c	/^key_to_string(EVP_PKEY *key)$/;"	f	file:
known_flags	or/or.h	/^  smartlist_t *known_flags;$/;"	m	struct:networkstatus_t
labels	or/eventdns.c	/^	struct dnslabel_entry labels[MAX_LABELS];$/;"	m	struct:dnslabel_table	typeref:struct:dnslabel_table::dnslabel_entry	file:
lanaddr	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^  char lanaddr[UPNP_LANADDR_SZ];$/;"	m	struct:miniupnpc_state_t
last	or/or.h	/^  struct insertion_time_elem_t *last; \/**< Last element in queue. *\/$/;"	m	struct:insertion_time_queue_t	typeref:struct:insertion_time_queue_t::insertion_time_elem_t
last_adjusted_tick	or/or.h	/^  unsigned last_adjusted_tick;$/;"	m	struct:__anon48
last_allowed	common/util.h	/^  time_t last_allowed;$/;"	m	struct:ratelim_t
last_attempted	or/circuitbuild.c	/^  time_t last_attempted; \/**< 0 if we can connect to this guard, or the time$/;"	m	struct:__anon18	file:
last_circ_at	or/or.h	/^  time_t last_circ_at;$/;"	m	struct:__anon54
last_cleaned_accepted_intro_dh_parts	or/rendservice.c	/^  time_t last_cleaned_accepted_intro_dh_parts;$/;"	m	struct:rend_service_t	file:
last_desc_dumped	or/routerparse.c	/^static time_t last_desc_dumped = 0;$/;"	v	file:
last_descriptor_download_attempted	or/routerlist.c	/^static time_t last_descriptor_download_attempted = 0;$/;"	v	file:
last_dir	common/OpenBSD_malloc_Linux.c	/^static struct pdinfo *last_dir;	\/* Caches to the last and previous *\/$/;"	v	typeref:struct:pdinfo	file:
last_dir_503_at	or/or.h	/^  time_t last_dir_503_at; \/**< When did this router last tell us that it$/;"	m	struct:routerstatus_t
last_error	or/eventdns.c	/^#define last_error(/;"	d	file:
last_error	or/eventdns.c	/^last_error(int sock)$/;"	f	file:
last_guessed_ip	or/router.c	/^static tor_addr_t last_guessed_ip = TOR_ADDR_NULL;$/;"	v	file:
last_hid_serv_requests_	or/rendclient.c	/^static strmap_t *last_hid_serv_requests_ = NULL;$/;"	v	file:
last_index	common/OpenBSD_malloc_Linux.c	/^static u_long	last_index;$/;"	v	file:
last_interface_ip	or/connection.c	/^static uint32_t last_interface_ip = 0;$/;"	v	file:
last_listed	or/or.h	/^  time_t last_listed;$/;"	m	struct:microdesc_t
last_listed_as_valid_until	or/or.h	/^  time_t last_listed_as_valid_until;$/;"	m	struct:signed_descriptor_t
last_networkstatus_download_attempted	or/networkstatus.c	/^static time_t last_networkstatus_download_attempted = 0;$/;"	v	file:
last_reachable	or/or.h	/^  time_t last_reachable;$/;"	m	struct:__anon41
last_reached_addr	or/rephist.c	/^  tor_addr_t last_reached_addr;$/;"	m	struct:or_history_t	file:
last_reached_port	or/rephist.c	/^  uint16_t last_reached_port;$/;"	m	struct:or_history_t	file:
last_read_count	common/tortls.c	/^  unsigned long last_read_count;$/;"	m	struct:tor_tls_t	file:
last_resolved_addr	or/config.c	/^static uint32_t last_resolved_addr = 0;$/;"	v	file:
last_rotation_time	or/cpuworker.c	/^static time_t last_rotation_time=0;$/;"	v	file:
last_seen_in_minutes	or/geoip.c	/^  unsigned int last_seen_in_minutes:30;$/;"	m	struct:clientmap_entry_t	file:
last_sent_bootstrap_message	or/control.c	/^static char last_sent_bootstrap_message[BOOTSTRAP_MSG_LEN];$/;"	v	file:
last_stability_doc	or/rephist.c	/^static char *last_stability_doc = NULL;$/;"	v	file:
last_state_file_write_failed	or/config.c	/^static int last_state_file_write_failed = 0;$/;"	v	file:
last_time_determined_shares	or/geoip.c	/^static time_t last_time_determined_shares = 0;$/;"	v	file:
last_write_count	common/tortls.c	/^  unsigned long last_write_count;$/;"	m	struct:tor_tls_t	file:
lastonionkey	or/router.c	/^static crypto_pk_t *lastonionkey=NULL;$/;"	v	file:
launch_descriptor_downloads	or/routerlist.c	/^launch_descriptor_downloads(int purpose,$/;"	f
launch_direct_bridge_descriptor_fetch	or/circuitbuild.c	/^launch_direct_bridge_descriptor_fetch(bridge_info_t *bridge)$/;"	f	file:
launch_dummy_descriptor_download_as_needed	or/routerlist.c	/^launch_dummy_descriptor_download_as_needed(time_t now,$/;"	f	file:
launch_managed_proxy	or/transports.c	/^launch_managed_proxy(managed_proxy_t *mp)$/;"	f	file:
launch_resolve	or/dns.c	/^launch_resolve(edge_connection_t *exitconn)$/;"	f	file:
launch_test_addresses	or/dns.c	/^launch_test_addresses(int fd, short event, void *args)$/;"	f	file:
launch_wildcard_check	or/dns.c	/^launch_wildcard_check(int min_len, int max_len, const char *suffix)$/;"	f	file:
le_version_t	common/compat_libevent.c	/^typedef uint32_t le_version_t;$/;"	t	file:
le_versions_compatibility	common/compat_libevent.c	/^le_versions_compatibility(le_version_t v)$/;"	f	file:
learned_bridge_descriptor	or/circuitbuild.c	/^learned_bridge_descriptor(routerinfo_t *ri, int from_cache)$/;"	f
learned_router_identity	or/circuitbuild.c	/^learned_router_identity(const tor_addr_t *addr, uint16_t port,$/;"	f
lease	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  int lease;$/;"	m	struct:natpmp_state_t
legacy_id_digest	or/or.h	/^  char legacy_id_digest[DIGEST_LEN];$/;"	m	struct:networkstatus_voter_info_t
legacy_key_certificate	or/router.c	/^static authority_cert_t *legacy_key_certificate = NULL;$/;"	v	file:
legacy_setup	test/test.c	/^const struct testcase_setup_t legacy_setup = {$/;"	v	typeref:struct:testcase_setup_t
legacy_signing_key	or/router.c	/^static crypto_pk_t *legacy_signing_key = NULL;$/;"	v	file:
legacy_test_cleanup	test/test.c	/^legacy_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
legacy_test_helper	test/test.c	/^legacy_test_helper(void *data)$/;"	f
legacy_test_setup	test/test.c	/^legacy_test_setup(const struct testcase_t *testcase)$/;"	f	file:
len	common/util.h	/^  size_t len;$/;"	m	struct:sized_chunk_t
len	or/eventdns.c	/^	size_t len;$/;"	m	struct:search_domain	file:
len	or/or.h	/^  size_t len; \/**< Length of <b>desc<\/b> *\/$/;"	m	struct:rend_cache_entry_t
length	common/sha256.c	/^    uint64_t length;$/;"	m	struct:sha256_state	file:
length	or/or.h	/^  uint16_t length; \/**< How long is the payload body? *\/$/;"	m	struct:__anon36
length_of_accounting_period_containing	or/hibernate.c	/^length_of_accounting_period_containing(time_t now)$/;"	f	file:
libevent_logging_callback	common/compat_libevent.c	/^libevent_logging_callback(int severity, const char *msg)$/;"	f	file:
libor_get_digests	common/util_codedigest.c	/^libor_get_digests(void)$/;"	f
link_apconn_to_circ	or/circuituse.c	/^link_apconn_to_circ(entry_connection_t *apconn, origin_circuit_t *circ,$/;"	f	file:
link_history_map	or/rephist.c	/^  digestmap_t *link_history_map;$/;"	m	struct:or_history_t	file:
link_history_t	or/rephist.c	/^typedef struct link_history_t {$/;"	s	file:
link_history_t	or/rephist.c	/^} link_history_t;$/;"	t	typeref:struct:link_history_t	file:
link_key	common/tortls.c	/^  crypto_pk_t *link_key;$/;"	m	struct:tor_tls_context_t	file:
link_proto	or/or.h	/^  uint8_t link_proto; \/**< What protocol version are we using? 0 for$/;"	m	struct:or_connection_t
linked	or/or.h	/^  unsigned int linked:1; \/**< True if there is, or has been, a linked_conn. *\/$/;"	m	struct:connection_t
linked_conn	or/or.h	/^  struct connection_t *linked_conn;$/;"	m	struct:connection_t	typeref:struct:connection_t::connection_t
linked_conn_is_closed	or/or.h	/^  unsigned int linked_conn_is_closed:1;$/;"	m	struct:connection_t
list	common/container.h	/^  void **list;$/;"	m	struct:smartlist_t
list	or/routerlist.c	/^  smartlist_t *list;$/;"	m	struct:routerset_t	file:
list_getinfo_options	or/control.c	/^list_getinfo_options(void)$/;"	f	file:
list_pending_descriptor_downloads	or/routerlist.c	/^list_pending_descriptor_downloads(digestmap_t *result, int extrainfo)$/;"	f	file:
list_pending_downloads	or/routerlist.c	/^list_pending_downloads(digestmap_t *result,$/;"	f	file:
list_pending_microdesc_downloads	or/routerlist.c	/^list_pending_microdesc_downloads(digestmap_t *result)$/;"	f
list_server_status_v1	or/dirserv.c	/^list_server_status_v1(smartlist_t *routers, char **router_status_out,$/;"	f
list_single_server_status	or/dirserv.c	/^list_single_server_status(const routerinfo_t *desc, int is_live)$/;"	f	file:
list_torrc_options	or/config.c	/^list_torrc_options(void)$/;"	f	file:
list_v3_auth_ids	or/dirvote.c	/^list_v3_auth_ids(void)$/;"	f	file:
listed_in_last_desc	or/or.h	/^  unsigned int listed_in_last_desc : 1;$/;"	m	struct:rend_intro_point_t
listener_connection_new	or/connection.c	/^listener_connection_new(int type, int socket_family)$/;"	f
listener_connection_t	or/or.h	/^typedef struct listener_connection_t {$/;"	s
listener_connection_t	or/or.h	/^} listener_connection_t;$/;"	t	typeref:struct:listener_connection_t
listener_type	or/or.h	/^  uint8_t listener_type;$/;"	m	struct:socks_request_t
lists_bad_directories	or/or.h	/^  unsigned int lists_bad_directories:1;$/;"	m	struct:networkstatus_v2_t
lists_bad_exits	or/or.h	/^  unsigned int lists_bad_exits:1; \/**< True iff this directory server marks$/;"	m	struct:networkstatus_v2_t
liveness	or/or.h	/^  network_liveness_t liveness;$/;"	m	struct:__anon54
load_authority_keyset	or/router.c	/^load_authority_keyset(int legacy, crypto_pk_t **key_out,$/;"	f	file:
load_bridge_stats	or/geoip.c	/^load_bridge_stats(time_t now)$/;"	f	file:
load_downloaded_routers	or/directory.c	/^load_downloaded_routers(const char *body, smartlist_t *which,$/;"	f	file:
load_identity_key	tools/tor-gencert.c	/^load_identity_key(void)$/;"	f	file:
load_nameservers_from_registry	or/eventdns.c	/^load_nameservers_from_registry(void)$/;"	f	file:
load_nameservers_with_getnetworkparams	or/eventdns.c	/^load_nameservers_with_getnetworkparams(void)$/;"	f	file:
load_passphrase	tools/tor-gencert.c	/^load_passphrase(void)$/;"	f	file:
load_policy_from_option	or/policies.c	/^load_policy_from_option(config_line_t *config, smartlist_t **policy,$/;"	f	file:
load_signing_key	tools/tor-gencert.c	/^load_signing_key(void)$/;"	f	file:
load_stats_file	or/router.c	/^load_stats_file(const char *filename, const char *end_line, time_t now,$/;"	f	file:
load_torrc_from_disk	or/config.c	/^load_torrc_from_disk(int argc, char **argv, int defaults_file)$/;"	f	file:
load_windows_system_library	common/util.c	/^load_windows_system_library(const TCHAR *library_name)$/;"	f
loaded	or/ntmain.c	/^  int loaded;$/;"	m	struct:service_fns	file:
lock	common/crypto.c	/^  tor_mutex_t *lock;$/;"	m	struct:CRYPTO_dynlock_value	file:
lockfile	or/main.c	/^static tor_lockfile_t *lockfile = NULL;$/;"	v	file:
log	common/torlog.h	/^#define log /;"	d
log	common/util.c	/^#undef log$/;"	d	file:
log	or/circuitbuild.c	/^#undef log$/;"	d	file:
log	or/eventdns.c	/^#define log /;"	d	file:
log	or/routerparse.c	/^#undef log$/;"	d	file:
log_addr_has_changed	or/router.c	/^log_addr_has_changed(int severity,$/;"	f	file:
log_callback	common/torlog.h	/^typedef void (*log_callback)(int severity, uint32_t domain, const char *msg);$/;"	t
log_cert_lifetime	common/tortls.c	/^log_cert_lifetime(int severity, const X509 *cert, const char *problem)$/;"	f	file:
log_commandline_options	tools/tor-fw-helper/tor-fw-helper.c	/^log_commandline_options(int argc, char **argv)$/;"	f	file:
log_credential_status	common/compat.c	/^log_credential_status(void)$/;"	f	file:
log_debug	common/torlog.h	/^#define log_debug /;"	d
log_debug	common/torlog.h	/^#define log_debug(/;"	d
log_domain	common/procmon.c	/^  log_domain_mask_t log_domain;$/;"	m	struct:tor_process_monitor_t	file:
log_domain_mask_t	common/torlog.h	/^typedef uint32_t log_domain_mask_t;$/;"	t
log_domains_are_logged	common/log.c	/^static int log_domains_are_logged = 0;$/;"	v	file:
log_engine	common/crypto.c	/^log_engine(const char *fn, ENGINE *e)$/;"	f	file:
log_entry_guards	or/circuitbuild.c	/^log_entry_guards(int severity)$/;"	f	file:
log_err	common/torlog.h	/^#define log_err /;"	d
log_err	common/torlog.h	/^#define log_err(/;"	d
log_failed_proxy_connection	or/connection.c	/^log_failed_proxy_connection(connection_t *conn)$/;"	f
log_fn	common/torlog.h	/^#define log_fn /;"	d
log_fn	common/torlog.h	/^#define log_fn(/;"	d
log_free	common/log.c	/^log_free(logfile_t *victim)$/;"	f	file:
log_from_handle	common/util.c	/^log_from_handle(HANDLE *pipe, int severity)$/;"	f	file:
log_from_pipe	common/util.c	/^log_from_pipe(FILE *stream, int severity, const char *executable,$/;"	f	file:
log_heartbeat	or/status.c	/^log_heartbeat(time_t now)$/;"	f
log_info	common/torlog.h	/^#define log_info /;"	d
log_info	common/torlog.h	/^#define log_info(/;"	d
log_level_to_string	common/log.c	/^log_level_to_string(int level)$/;"	f
log_mutex	common/log.c	/^static tor_mutex_t log_mutex;$/;"	v	file:
log_mutex_initialized	common/log.c	/^static int log_mutex_initialized = 0;$/;"	v	file:
log_notice	common/torlog.h	/^#define log_notice /;"	d
log_notice	common/torlog.h	/^#define log_notice(/;"	d
log_set_application_name	common/log.c	/^log_set_application_name(const char *name)$/;"	f
log_severity_list_t	common/torlog.h	/^typedef struct log_severity_list_t {$/;"	s
log_severity_list_t	common/torlog.h	/^} log_severity_list_t;$/;"	t	typeref:struct:log_severity_list_t
log_severity_to_event	or/control.c	/^log_severity_to_event(int severity)$/;"	f	file:
log_sock_error	tools/tor-resolve.c	/^#define log_sock_error(/;"	d	file:
log_time_granularity	common/log.c	/^static int log_time_granularity = 1;$/;"	v	file:
log_tor_version	common/log.c	/^log_tor_version(logfile_t *lf, int reset)$/;"	f	file:
log_unsafe_socks_warning	or/buffers.c	/^log_unsafe_socks_warning(int socks_protocol, const char *address,$/;"	f	file:
log_warn	common/torlog.h	/^#define log_warn /;"	d
log_warn	common/torlog.h	/^#define log_warn(/;"	d
logfile_t	common/log.c	/^typedef struct logfile_t {$/;"	s	file:
logfile_t	common/log.c	/^} logfile_t;$/;"	t	typeref:struct:logfile_t	file:
logfiles	common/log.c	/^static logfile_t *logfiles = NULL;$/;"	v	file:
logfn	or/eventdns.c	/^logfn(int is_warn, const char *msg) {$/;"	f
logs_free_all	common/log.c	/^logs_free_all(void)$/;"	f
logs_set_domain_logging	common/log.c	/^logs_set_domain_logging(int enabled)$/;"	f
logv	common/log.c	/^logv(int severity, log_domain_mask_t domain, const char *funcname,$/;"	f	file:
lookup_cached_dir_by_fp	or/dirserv.c	/^lookup_cached_dir_by_fp(const char *fp)$/;"	f	file:
lookup_last_hid_serv_request	or/rendclient.c	/^lookup_last_hid_serv_request(routerstatus_t *hs_dir,$/;"	f	file:
lost_owning_controller	or/control.c	/^lost_owning_controller(const char *owner_type, const char *loss_manner)$/;"	f	file:
lowest_length	or/buffers.c	/^  int lowest_length; \/**< What's the smallest value of cur_length since the$/;"	m	struct:chunk_freelist_t	file:
made_contact	or/circuitbuild.c	/^  unsigned int made_contact : 1; \/**< 0 if we have never connected to this$/;"	m	struct:__anon18	file:
magic	common/mempool.c	/^  unsigned long magic; \/**< Must be MP_CHUNK_MAGIC if this chunk is valid. *\/$/;"	m	struct:mp_chunk_t	file:
magic	common/tortls.c	/^  uint32_t magic;$/;"	m	struct:tor_tls_t	file:
magic	or/buffers.c	/^  uint32_t magic; \/**< Magic cookie for debugging: Must be set to$/;"	m	struct:buf_t	file:
magic	or/config.c	/^  uint32_t magic; \/**< Required 'magic value' to make sure we have a struct$/;"	m	struct:__anon21	file:
magic	or/dns.c	/^  uint32_t magic;$/;"	m	struct:cached_resolve_t	file:
magic	or/or.h	/^  uint32_t magic; \/**< For memory and type debugging: must equal$/;"	m	struct:circuit_t
magic	or/or.h	/^  uint32_t magic; \/**< For memory debugging: must equal one of$/;"	m	struct:connection_t
magic	or/or.h	/^  uint32_t magic;$/;"	m	struct:crypt_path_t
magic_offset	or/config.c	/^  off_t magic_offset; \/**< Offset of the magic value within the struct. *\/$/;"	m	struct:__anon21	file:
main	or/eventdns.c	/^main(int c, char **v) {$/;"	f
main	or/tor_main.c	/^main(int argc, char *argv[])$/;"	f
main	test/bench.c	/^main(int argc, const char **argv)$/;"	f
main	test/test-child.c	/^main(int argc, char **argv)$/;"	f
main	test/test.c	/^main(int c, const char **v)$/;"	f
main	test/tinytest_demo.c	/^main(int c, const char **v)$/;"	f
main	tools/tor-checkkey.c	/^main(int c, char **v)$/;"	f
main	tools/tor-fw-helper/tor-fw-helper.c	/^main(int argc, char **argv)$/;"	f
main	tools/tor-gencert.c	/^main(int argc, char **argv)$/;"	f
main	tools/tor-resolve.c	/^main(int argc, char **argv)$/;"	f
main_callback	or/eventdns.c	/^main_callback(int result, char type, int count, int ttl,$/;"	f
main_thread_id	common/compat.c	/^static unsigned long main_thread_id = -1;$/;"	v	file:
major	or/or.h	/^  int major;$/;"	m	struct:tor_version_t
make_circuit_active_on_conn	or/relay.c	/^make_circuit_active_on_conn(circuit_t *circ, or_connection_t *conn)$/;"	f
make_circuit_inactive_on_conn	or/relay.c	/^make_circuit_inactive_on_conn(circuit_t *circ, or_connection_t *conn)$/;"	f
make_consensus_method_list	or/dirvote.c	/^make_consensus_method_list(int low, int high, const char *separator)$/;"	f	file:
make_new_id	tools/tor-gencert.c	/^int make_new_id = 0;$/;"	v
make_path_absolute	common/compat.c	/^make_path_absolute(char *fname)$/;"	f
make_socket_reuseable	or/connection.c	/^make_socket_reuseable(tor_socket_t sock)$/;"	f	file:
malloc	common/OpenBSD_malloc_Linux.c	/^malloc(size_t size)$/;"	f
malloc_abort	common/OpenBSD_malloc_Linux.c	/^static int	malloc_abort = 2;$/;"	v	file:
malloc_active	common/OpenBSD_malloc_Linux.c	/^static int	malloc_active;$/;"	v	file:
malloc_brk	common/OpenBSD_malloc_Linux.c	/^static caddr_t	malloc_brk;$/;"	v	file:
malloc_bytes	common/OpenBSD_malloc_Linux.c	/^malloc_bytes(size_t size)$/;"	f	file:
malloc_cache	common/OpenBSD_malloc_Linux.c	/^static unsigned int	malloc_cache = 16;$/;"	v	file:
malloc_dump	common/OpenBSD_malloc_Linux.c	/^malloc_dump(int fd)$/;"	f
malloc_exit	common/OpenBSD_malloc_Linux.c	/^malloc_exit(void)$/;"	f	file:
malloc_freeprot	common/OpenBSD_malloc_Linux.c	/^static int	malloc_freeprot;$/;"	v	file:
malloc_func	common/OpenBSD_malloc_Linux.c	/^static const char	*malloc_func;$/;"	v	file:
malloc_good_size	common/OpenBSD_malloc_Linux.c	/^size_t malloc_good_size(size_t size)$/;"	f
malloc_guard	common/OpenBSD_malloc_Linux.c	/^static size_t	malloc_guard = 0;$/;"	v	file:
malloc_guarded	common/OpenBSD_malloc_Linux.c	/^static size_t	malloc_guarded;$/;"	v	file:
malloc_hint	common/OpenBSD_malloc_Linux.c	/^static int	malloc_hint = 1;$/;"	v	file:
malloc_init	common/OpenBSD_malloc_Linux.c	/^malloc_init(void)$/;"	f	file:
malloc_junk	common/OpenBSD_malloc_Linux.c	/^static int	malloc_junk;$/;"	v	file:
malloc_make_chunks	common/OpenBSD_malloc_Linux.c	/^malloc_make_chunks(int bits)$/;"	f	file:
malloc_maxsize	common/OpenBSD_malloc_Linux.c	/^#define malloc_maxsize	/;"	d	file:
malloc_minsize	common/OpenBSD_malloc_Linux.c	/^#define malloc_minsize	/;"	d	file:
malloc_options	common/OpenBSD_malloc_Linux.c	/^char		*malloc_options;$/;"	v
malloc_pagemask	common/OpenBSD_malloc_Linux.c	/^#define malloc_pagemask	/;"	d	file:
malloc_pages	common/OpenBSD_malloc_Linux.c	/^malloc_pages(size_t size)$/;"	f	file:
malloc_pageshift	common/OpenBSD_malloc_Linux.c	/^#define	malloc_pageshift	/;"	d	file:
malloc_pageshift	common/OpenBSD_malloc_Linux.c	/^#define malloc_pageshift	/;"	d	file:
malloc_pagesize	common/OpenBSD_malloc_Linux.c	/^#define malloc_pagesize	/;"	d	file:
malloc_ptrguard	common/OpenBSD_malloc_Linux.c	/^static int	malloc_ptrguard;$/;"	v	file:
malloc_realloc	common/OpenBSD_malloc_Linux.c	/^static int	malloc_realloc;$/;"	v	file:
malloc_recurse	common/OpenBSD_malloc_Linux.c	/^malloc_recurse(void)$/;"	f	file:
malloc_silent	common/OpenBSD_malloc_Linux.c	/^static int	malloc_silent;$/;"	v	file:
malloc_started	common/OpenBSD_malloc_Linux.c	/^static unsigned int	malloc_started;$/;"	v	file:
malloc_stats	common/OpenBSD_malloc_Linux.c	/^static int	malloc_stats;$/;"	v	file:
malloc_used	common/OpenBSD_malloc_Linux.c	/^static size_t	malloc_used;$/;"	v	file:
malloc_utrace	common/OpenBSD_malloc_Linux.c	/^static int	malloc_utrace;$/;"	v	file:
malloc_xmalloc	common/OpenBSD_malloc_Linux.c	/^static int	malloc_xmalloc;$/;"	v	file:
malloc_zero	common/OpenBSD_malloc_Linux.c	/^static int	malloc_zero;$/;"	v	file:
managed_proxy_create	or/transports.c	/^managed_proxy_create(const smartlist_t *transport_list,$/;"	f	file:
managed_proxy_destroy	or/transports.c	/^managed_proxy_destroy(managed_proxy_t *mp,$/;"	f	file:
managed_proxy_has_argv	or/transports.c	/^managed_proxy_has_argv(const managed_proxy_t *mp, char **proxy_argv)$/;"	f	file:
managed_proxy_list	or/transports.c	/^static smartlist_t *managed_proxy_list = NULL;$/;"	v	file:
managed_proxy_t	or/transports.h	/^} managed_proxy_t;$/;"	t	typeref:struct:__anon71
map_pages	common/OpenBSD_malloc_Linux.c	/^map_pages(size_t pages)$/;"	f	file:
mapping_size	common/compat.h	/^  size_t mapping_size; \/**< Size of the actual mapping. (This is this file$/;"	m	struct:tor_mmap_t
mark_all_trusteddirservers_up	or/routerlist.c	/^mark_all_trusteddirservers_up(void)$/;"	f	file:
mark_bridge_list	or/circuitbuild.c	/^mark_bridge_list(void)$/;"	f
mark_logs_temp	common/log.c	/^mark_logs_temp(void)$/;"	f
mark_my_descriptor_dirty	or/router.c	/^mark_my_descriptor_dirty(const char *reason)$/;"	f
mark_my_descriptor_dirty_if_too_old	or/router.c	/^mark_my_descriptor_dirty_if_too_old(time_t now)$/;"	f
mark_or_down	or/rephist.c	/^mark_or_down(or_history_t *hist, time_t when, int failed)$/;"	f	file:
mark_or_up	or/rephist.c	/^mark_or_up(or_history_t *hist, time_t when)$/;"	f	file:
mark_socket_open	common/compat.c	/^#define mark_socket_open(/;"	d	file:
mark_socket_open	common/compat.c	/^mark_socket_open(tor_socket_t s)$/;"	f	file:
mark_transport_list	or/circuitbuild.c	/^mark_transport_list(void)$/;"	f
marked_for_close	or/or.h	/^  uint16_t marked_for_close; \/**< Should we close this circuit at the end of$/;"	m	struct:circuit_t
marked_for_close	or/or.h	/^  uint16_t marked_for_close; \/**< Should we close this conn on the next$/;"	m	struct:connection_t
marked_for_close_file	or/or.h	/^  const char *marked_for_close_file; \/**< For debugging: in which file was this$/;"	m	struct:circuit_t
marked_for_close_file	or/or.h	/^  const char *marked_for_close_file; \/**< For debugging: in which file were$/;"	m	struct:connection_t
marked_for_removal	or/circuitbuild.c	/^  unsigned marked_for_removal : 1;$/;"	m	struct:__anon19	file:
marked_for_removal	or/circuitbuild.h	/^  unsigned marked_for_removal : 1;$/;"	m	struct:__anon20
marked_for_removal	or/transports.h	/^  unsigned int marked_for_removal : 1;$/;"	m	struct:__anon71
mask	common/container.h	/^  int mask; \/**< One less than the number of bits in <b>ba<\/b>; always one less$/;"	m	struct:__anon8
maskbits	or/or.h	/^  maskbits_t maskbits; \/**< Accept\/reject all addresses <b>a<\/b> such that the$/;"	m	struct:addr_policy_t
maskbits_t	common/address.h	/^typedef uint8_t maskbits_t;$/;"	t
masks	common/torlog.h	/^  log_domain_mask_t masks[LOG_DEBUG-LOG_ERR+1];$/;"	m	struct:log_severity_list_t
max_args	or/routerparse.c	/^  int max_args;$/;"	m	struct:token_rule_t	file:
max_cnt	or/routerparse.c	/^  int max_cnt;$/;"	m	struct:token_rule_t	file:
max_length	or/buffers.c	/^  int max_length; \/**< Never allow more than this number of chunks in the$/;"	m	struct:chunk_freelist_t	file:
max_port	or/or.h	/^  uint16_t min_port, max_port;$/;"	m	struct:short_policy_entry_t
max_socket	common/compat.c	/^static int max_socket = -1;$/;"	v	file:
max_total	or/rephist.c	/^  uint64_t max_total; \/**< Largest value that total_obs has taken on in the$/;"	m	struct:bw_array_t	file:
maxima	or/rephist.c	/^  uint64_t maxima[NUM_TOTALS];$/;"	m	struct:bw_array_t	file:
may_use_optimistic_data	or/or.h	/^  unsigned int may_use_optimistic_data : 1;$/;"	m	struct:entry_connection_t
md	or/or.h	/^  microdesc_t *md;$/;"	m	struct:node_t
mean_num_cells_in_queue	or/rephist.c	/^  double mean_num_cells_in_queue;$/;"	m	struct:circ_buffer_stats_t	file:
mean_time_cells_in_queue	or/rephist.c	/^  double mean_time_cells_in_queue;$/;"	m	struct:circ_buffer_stats_t	file:
measured_bw	or/or.h	/^  uint32_t measured_bw; \/**< Measured bandwidth (capacity) of the router *\/$/;"	m	struct:routerstatus_t
measured_bw_line_apply	or/dirserv.c	/^measured_bw_line_apply(measured_bw_line_t *parsed_line,$/;"	f
measured_bw_line_parse	or/dirserv.c	/^measured_bw_line_parse(measured_bw_line_t *out, const char *orig_line)$/;"	f
measured_bw_line_t	or/or.h	/^typedef struct measured_bw_line_t {$/;"	s
measured_bw_line_t	or/or.h	/^} measured_bw_line_t;$/;"	t	typeref:struct:measured_bw_line_t
median	test/test_containers.c	/^#define median(/;"	d	file:
median	test/test_containers.c	/^#undef median$/;"	d	file:
median_double	common/container.h	/^median_double(double *array, int n_elements)$/;"	f
median_int	common/container.h	/^median_int(int *array, int n_elements)$/;"	f
median_int32	common/container.h	/^median_int32(int32_t *array, int n_elements)$/;"	f
median_long	common/container.h	/^median_long(long *array, int n_elements)$/;"	f
median_time	common/container.h	/^median_time(time_t *array, int n_elements)$/;"	f
median_uint32	common/container.h	/^median_uint32(uint32_t *array, int n_elements)$/;"	f
mem	common/memarea.c	/^    char mem[1]; \/**< Memory space in this chunk.  *\/$/;"	m	union:memarea_chunk_t::__anon12	file:
mem	common/mempool.c	/^    char mem[1];$/;"	m	union:mp_allocated_t::__anon13	file:
mem	common/mempool.c	/^  char mem[FLEXIBLE_ARRAY_MEMBER]; \/**< Storage for this chunk. *\/$/;"	m	struct:mp_chunk_t	file:
mem	or/buffers.c	/^  char mem[FLEXIBLE_ARRAY_MEMBER]; \/**< The actual memory used for storage in$/;"	m	struct:chunk_t	file:
mem_size	common/memarea.c	/^  size_t mem_size; \/**< How much RAM is available in u.mem, total? *\/$/;"	m	struct:memarea_chunk_t	file:
mem_size	common/mempool.c	/^  size_t mem_size; \/**< Number of usable bytes in mem. *\/$/;"	m	struct:mp_chunk_t	file:
memalign	common/OpenBSD_malloc_Linux.c	/^void *memalign(size_t boundary, size_t size)$/;"	f
memarea_alloc	common/memarea.c	/^memarea_alloc(memarea_t *area, size_t sz)$/;"	f
memarea_alloc_zero	common/memarea.c	/^memarea_alloc_zero(memarea_t *area, size_t sz)$/;"	f
memarea_assert_ok	common/memarea.c	/^memarea_assert_ok(memarea_t *area)$/;"	f
memarea_chunk_t	common/memarea.c	/^typedef struct memarea_chunk_t {$/;"	s	file:
memarea_chunk_t	common/memarea.c	/^} memarea_chunk_t;$/;"	t	typeref:struct:memarea_chunk_t	file:
memarea_clear	common/memarea.c	/^memarea_clear(memarea_t *area)$/;"	f
memarea_clear_freelist	common/memarea.c	/^memarea_clear_freelist(void)$/;"	f
memarea_drop_all	common/memarea.c	/^memarea_drop_all(memarea_t *area)$/;"	f
memarea_get_stats	common/memarea.c	/^memarea_get_stats(memarea_t *area, size_t *allocated_out, size_t *used_out)$/;"	f
memarea_memdup	common/memarea.c	/^memarea_memdup(memarea_t *area, const void *s, size_t n)$/;"	f
memarea_new	common/memarea.c	/^memarea_new(void)$/;"	f
memarea_owns_ptr	common/memarea.c	/^memarea_owns_ptr(const memarea_t *area, const void *p)$/;"	f
memarea_strdup	common/memarea.c	/^memarea_strdup(memarea_t *area, const char *s)$/;"	f
memarea_strndup	common/memarea.c	/^memarea_strndup(memarea_t *area, const char *s, size_t n)$/;"	f
memarea_t	common/memarea.c	/^struct memarea_t {$/;"	s	file:
memarea_t	common/memarea.h	/^typedef struct memarea_t memarea_t;$/;"	t	typeref:struct:memarea_t
memeq_opt	or/connection_edge.c	/^memeq_opt(const char *a, size_t alen, const char *b, size_t blen)$/;"	f	file:
memlen	or/buffers.c	/^  size_t memlen; \/**< The number of usable bytes of storage in <b>mem<\/b>. *\/$/;"	m	struct:chunk_t	file:
memory_units	or/config.c	/^static struct unit_table_t memory_units[] = {$/;"	v	typeref:struct:unit_table_t	file:
method_bits	common/torgzip.c	/^method_bits(compress_method_t method)$/;"	f	file:
micro	or/or.h	/^  int micro;$/;"	m	struct:tor_version_t
microdesc	or/or.h	/^  vote_microdesc_hash_t *microdesc;$/;"	m	struct:vote_routerstatus_t
microdesc_average_size	or/microdesc.c	/^microdesc_average_size(microdesc_cache_t *cache)$/;"	f
microdesc_cache_clean	or/microdesc.c	/^microdesc_cache_clean(microdesc_cache_t *cache, time_t cutoff, int force)$/;"	f
microdesc_cache_clear	or/microdesc.c	/^microdesc_cache_clear(microdesc_cache_t *cache)$/;"	f
microdesc_cache_lookup_by_digest256	or/microdesc.c	/^microdesc_cache_lookup_by_digest256(microdesc_cache_t *cache, const char *d)$/;"	f
microdesc_cache_rebuild	or/microdesc.c	/^microdesc_cache_rebuild(microdesc_cache_t *cache, int force)$/;"	f
microdesc_cache_reload	or/microdesc.c	/^microdesc_cache_reload(microdesc_cache_t *cache)$/;"	f
microdesc_cache_t	or/microdesc.c	/^struct microdesc_cache_t {$/;"	s	file:
microdesc_cache_t	or/or.h	/^typedef struct microdesc_cache_t microdesc_cache_t;$/;"	t	typeref:struct:microdesc_cache_t
microdesc_check_counts	or/microdesc.c	/^microdesc_check_counts(void)$/;"	f
microdesc_consensus_methods	or/dirvote.c	/^static char *microdesc_consensus_methods = NULL;$/;"	v	file:
microdesc_free	or/microdesc.c	/^microdesc_free(microdesc_t *md)$/;"	f
microdesc_free_all	or/microdesc.c	/^microdesc_free_all(void)$/;"	f
microdesc_hash_line	or/or.h	/^  char *microdesc_hash_line;$/;"	m	struct:vote_microdesc_hash_t
microdesc_list_missing_digest256	or/microdesc.c	/^microdesc_list_missing_digest256(networkstatus_t *ns, microdesc_cache_t *cache,$/;"	f
microdesc_t	or/or.h	/^typedef struct microdesc_t {$/;"	s
microdesc_t	or/or.h	/^} microdesc_t;$/;"	t	typeref:struct:microdesc_t
microdesc_tests	test/test_microdesc.c	/^struct testcase_t microdesc_tests[] = {$/;"	v	typeref:struct:testcase_t
microdesc_token_table	or/routerparse.c	/^static token_rule_t microdesc_token_table[] = {$/;"	v	file:
microdescs_add_list_to_cache	or/microdesc.c	/^microdescs_add_list_to_cache(microdesc_cache_t *cache,$/;"	f
microdescs_add_to_cache	or/microdesc.c	/^microdescs_add_to_cache(microdesc_cache_t *cache,$/;"	f
microdescs_parse_from_string	or/routerparse.c	/^microdescs_parse_from_string(const char *s, const char *eos,$/;"	f
min_args	or/routerparse.c	/^  int min_args;$/;"	m	struct:token_rule_t	file:
min_cnt	or/routerparse.c	/^  int min_cnt;$/;"	m	struct:token_rule_t	file:
min_empty_chunks	common/mempool.h	/^  int min_empty_chunks;$/;"	m	struct:mp_pool_t
min_port	or/or.h	/^  uint16_t min_port, max_port;$/;"	m	struct:short_policy_entry_t
minheap_idx	or/dns.c	/^  int minheap_idx;$/;"	m	struct:cached_resolve_t	file:
miniupnpc_state_t	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^typedef struct miniupnpc_state_t {$/;"	s
miniupnpc_state_t	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^} miniupnpc_state_t;$/;"	t	typeref:struct:miniupnpc_state_t
minor	or/or.h	/^  int minor;$/;"	m	struct:tor_version_t
mm_free	or/eventdns.c	/^#define mm_free(/;"	d	file:
mm_malloc	or/eventdns.c	/^#define mm_malloc(/;"	d	file:
mm_realloc	or/eventdns.c	/^#define mm_realloc(/;"	d	file:
mm_strdup	or/eventdns.c	/^#define mm_strdup(/;"	d	file:
mmap	or/or.h	/^  tor_mmap_t *mmap; \/**< A mmap for the main file in the store. *\/$/;"	m	struct:desc_store_t
mmap_handle	common/compat.h	/^  HANDLE mmap_handle;$/;"	m	struct:tor_mmap_t
monitor_owning_controller_process	or/control.c	/^monitor_owning_controller_process(const char *process_spec)$/;"	f
months_lifetime	tools/tor-gencert.c	/^int months_lifetime = DEFAULT_LIFETIME;$/;"	v
mostly_read	or/rephist.c	/^static uint32_t mostly_read = 0;$/;"	v	file:
mostly_written	or/rephist.c	/^static uint32_t mostly_written = 0;$/;"	v	file:
move_buf_to_buf	or/buffers.c	/^move_buf_to_buf(buf_t *buf_out, buf_t *buf_in, size_t *buf_flushlen)$/;"	f
mp_allocated_t	common/mempool.c	/^struct mp_allocated_t {$/;"	s	file:
mp_allocated_t	common/mempool.c	/^typedef struct mp_allocated_t mp_allocated_t;$/;"	t	typeref:struct:mp_allocated_t	file:
mp_chunk_new	common/mempool.c	/^mp_chunk_new(mp_pool_t *pool)$/;"	f	file:
mp_chunk_t	common/mempool.c	/^struct mp_chunk_t {$/;"	s	file:
mp_chunk_t	common/mempool.c	/^typedef struct mp_chunk_t mp_chunk_t;$/;"	t	typeref:struct:mp_chunk_t	file:
mp_pool_assert_ok	common/mempool.c	/^mp_pool_assert_ok(mp_pool_t *pool)$/;"	f
mp_pool_clean	common/mempool.c	/^mp_pool_clean(mp_pool_t *pool, int n_to_keep, int keep_recently_used)$/;"	f
mp_pool_destroy	common/mempool.c	/^mp_pool_destroy(mp_pool_t *pool)$/;"	f
mp_pool_get	common/mempool.c	/^mp_pool_get(mp_pool_t *pool)$/;"	f
mp_pool_log_status	common/mempool.c	/^mp_pool_log_status(mp_pool_t *pool, int severity)$/;"	f
mp_pool_new	common/mempool.c	/^mp_pool_new(size_t item_size, size_t chunk_capacity)$/;"	f
mp_pool_release	common/mempool.c	/^mp_pool_release(void *item)$/;"	f
mp_pool_sort_used_chunks	common/mempool.c	/^mp_pool_sort_used_chunks(mp_pool_t *pool)$/;"	f	file:
mp_pool_sort_used_chunks_helper	common/mempool.c	/^mp_pool_sort_used_chunks_helper(const void *_a, const void *_b)$/;"	f	file:
mp_pool_t	common/mempool.h	/^struct mp_pool_t {$/;"	s
mp_pool_t	common/mempool.h	/^typedef struct mp_pool_t mp_pool_t;$/;"	t	typeref:struct:mp_pool_t
msec_per_tick	common/compat_libevent.h	/^  int msec_per_tick;$/;"	m	struct:tor_libevent_cfg
msg	common/compat.c	/^struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	m	struct:__anon5	file:
msg	common/log.c	/^  char *msg; \/**< The content of the message *\/$/;"	m	struct:pending_cb_message_t	file:
multiplier	or/config.c	/^  uint64_t multiplier; \/**< How many of the base unit appear in this unit *\/$/;"	m	struct:unit_table_t	file:
munge_extrainfo_into_routerinfo	or/control.c	/^munge_extrainfo_into_routerinfo(const char *ri_body,$/;"	f	file:
mutex	common/compat.h	/^  CRITICAL_SECTION mutex;$/;"	m	struct:tor_mutex_t
my_auth_cert	common/tortls.c	/^  tor_cert_t *my_auth_cert;$/;"	m	struct:tor_tls_context_t	file:
my_id_cert	common/tortls.c	/^  tor_cert_t *my_id_cert;$/;"	m	struct:tor_tls_context_t	file:
my_link_cert	common/tortls.c	/^  tor_cert_t *my_link_cert;$/;"	m	struct:tor_tls_context_t	file:
n	or/or.h	/^  int n; \/**< The number of cells in the queue. *\/$/;"	m	struct:cell_queue_t
n_additional	or/eventdns.c	/^	int n_additional; \/* how many additional RRs have been set? *\/$/;"	m	struct:server_request	file:
n_alloc	or/buffers.c	/^  uint64_t n_alloc;$/;"	m	struct:chunk_freelist_t	file:
n_allocated	common/mempool.c	/^  int n_allocated; \/**< Number of currently allocated items in this chunk. *\/$/;"	m	struct:mp_chunk_t	file:
n_answer	or/eventdns.c	/^	int n_answer; \/* how many answer RRs have been set? *\/$/;"	m	struct:server_request	file:
n_args	or/routerparse.c	/^  int n_args:30;               \/**< Number of elements in args *\/$/;"	m	struct:directory_token_t	file:
n_authority	or/eventdns.c	/^	int n_authority; \/* how many authority RRs have been set? *\/$/;"	m	struct:server_request	file:
n_backends	tools/tor-fw-helper/tor-fw-helper.c	/^  int n_backends;$/;"	m	struct:backends_t	file:
n_bad	test/tinytest.c	/^static int n_bad = 0; \/**< Number of tests that have failed. *\/$/;"	v	file:
n_bits_set_u8	common/util.c	/^n_bits_set_u8(uint8_t v)$/;"	f
n_bogus_times	or/rephist.c	/^static int n_bogus_times = 0;$/;"	v	file:
n_bytes_at_soft_limit	or/hibernate.c	/^static uint64_t n_bytes_at_soft_limit = 0;$/;"	v	file:
n_bytes_read_in_interval	or/hibernate.c	/^static uint64_t n_bytes_read_in_interval = 0;$/;"	v	file:
n_bytes_written_in_interval	or/hibernate.c	/^static uint64_t n_bytes_written_in_interval = 0;$/;"	v	file:
n_calls_since_last_time	common/util.h	/^  int n_calls_since_last_time;$/;"	m	struct:ratelim_t
n_cell_ewma	or/or.h	/^  cell_ewma_t n_cell_ewma;$/;"	m	struct:circuit_t
n_circ_id	or/or.h	/^  circid_t n_circ_id;$/;"	m	struct:circuit_t
n_circuit_failures	or/circuituse.c	/^static int n_circuit_failures = 0;$/;"	v	file:
n_circuits	or/or.h	/^  int n_circuits; \/**< How many circuits use this connection as p_conn or$/;"	m	struct:or_connection_t
n_conn	or/or.h	/^  or_connection_t *n_conn;$/;"	m	struct:circuit_t
n_conn_cells	or/or.h	/^  cell_queue_t n_conn_cells;$/;"	m	struct:circuit_t
n_conn_fail	or/rephist.c	/^  unsigned long n_conn_fail;$/;"	m	struct:or_history_t	file:
n_conn_ok	or/rephist.c	/^  unsigned long n_conn_ok;$/;"	m	struct:or_history_t	file:
n_conn_onionskin	or/or.h	/^  char *n_conn_onionskin;$/;"	m	struct:circuit_t
n_countries	or/routerlist.c	/^  int n_countries;$/;"	m	struct:routerset_t	file:
n_crypto	or/or.h	/^  crypto_cipher_t *n_crypto;$/;"	m	struct:or_circuit_t
n_digest	or/or.h	/^  crypto_digest_t *n_digest;$/;"	m	struct:or_circuit_t
n_download_failures	or/or.h	/^  uint8_t n_download_failures; \/**< Number of failures trying to download the$/;"	m	struct:download_status_t
n_empty_chunks	common/mempool.h	/^  int n_empty_chunks;$/;"	m	struct:mp_pool_t
n_entries	or/or.h	/^  unsigned int n_entries : 31;$/;"	m	struct:short_policy_t
n_extend_fail	or/rephist.c	/^  unsigned long n_extend_fail;$/;"	m	struct:link_history_t	file:
n_extend_ok	or/rephist.c	/^  unsigned long n_extend_ok;$/;"	m	struct:link_history_t	file:
n_free	or/buffers.c	/^  uint64_t n_free;$/;"	m	struct:chunk_freelist_t	file:
n_freelist_miss	or/buffers.c	/^static uint64_t n_freelist_miss = 0;$/;"	v	file:
n_hit	or/buffers.c	/^  uint64_t n_hit;$/;"	m	struct:chunk_freelist_t	file:
n_hop	or/or.h	/^  extend_info_t *n_hop;$/;"	m	struct:circuit_t
n_intervals_valid	or/or.h	/^  int n_intervals_valid;$/;"	m	struct:vote_timing_t
n_intro_circuits_launched	or/rendservice.c	/^  int n_intro_circuits_launched; \/**< Count of intro circuits we have$/;"	m	struct:rend_service_t	file:
n_intro_points_wanted	or/rendservice.c	/^  unsigned int n_intro_points_wanted; \/**< Number of intro points this$/;"	m	struct:rend_service_t	file:
n_labels	or/eventdns.c	/^	int n_labels; \/* number of current entries *\/$/;"	m	struct:dnslabel_table	file:
n_leapdays	common/util.c	/^n_leapdays(int y1, int y2)$/;"	f	file:
n_libevent_errors	or/main.c	/^static int n_libevent_errors = 0;$/;"	v	file:
n_ok	test/tinytest.c	/^static int n_ok = 0; \/**< Number of tests that have passed *\/$/;"	v	file:
n_onionskins_decrypted	or/rephist.c	/^  unsigned long n_onionskins_decrypted;$/;"	m	struct:__anon68	file:
n_onionskins_encrypted	or/rephist.c	/^  unsigned long n_onionskins_encrypted;$/;"	m	struct:__anon68	file:
n_or_protocol_versions	or/connection_or.c	/^static const int n_or_protocol_versions =$/;"	v	file:
n_read	or/or.h	/^  uint32_t n_read;$/;"	m	struct:edge_connection_t
n_rend_client_ops	or/rephist.c	/^  unsigned long n_rend_client_ops;$/;"	m	struct:__anon68	file:
n_rend_mid_ops	or/rephist.c	/^  unsigned long n_rend_mid_ops;$/;"	m	struct:__anon68	file:
n_rend_server_ops	or/rephist.c	/^  unsigned long n_rend_server_ops;$/;"	m	struct:__anon68	file:
n_seconds_active_in_interval	or/hibernate.c	/^static uint32_t n_seconds_active_in_interval = 0;$/;"	v	file:
n_seconds_to_hit_soft_limit	or/hibernate.c	/^static int n_seconds_to_hit_soft_limit = 0;$/;"	v	file:
n_seen	or/microdesc.c	/^  unsigned n_seen;$/;"	m	struct:microdesc_cache_t	file:
n_signed_dir_objs	or/rephist.c	/^  unsigned long n_signed_dir_objs;$/;"	m	struct:__anon68	file:
n_signed_routerdescs	or/rephist.c	/^  unsigned long n_signed_routerdescs;$/;"	m	struct:__anon68	file:
n_skipped	test/tinytest.c	/^static int n_skipped = 0; \/**< Number of tests that have been skipped. *\/$/;"	v	file:
n_sockets_open	common/compat.c	/^static int n_sockets_open = 0;$/;"	v	file:
n_streams	or/or.h	/^  edge_connection_t *n_streams;$/;"	m	struct:or_circuit_t
n_tls_client_handshakes	or/rephist.c	/^  unsigned long n_tls_client_handshakes;$/;"	m	struct:__anon68	file:
n_tls_server_handshakes	or/rephist.c	/^  unsigned long n_tls_server_handshakes;$/;"	m	struct:__anon68	file:
n_v2_ns_requests	or/geoip.c	/^  uint32_t n_v2_ns_requests;$/;"	m	struct:geoip_country_t	file:
n_v3_ns_requests	or/geoip.c	/^  uint32_t n_v3_ns_requests;$/;"	m	struct:geoip_country_t	file:
n_verified_dir_objs	or/rephist.c	/^  unsigned long n_verified_dir_objs;$/;"	m	struct:__anon68	file:
n_verified_routerdescs	or/rephist.c	/^  unsigned long n_verified_routerdescs;$/;"	m	struct:__anon68	file:
n_wildcard_requests	or/dns.c	/^static int n_wildcard_requests = 0;$/;"	v	file:
n_written	or/or.h	/^  uint32_t n_written;$/;"	m	struct:edge_connection_t
name	common/tortls.c	/^typedef struct cipher_info_t { unsigned id; const char *name; } cipher_info_t;$/;"	m	struct:cipher_info_t	file:
name	or/circuitbuild.h	/^  char *name;$/;"	m	struct:__anon20
name	or/config.c	/^  const char *name; \/**< The full keyword (case insensitive). *\/$/;"	m	struct:config_var_t	file:
name	or/config.c	/^  const char *name;$/;"	m	struct:config_var_description_t	file:
name	or/eventdns.c	/^			char name[HOST_NAME_MAX];$/;"	m	struct:reply::__anon28::__anon31	file:
name	or/eventdns.c	/^	char *name; \/* name part of the RR *\/$/;"	m	struct:server_reply_item	file:
name	or/eventdns.h	/^	char name[1];$/;"	m	struct:evdns_server_question
name	test/bench.c	/^  const char *name;$/;"	m	struct:benchmark_t	file:
name	test/tinytest.h	/^	const char *name; \/**< An identifier for this case. *\/$/;"	m	struct:testcase_t
name	tools/tor-fw-helper/tor-fw-helper.h	/^  const char *name;$/;"	m	struct:tor_fw_backend_t
name_lookup_warned	or/or.h	/^  unsigned int name_lookup_warned:1; \/**< Have we warned the user for referring$/;"	m	struct:node_t
name_parse	or/eventdns.c	/^name_parse(u8 *packet, int length, int *idx, char *name_out, size_t name_out_len) {$/;"	f	file:
named_server_map	or/networkstatus.c	/^static strmap_t *named_server_map = NULL;$/;"	v	file:
names	or/routerlist.c	/^  strmap_t *names;$/;"	m	struct:routerset_t	file:
nameserver	or/eventdns.c	/^struct nameserver {$/;"	s	file:
nameserver_config_failed	or/dns.c	/^static int nameserver_config_failed = 0;$/;"	v	file:
nameserver_failed	or/eventdns.c	/^nameserver_failed(struct nameserver *const ns, const char *msg) {$/;"	f	file:
nameserver_pick	or/eventdns.c	/^nameserver_pick(void) {$/;"	f	file:
nameserver_probe_callback	or/eventdns.c	/^nameserver_probe_callback(int result, char type, int count, int ttl, void *addresses, void *arg) {$/;"	f	file:
nameserver_probe_failed	or/eventdns.c	/^nameserver_probe_failed(struct nameserver *const ns) {$/;"	f	file:
nameserver_prod_callback	or/eventdns.c	/^nameserver_prod_callback(int fd, short events, void *arg) {$/;"	f	file:
nameserver_read	or/eventdns.c	/^nameserver_read(struct nameserver *ns) {$/;"	f	file:
nameserver_ready_callback	or/eventdns.c	/^nameserver_ready_callback(int fd, short events, void *arg) {$/;"	f	file:
nameserver_send_probe	or/eventdns.c	/^nameserver_send_probe(struct nameserver *const ns) {$/;"	f	file:
nameserver_up	or/eventdns.c	/^nameserver_up(struct nameserver *const ns) {$/;"	f	file:
nameserver_write_waiting	or/eventdns.c	/^nameserver_write_waiting(struct nameserver *ns, char waiting) {$/;"	f	file:
nameservers_configured	or/dns.c	/^static int nameservers_configured = 0;$/;"	v	file:
nanostart	test/bench.c	/^static uint64_t nanostart;$/;"	v	file:
nat_pmp_status	tools/tor-fw-helper/tor-fw-helper.h	/^  int nat_pmp_status;$/;"	m	struct:__anon72
natpmp	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  natpmp_t natpmp;$/;"	m	struct:natpmp_state_t
natpmp_state_t	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^typedef struct natpmp_state_t {$/;"	s
natpmp_state_t	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^} natpmp_state_t;$/;"	t	typeref:struct:natpmp_state_t
ndots	or/eventdns.c	/^	int ndots;$/;"	m	struct:search_state	file:
need_capacity	or/or.h	/^  unsigned int need_capacity : 1;$/;"	m	struct:__anon47
need_to_mirror	or/or.h	/^  unsigned int need_to_mirror:1;$/;"	m	struct:routerstatus_t
need_to_update_have_min_dir_info	or/routerlist.c	/^static int need_to_update_have_min_dir_info = 1;$/;"	v	file:
need_uptime	or/or.h	/^  unsigned int need_uptime : 1;$/;"	m	struct:__anon47
needs_close	common/log.c	/^  int needs_close; \/**< Boolean: true if the stream gets closed on shutdown. *\/$/;"	m	struct:logfile_t	file:
needs_retest_if_added	or/or.h	/^  unsigned int needs_retest_if_added:1;$/;"	m	struct:__anon41
negotiated_callback	common/tortls.c	/^  void (*negotiated_callback)(tor_tls_t *tls, void *arg);$/;"	m	struct:tor_tls_t	file:
net_is_disabled	or/router.c	/^net_is_disabled(void)$/;"	f
net_params	or/or.h	/^  smartlist_t *net_params;$/;"	m	struct:networkstatus_t
netstatus_token_table	or/routerparse.c	/^static token_rule_t netstatus_token_table[] = {$/;"	v	file:
network_init	common/compat.c	/^network_init(void)$/;"	f
network_init	tools/tor-fw-helper/tor-fw-helper.c	/^network_init(void)$/;"	f	file:
network_last_live	or/or.h	/^  time_t network_last_live;$/;"	m	struct:__anon53
network_liveness_t	or/or.h	/^} network_liveness_t;$/;"	t	typeref:struct:__anon53
networkstatus_add_detached_signatures	or/dirvote.c	/^networkstatus_add_detached_signatures(networkstatus_t *target,$/;"	f
networkstatus_check_consensus_signature	or/networkstatus.c	/^networkstatus_check_consensus_signature(networkstatus_t *consensus,$/;"	f
networkstatus_check_document_signature	or/networkstatus.c	/^networkstatus_check_document_signature(const networkstatus_t *consensus,$/;"	f
networkstatus_check_weights	or/dirvote.c	/^networkstatus_check_weights(int64_t Wgg, int64_t Wgd, int64_t Wmg,$/;"	f	file:
networkstatus_compute_bw_weights_v10	or/dirvote.c	/^networkstatus_compute_bw_weights_v10(smartlist_t *chunks, int64_t G,$/;"	f	file:
networkstatus_compute_bw_weights_v9	or/dirvote.c	/^networkstatus_compute_bw_weights_v9(smartlist_t *chunks, int64_t G, int64_t M,$/;"	f	file:
networkstatus_compute_consensus	or/dirvote.c	/^networkstatus_compute_consensus(smartlist_t *votes,$/;"	f
networkstatus_consensus_download_failed	or/networkstatus.c	/^networkstatus_consensus_download_failed(int status_code, const char *flavname)$/;"	f
networkstatus_consensus_token_table	or/routerparse.c	/^static token_rule_t networkstatus_consensus_token_table[] = {$/;"	v	file:
networkstatus_copy_old_consensus_info	or/networkstatus.c	/^networkstatus_copy_old_consensus_info(networkstatus_t *new_c,$/;"	f	file:
networkstatus_detached_signature_token_table	or/routerparse.c	/^static token_rule_t networkstatus_detached_signature_token_table[] = {$/;"	v	file:
networkstatus_digest	or/or.h	/^  char networkstatus_digest[DIGEST_LEN];$/;"	m	struct:networkstatus_v2_t
networkstatus_dump_bridge_status_to_file	or/networkstatus.c	/^networkstatus_dump_bridge_status_to_file(time_t now)$/;"	f
networkstatus_format_signatures	or/dirvote.c	/^networkstatus_format_signatures(networkstatus_t *consensus,$/;"	f	file:
networkstatus_free_all	or/networkstatus.c	/^networkstatus_free_all(void)$/;"	f
networkstatus_get_bw_weight	or/networkstatus.c	/^networkstatus_get_bw_weight(networkstatus_t *ns, const char *weight_name,$/;"	f
networkstatus_get_cache_filename	or/networkstatus.c	/^networkstatus_get_cache_filename(const char *identity_digest)$/;"	f
networkstatus_get_detached_signatures	or/dirvote.c	/^networkstatus_get_detached_signatures(smartlist_t *consensuses)$/;"	f
networkstatus_get_flavor_name	or/networkstatus.c	/^networkstatus_get_flavor_name(consensus_flavor_t flav)$/;"	f
networkstatus_get_latest_consensus	or/networkstatus.c	/^networkstatus_get_latest_consensus(void)$/;"	f
networkstatus_get_latest_consensus_by_flavor	or/networkstatus.c	/^networkstatus_get_latest_consensus_by_flavor(consensus_flavor_t f)$/;"	f
networkstatus_get_live_consensus	or/networkstatus.c	/^networkstatus_get_live_consensus(time_t now)$/;"	f
networkstatus_get_param	or/networkstatus.c	/^networkstatus_get_param(const networkstatus_t *ns, const char *param_name,$/;"	f
networkstatus_get_reasonably_live_consensus	or/networkstatus.c	/^networkstatus_get_reasonably_live_consensus(time_t now, int flavor)$/;"	f
networkstatus_get_router_digest_by_nickname	or/networkstatus.c	/^networkstatus_get_router_digest_by_nickname(const char *nickname)$/;"	f
networkstatus_get_v2_list	or/networkstatus.c	/^networkstatus_get_v2_list(void)$/;"	f
networkstatus_get_voter_by_id	or/networkstatus.c	/^networkstatus_get_voter_by_id(networkstatus_t *vote,$/;"	f
networkstatus_getinfo_by_purpose	or/networkstatus.c	/^networkstatus_getinfo_by_purpose(const char *purpose_string, time_t now)$/;"	f
networkstatus_getinfo_helper_single	or/networkstatus.c	/^networkstatus_getinfo_helper_single(const routerstatus_t *rs)$/;"	f
networkstatus_nickname_is_unnamed	or/networkstatus.c	/^networkstatus_nickname_is_unnamed(const char *nickname)$/;"	f
networkstatus_note_certs_arrived	or/networkstatus.c	/^networkstatus_note_certs_arrived(void)$/;"	f
networkstatus_parse_detached_signatures	or/routerparse.c	/^networkstatus_parse_detached_signatures(const char *s, const char *eos)$/;"	f
networkstatus_parse_flavor_name	or/networkstatus.c	/^networkstatus_parse_flavor_name(const char *flavname)$/;"	f
networkstatus_parse_vote_from_string	or/routerparse.c	/^networkstatus_parse_vote_from_string(const char *s, const char **eos_out,$/;"	f
networkstatus_reset_download_failures	or/networkstatus.c	/^networkstatus_reset_download_failures(void)$/;"	f
networkstatus_reset_warnings	or/networkstatus.c	/^networkstatus_reset_warnings(void)$/;"	f
networkstatus_set_current_consensus	or/networkstatus.c	/^networkstatus_set_current_consensus(const char *consensus,$/;"	f
networkstatus_t	or/or.h	/^typedef struct networkstatus_t {$/;"	s
networkstatus_t	or/or.h	/^} networkstatus_t;$/;"	t	typeref:struct:networkstatus_t
networkstatus_token_table	or/routerparse.c	/^static token_rule_t networkstatus_token_table[] = {$/;"	v	file:
networkstatus_type_t	or/or.h	/^} networkstatus_type_t;$/;"	t	typeref:enum:__anon42
networkstatus_v2_find_entry	or/networkstatus.c	/^networkstatus_v2_find_entry(networkstatus_v2_t *ns, const char *digest)$/;"	f
networkstatus_v2_find_mutable_entry	or/networkstatus.c	/^networkstatus_v2_find_mutable_entry(networkstatus_v2_t *ns, const char *digest)$/;"	f
networkstatus_v2_free	or/networkstatus.c	/^networkstatus_v2_free(networkstatus_v2_t *ns)$/;"	f
networkstatus_v2_get_by_digest	or/networkstatus.c	/^networkstatus_v2_get_by_digest(const char *digest)$/;"	f
networkstatus_v2_list	or/networkstatus.c	/^static smartlist_t *networkstatus_v2_list = NULL;$/;"	v	file:
networkstatus_v2_list_clean	or/networkstatus.c	/^networkstatus_v2_list_clean(time_t now)$/;"	f
networkstatus_v2_list_has_changed	or/networkstatus.c	/^static int networkstatus_v2_list_has_changed = 0;$/;"	v	file:
networkstatus_v2_parse_from_string	or/routerparse.c	/^networkstatus_v2_parse_from_string(const char *s)$/;"	f
networkstatus_v2_t	or/or.h	/^typedef struct networkstatus_v2_t {$/;"	s
networkstatus_v2_t	or/or.h	/^} networkstatus_v2_t;$/;"	t	typeref:struct:networkstatus_v2_t
networkstatus_verify_bw_weights	or/routerparse.c	/^networkstatus_verify_bw_weights(networkstatus_t *ns)$/;"	f
networkstatus_vote_find_entry	or/networkstatus.c	/^networkstatus_vote_find_entry(networkstatus_t *ns, const char *digest)$/;"	f
networkstatus_vote_find_entry_idx	or/networkstatus.c	/^networkstatus_vote_find_entry_idx(networkstatus_t *ns,$/;"	f
networkstatus_vote_find_mutable_entry	or/networkstatus.c	/^networkstatus_vote_find_mutable_entry(networkstatus_t *ns, const char *digest)$/;"	f
networkstatus_vote_footer_token_table	or/routerparse.c	/^static token_rule_t networkstatus_vote_footer_token_table[] = {$/;"	v	file:
networkstatus_vote_free	or/networkstatus.c	/^networkstatus_vote_free(networkstatus_t *ns)$/;"	f
networkstatus_voter_info_t	or/or.h	/^typedef struct networkstatus_voter_info_t {$/;"	s
networkstatus_voter_info_t	or/or.h	/^} networkstatus_voter_info_t;$/;"	t	typeref:struct:networkstatus_voter_info_t
new_address	or/connection_edge.c	/^  char *new_address;$/;"	m	struct:__anon22	file:
new_cached_dir	or/dirserv.c	/^new_cached_dir(char *s, time_t published)$/;"	f
new_chunk_capacity	common/mempool.h	/^  int new_chunk_capacity;$/;"	m	struct:mp_pool_t
new_route_len	or/circuitbuild.c	/^new_route_len(uint8_t purpose, extend_info_t *exit,$/;"	f	file:
newnym_epoch	or/main.c	/^static unsigned newnym_epoch = 0;$/;"	v	file:
next	common/OpenBSD_malloc_Linux.c	/^	struct pdinfo	*next;$/;"	m	struct:pdinfo	typeref:struct:pdinfo::pdinfo	file:
next	common/OpenBSD_malloc_Linux.c	/^	struct pgfree	*next;	\/* next run of free pages *\/$/;"	m	struct:pgfree	typeref:struct:pgfree::pgfree	file:
next	common/OpenBSD_malloc_Linux.c	/^	struct pginfo	*next;	\/* next on the free list *\/$/;"	m	struct:pginfo	typeref:struct:pginfo::pginfo	file:
next	common/log.c	/^  struct logfile_t *next; \/**< Next logfile_t in the linked list. *\/$/;"	m	struct:logfile_t	typeref:struct:logfile_t::logfile_t	file:
next	common/mempool.c	/^  mp_chunk_t *next; \/**< The next free, used, or full chunk in sequence. *\/$/;"	m	struct:mp_chunk_t	file:
next	or/buffers.c	/^  struct chunk_t *next; \/**< The next chunk on the buffer or freelist. *\/$/;"	m	struct:chunk_t	typeref:struct:chunk_t::chunk_t	file:
next	or/dns.c	/^  struct pending_connection_t *next;$/;"	m	struct:pending_connection_t	typeref:struct:pending_connection_t::pending_connection_t	file:
next	or/eventdns.c	/^	struct evdns_request *next, *prev;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::evdns_request	file:
next	or/eventdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::nameserver	file:
next	or/eventdns.c	/^	struct search_domain *next;$/;"	m	struct:search_domain	typeref:struct:search_domain::search_domain	file:
next	or/eventdns.c	/^	struct server_reply_item *next; \/* next item in sequence. *\/$/;"	m	struct:server_reply_item	typeref:struct:server_reply_item::server_reply_item	file:
next	or/onion.c	/^  struct onion_queue_t *next;$/;"	m	struct:onion_queue_t	typeref:struct:onion_queue_t::onion_queue_t	file:
next	or/or.h	/^  struct circuit_t *next; \/**< Next circuit in linked list of all circuits. *\/$/;"	m	struct:circuit_t	typeref:struct:circuit_t::circuit_t
next	or/or.h	/^  struct config_line_t *next;$/;"	m	struct:config_line_t	typeref:struct:config_line_t::config_line_t
next	or/or.h	/^  struct crypt_path_t *next; \/**< Link to next crypt_path_t in the circuit.$/;"	m	struct:crypt_path_t	typeref:struct:crypt_path_t::crypt_path_t
next	or/or.h	/^  struct insertion_time_elem_t *next; \/**< Next element in queue. *\/$/;"	m	struct:insertion_time_elem_t	typeref:struct:insertion_time_elem_t::insertion_time_elem_t
next	or/or.h	/^  struct packed_cell_t *next; \/**< Next cell queued on this circuit. *\/$/;"	m	struct:packed_cell_t	typeref:struct:packed_cell_t::packed_cell_t
next	or/or.h	/^  struct vote_microdesc_hash_t *next;$/;"	m	struct:vote_microdesc_hash_t	typeref:struct:vote_microdesc_hash_t::vote_microdesc_hash_t
next_active_on_n_conn	or/or.h	/^  struct circuit_t *next_active_on_n_conn;$/;"	m	struct:circuit_t	typeref:struct:circuit_t::circuit_t
next_active_on_p_conn	or/or.h	/^  struct circuit_t *next_active_on_p_conn;$/;"	m	struct:or_circuit_t	typeref:struct:or_circuit_t::circuit_t
next_attempt_at	or/or.h	/^  time_t next_attempt_at; \/**< When should we try downloading this descriptor$/;"	m	struct:download_status_t
next_chunk	common/memarea.c	/^  struct memarea_chunk_t *next_chunk;$/;"	m	struct:memarea_chunk_t	typeref:struct:memarea_chunk_t::memarea_chunk_t	file:
next_circ_id	or/or.h	/^  circid_t next_circ_id; \/**< Which circ_id do we try to use next on$/;"	m	struct:or_connection_t
next_circ_on_conn_p	or/relay.c	/^next_circ_on_conn_p(circuit_t *circ, or_connection_t *conn)$/;"	f	file:
next_free	common/mempool.c	/^    mp_allocated_t *next_free;$/;"	m	union:mp_allocated_t::__anon13	file:
next_max_idx	or/rephist.c	/^  int next_max_idx;$/;"	m	struct:bw_array_t	file:
next_mem	common/memarea.c	/^  char *next_mem; \/**< Next position in u.mem to allocate data at.  If it's$/;"	m	struct:memarea_chunk_t	file:
next_mem	common/mempool.c	/^  char *next_mem; \/**< Pointer into part of <b>mem<\/b> not yet carved up. *\/$/;"	m	struct:mp_chunk_t	file:
next_pending	or/eventdns.c	/^	struct server_request *next_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:
next_period	or/rephist.c	/^  time_t next_period;$/;"	m	struct:bw_array_t	file:
next_stream	or/or.h	/^  struct edge_connection_t *next_stream; \/**< Points to the next stream at this$/;"	m	struct:edge_connection_t	typeref:struct:edge_connection_t::edge_connection_t
next_stream_id	or/or.h	/^  streamid_t next_stream_id;$/;"	m	struct:origin_circuit_t
next_upload_time	or/rendservice.c	/^  time_t next_upload_time; \/**< Scheduled next hidden service descriptor$/;"	m	struct:rend_service_t	file:
next_virtual_addr	or/connection_edge.c	/^static uint32_t next_virtual_addr    = 0x7fc00000u;$/;"	v	file:
next_with_same_id	or/or.h	/^  struct or_connection_t *next_with_same_id; \/**< Next connection with same$/;"	m	struct:or_connection_t	typeref:struct:or_connection_t::or_connection_t
next_write	or/or.h	/^  time_t next_write;$/;"	m	struct:__anon52
nickname	or/circuitbuild.c	/^  char nickname[MAX_NICKNAME_LEN+1];$/;"	m	struct:__anon18	file:
nickname	or/dirserv.c	/^  char nickname[MAX_NICKNAME_LEN+1];$/;"	m	struct:router_status_t	file:
nickname	or/or.h	/^  char *nickname; \/**< Human-readable OR name. *\/$/;"	m	struct:__anon41
nickname	or/or.h	/^  char *nickname; \/**< Nickname of OR on other side (if any). *\/$/;"	m	struct:or_connection_t
nickname	or/or.h	/^  char *nickname; \/**< Nickname of this voter *\/$/;"	m	struct:networkstatus_voter_info_t
nickname	or/or.h	/^  char *nickname;$/;"	m	struct:trusted_dir_server_t
nickname	or/or.h	/^  char nickname[MAX_HEX_NICKNAME_LEN+1]; \/**< This router's nickname for$/;"	m	struct:extend_info_t
nickname	or/or.h	/^  char nickname[MAX_NICKNAME_LEN+1]; \/**< The nickname this router says it$/;"	m	struct:routerstatus_t
nickname	or/or.h	/^  char nickname[MAX_NICKNAME_LEN+1];$/;"	m	struct:extrainfo_t
no_advertise	or/or.h	/^  unsigned int no_advertise : 1;$/;"	m	struct:port_cfg_t
no_listen	or/or.h	/^  unsigned int no_listen : 1;$/;"	m	struct:port_cfg_t
no_save	or/or.h	/^  unsigned int no_save : 1;$/;"	m	struct:microdesc_t
node	or/or.h	/^  HT_ENTRY(microdesc_t) node;$/;"	m	struct:microdesc_t
node_allows_single_hop_exits	or/nodelist.c	/^node_allows_single_hop_exits(const node_t *node)$/;"	f
node_describe	or/router.c	/^node_describe(const node_t *node)$/;"	f
node_exit_policy_rejects_all	or/nodelist.c	/^node_exit_policy_rejects_all(const node_t *node)$/;"	f
node_free	or/nodelist.c	/^node_free(node_t *node)$/;"	f	file:
node_get_addr	or/nodelist.c	/^node_get_addr(const node_t *node, tor_addr_t *addr_out)$/;"	f
node_get_addr_ipv4h	or/nodelist.h	/^#define node_get_addr_ipv4h(/;"	d
node_get_address_string	or/nodelist.c	/^node_get_address_string(const node_t *node, char *buf, size_t len)$/;"	f
node_get_all_orports	or/nodelist.c	/^node_get_all_orports(const node_t *node)$/;"	f
node_get_by_hex_id	or/nodelist.c	/^node_get_by_hex_id(const char *hex_id)$/;"	f
node_get_by_id	or/nodelist.c	/^node_get_by_id(const char *identity_digest)$/;"	f
node_get_by_nickname	or/nodelist.c	/^node_get_by_nickname(const char *nickname, int warn_if_unnamed)$/;"	f
node_get_declared_family	or/nodelist.c	/^node_get_declared_family(const node_t *node)$/;"	f
node_get_declared_uptime	or/nodelist.c	/^node_get_declared_uptime(const node_t *node)$/;"	f
node_get_description	or/router.c	/^node_get_description(char *buf, const node_t *node)$/;"	f
node_get_mutable_by_id	or/nodelist.c	/^node_get_mutable_by_id(const char *identity_digest)$/;"	f
node_get_nickname	or/nodelist.c	/^node_get_nickname(const node_t *node)$/;"	f
node_get_or_create	or/nodelist.c	/^node_get_or_create(const char *identity_digest)$/;"	f	file:
node_get_platform	or/nodelist.c	/^node_get_platform(const node_t *node)$/;"	f
node_get_pref_ipv6_orport	or/nodelist.c	/^node_get_pref_ipv6_orport(const node_t *node, tor_addr_port_t *ap_out)$/;"	f
node_get_pref_orport	or/nodelist.c	/^node_get_pref_orport(const node_t *node, tor_addr_port_t *ap_out)$/;"	f
node_get_prim_addr_ipv4h	or/nodelist.c	/^node_get_prim_addr_ipv4h(const node_t *node)$/;"	f
node_get_prim_orport	or/nodelist.c	/^node_get_prim_orport(const node_t *node, tor_addr_port_t *ap_out)$/;"	f
node_get_published_on	or/nodelist.c	/^node_get_published_on(const node_t *node)$/;"	f
node_get_purpose	or/nodelist.c	/^node_get_purpose(const node_t *node)$/;"	f
node_get_verbose_nickname	or/nodelist.c	/^node_get_verbose_nickname(const node_t *node,$/;"	f
node_handles_some_port	or/circuitbuild.c	/^node_handles_some_port(const node_t *node, smartlist_t *needed_ports)$/;"	f	file:
node_has_descriptor	or/nodelist.c	/^node_has_descriptor(const node_t *node)$/;"	f
node_hex	or/or.h	/^  char node_hex[MAX_HEX_NICKNAME_LEN+1];$/;"	m	struct:measured_bw_line_t
node_id	or/or.h	/^  char node_id[DIGEST_LEN];$/;"	m	struct:measured_bw_line_t
node_id_eq	or/nodelist.c	/^node_id_eq(const node_t *node1, const node_t *node2)$/;"	f	file:
node_id_hash	or/nodelist.c	/^node_id_hash(const node_t *node)$/;"	f	file:
node_in_nickname_smartlist	or/routerlist.c	/^node_in_nickname_smartlist(const smartlist_t *lst, const node_t *node)$/;"	f	file:
node_is_a_configured_bridge	or/circuitbuild.c	/^node_is_a_configured_bridge(const node_t *node)$/;"	f
node_is_bridge	or/nodelist.h	/^#define node_is_bridge(/;"	d
node_is_dir	or/nodelist.c	/^node_is_dir(const node_t *node)$/;"	f
node_is_me	or/nodelist.c	/^node_is_me(const node_t *node)$/;"	f
node_is_named	or/nodelist.c	/^node_is_named(const node_t *node)$/;"	f
node_is_unreliable	or/routerlist.c	/^node_is_unreliable(const node_t *node, int need_uptime,$/;"	f
node_is_usable	or/nodelist.c	/^node_is_usable(const node_t *node)$/;"	f	file:
node_nickname_matches	or/routerlist.c	/^node_nickname_matches(const node_t *node, const char *nickname)$/;"	f	file:
node_set_country	or/routerlist.c	/^node_set_country(node_t *node)$/;"	f
node_sl_choose_by_bandwidth	or/routerlist.c	/^node_sl_choose_by_bandwidth(smartlist_t *sl,$/;"	f
node_t	or/or.h	/^typedef struct node_t {$/;"	s
node_t	or/or.h	/^} node_t;$/;"	t	typeref:struct:node_t
nodelist_add_microdesc	or/nodelist.c	/^nodelist_add_microdesc(microdesc_t *md)$/;"	f
nodelist_add_node_and_family	or/routerlist.c	/^nodelist_add_node_and_family(smartlist_t *sl, const node_t *node)$/;"	f
nodelist_add_routerinfo	or/nodelist.c	/^nodelist_add_routerinfo(routerinfo_t *ri)$/;"	f
nodelist_assert_ok	or/nodelist.c	/^nodelist_assert_ok(void)$/;"	f
nodelist_drop_node	or/nodelist.c	/^nodelist_drop_node(node_t *node, int remove_from_ht)$/;"	f	file:
nodelist_free_all	or/nodelist.c	/^nodelist_free_all(void)$/;"	f
nodelist_get_list	or/nodelist.c	/^nodelist_get_list(void)$/;"	f
nodelist_idx	or/or.h	/^  int nodelist_idx;$/;"	m	struct:node_t
nodelist_purge	or/nodelist.c	/^nodelist_purge(void)$/;"	f
nodelist_refresh_countries	or/routerlist.c	/^nodelist_refresh_countries(void) \/* MOVE *\/$/;"	f
nodelist_remove_microdesc	or/nodelist.c	/^nodelist_remove_microdesc(const char *identity_digest, microdesc_t *md)$/;"	f
nodelist_remove_routerinfo	or/nodelist.c	/^nodelist_remove_routerinfo(routerinfo_t *ri)$/;"	f
nodelist_set_consensus	or/nodelist.c	/^nodelist_set_consensus(networkstatus_t *ns)$/;"	f
nodelist_t	or/nodelist.c	/^typedef struct nodelist_t {$/;"	s	file:
nodelist_t	or/nodelist.c	/^} nodelist_t;$/;"	t	typeref:struct:nodelist_t	file:
nodes	or/nodelist.c	/^  smartlist_t *nodes;$/;"	m	struct:nodelist_t	file:
nodes_in_same_family	or/routerlist.c	/^nodes_in_same_family(const node_t *node1, const node_t *node2)$/;"	f
nonlive_timeouts	or/or.h	/^  int nonlive_timeouts;$/;"	m	struct:__anon53
normalize_data_directory	or/config.c	/^normalize_data_directory(or_options_t *options)$/;"	f	file:
note_broken_connection	or/connection_or.c	/^note_broken_connection(const char *state)$/;"	f	file:
note_client_request	or/directory.c	/^note_client_request(int purpose, int compressed, size_t bytes)$/;"	f	file:
note_crypto_pk_op	or/rephist.c	/^note_crypto_pk_op(pk_op_t operation)$/;"	f
note_request	or/directory.c	/^note_request(const char *key, size_t bytes)$/;"	f
notify_control_networkstatus_changed	or/networkstatus.c	/^notify_control_networkstatus_changed(const networkstatus_t *old_c,$/;"	f	file:
nquestions	or/eventdns.h	/^	int nquestions;$/;"	m	struct:evdns_server_request
ns	or/eventdns.c	/^	struct nameserver *ns;	\/* the server which we last sent it *\/$/;"	m	struct:evdns_request	typeref:struct:evdns_request::nameserver	file:
ns_detached_signatures_free	or/dirvote.c	/^ns_detached_signatures_free(ns_detached_signatures_t *s)$/;"	f
ns_detached_signatures_t	or/or.h	/^typedef struct ns_detached_signatures_t {$/;"	s
ns_detached_signatures_t	or/or.h	/^} ns_detached_signatures_t;$/;"	t	typeref:struct:ns_detached_signatures_t
ns_v2_responses	or/geoip.c	/^static uint32_t ns_v2_responses[GEOIP_NS_RESPONSE_NUM];$/;"	v	file:
ns_v3_responses	or/geoip.c	/^static uint32_t ns_v3_responses[GEOIP_NS_RESPONSE_NUM];$/;"	v	file:
nt_service_body	or/ntmain.c	/^nt_service_body(int argc, char **argv)$/;"	f	file:
nt_service_cmd_start	or/ntmain.c	/^nt_service_cmd_start(void)$/;"	f	file:
nt_service_cmd_stop	or/ntmain.c	/^nt_service_cmd_stop(void)$/;"	f	file:
nt_service_command_line	or/ntmain.c	/^nt_service_command_line(int *using_default_torrc)$/;"	f	file:
nt_service_control	or/ntmain.c	/^nt_service_control(DWORD request)$/;"	f	file:
nt_service_install	or/ntmain.c	/^nt_service_install(int argc, char **argv)$/;"	f	file:
nt_service_is_stopping	or/ntmain.c	/^nt_service_is_stopping(void)$/;"	f
nt_service_is_stopping	or/ntmain.h	/^#define nt_service_is_stopping(/;"	d
nt_service_loadlibrary	or/ntmain.c	/^nt_service_loadlibrary(void)$/;"	f	file:
nt_service_main	or/ntmain.c	/^nt_service_main(void)$/;"	f	file:
nt_service_open	or/ntmain.c	/^nt_service_open(SC_HANDLE hSCManager)$/;"	f	file:
nt_service_open_scm	or/ntmain.c	/^nt_service_open_scm(void)$/;"	f	file:
nt_service_parse_options	or/ntmain.c	/^nt_service_parse_options(int argc, char **argv, int *should_exit)$/;"	f
nt_service_remove	or/ntmain.c	/^nt_service_remove(void)$/;"	f	file:
nt_service_set_state	or/ntmain.c	/^nt_service_set_state(DWORD state)$/;"	f
nt_service_start	or/ntmain.c	/^nt_service_start(SC_HANDLE hService)$/;"	f	file:
nt_service_stop	or/ntmain.c	/^nt_service_stop(SC_HANDLE hService)$/;"	f	file:
num_circuits_launched	or/or.h	/^  unsigned int num_circuits_launched:4;$/;"	m	struct:entry_connection_t
num_cpus	common/compat_libevent.h	/^  int num_cpus;$/;"	m	struct:tor_libevent_cfg
num_cpuworkers	or/cpuworker.c	/^static int num_cpuworkers=0;$/;"	v	file:
num_cpuworkers_busy	or/cpuworker.c	/^static int num_cpuworkers_busy=0;$/;"	v	file:
num_domains	or/eventdns.c	/^	int num_domains;$/;"	m	struct:search_state	file:
num_live_entry_guards	or/circuitbuild.c	/^num_live_entry_guards(void)$/;"	f	file:
num_maxes_set	or/rephist.c	/^  int num_maxes_set;$/;"	m	struct:bw_array_t	file:
num_recent_circs	or/or.h	/^  int num_recent_circs;$/;"	m	struct:__anon53
num_rend_services	or/rendservice.c	/^num_rend_services(void)$/;"	f
num_resolve_failures	or/connection_edge.c	/^  short num_resolve_failures;$/;"	m	struct:__anon22	file:
num_socks_retries	or/or.h	/^  uint8_t num_socks_retries;$/;"	m	struct:entry_connection_t
num_used	common/container.h	/^  int num_used;$/;"	m	struct:smartlist_t
nym_epoch	or/or.h	/^  unsigned nym_epoch;$/;"	m	struct:entry_connection_t
nym_epoch	or/or.h	/^  unsigned nym_epoch;$/;"	m	struct:origin_circuit_t
obj_syntax	or/routerparse.c	/^} obj_syntax;$/;"	t	typeref:enum:__anon70	file:
object_body	or/routerparse.c	/^  char *object_body;           \/**< Contents of object, base64-decoded. *\/$/;"	m	struct:directory_token_t	file:
object_size	or/routerparse.c	/^  size_t object_size;          \/**< Bytes in object_body *\/$/;"	m	struct:directory_token_t	file:
object_type	or/routerparse.c	/^  char *object_type;           \/**< -----BEGIN [object_type]-----*\/$/;"	m	struct:directory_token_t	file:
obs	or/rephist.c	/^  uint64_t obs[NUM_SECS_ROLLING_MEASURE];$/;"	m	struct:bw_array_t	file:
off	or/or.h	/^  off_t off;$/;"	m	struct:microdesc_t
off64_t	common/torgzip.c	/^#define off64_t /;"	d	file:
ol_length	or/onion.c	/^static int ol_length=0;$/;"	v	file:
ol_list	or/onion.c	/^static onion_queue_t *ol_list=NULL;$/;"	v	file:
ol_tail	or/onion.c	/^static onion_queue_t *ol_tail=NULL;$/;"	v	file:
old	or/routerlist.c	/^  int old;$/;"	m	struct:duration_idx_t	file:
old_routers	or/or.h	/^  smartlist_t *old_routers;$/;"	m	struct:__anon44
on_circuit	or/or.h	/^  struct circuit_t *on_circuit; \/**< The circuit (if any) that this edge$/;"	m	struct:edge_connection_t	typeref:struct:edge_connection_t::circuit_t
one_tick	common/compat_libevent.c	/^static const struct timeval *one_tick = NULL;$/;"	v	typeref:struct:timeval	file:
onehop_tunnel	or/or.h	/^  unsigned int onehop_tunnel : 1;$/;"	m	struct:__anon47
onion_address	or/or.h	/^  char onion_address[REND_SERVICE_ADDRESS_LEN+1];$/;"	m	struct:rend_service_authorization_t
onion_address	or/or.h	/^  char onion_address[REND_SERVICE_ID_LEN_BASE32+1];$/;"	m	struct:rend_data_t
onion_append_hop	or/circuitbuild.c	/^onion_append_hop(crypt_path_t **head_ptr, extend_info_t *choice)$/;"	f	file:
onion_append_to_cpath	or/circuitbuild.c	/^onion_append_to_cpath(crypt_path_t **head_ptr, crypt_path_t *new_hop)$/;"	f
onion_extend_cpath	or/circuitbuild.c	/^onion_extend_cpath(origin_circuit_t *circ)$/;"	f	file:
onion_key	or/or.h	/^  crypto_pk_t *onion_key; \/**< Current onionskin key. *\/$/;"	m	struct:extend_info_t
onion_next_hop_in_cpath	or/circuitbuild.c	/^onion_next_hop_in_cpath(crypt_path_t *cpath)$/;"	f	file:
onion_next_task	or/onion.c	/^onion_next_task(char **onionskin_out)$/;"	f
onion_pending_add	or/onion.c	/^onion_pending_add(or_circuit_t *circ, char *onionskin)$/;"	f
onion_pending_remove	or/onion.c	/^onion_pending_remove(or_circuit_t *circ)$/;"	f
onion_pick_cpath_exit	or/circuitbuild.c	/^onion_pick_cpath_exit(origin_circuit_t *circ, extend_info_t *exit)$/;"	f	file:
onion_pkey	or/or.h	/^  crypto_pk_t *onion_pkey; \/**< Public RSA key for onions. *\/$/;"	m	struct:__anon41
onion_pkey	or/or.h	/^  crypto_pk_t *onion_pkey;$/;"	m	struct:microdesc_t
onion_populate_cpath	or/circuitbuild.c	/^onion_populate_cpath(origin_circuit_t *circ)$/;"	f	file:
onion_queue_t	or/onion.c	/^typedef struct onion_queue_t {$/;"	s	file:
onion_queue_t	or/onion.c	/^} onion_queue_t;$/;"	t	typeref:struct:onion_queue_t	file:
onion_skin_client_handshake	or/onion.c	/^onion_skin_client_handshake(crypto_dh_t *handshake_state,$/;"	f
onion_skin_create	or/onion.c	/^onion_skin_create(crypto_pk_t *dest_router_key,$/;"	f
onion_skin_server_handshake	or/onion.c	/^onion_skin_server_handshake(const char *onion_skin, \/*ONIONSKIN_CHALLENGE_LEN*\/$/;"	f
onionkey	or/router.c	/^static crypto_pk_t *onionkey=NULL;$/;"	v	file:
onionkey_set_at	or/router.c	/^static time_t onionkey_set_at=0; \/**< When was onionkey last changed? *\/$/;"	v	file:
onionskin	or/onion.c	/^  char *onionskin;$/;"	m	struct:onion_queue_t	file:
onionskin_answer	or/circuitbuild.c	/^onionskin_answer(or_circuit_t *circ, uint8_t cell_type, const char *payload,$/;"	f
open_file_t	common/util.c	/^struct open_file_t {$/;"	s	file:
open_file_t	common/util.h	/^typedef struct open_file_t open_file_t;$/;"	t	typeref:struct:open_file_t
open_sockets	common/compat.c	/^static bitarray_t *open_sockets = NULL;$/;"	v	file:
opt_forked	test/tinytest.c	/^static int opt_forked = 0; \/**< True iff we're called from inside a win32 fork*\/$/;"	v	file:
opt_nofork	test/tinytest.c	/^static int opt_nofork = 0; \/**< Suppress calls to fork() for debugging. *\/$/;"	v	file:
opt_streq	or/config.c	/^opt_streq(const char *s1, const char *s2)$/;"	f	file:
opt_verbosity	test/tinytest.c	/^static int opt_verbosity = 1; \/**< -==quiet,0==terse,1==normal,2==verbose *\/$/;"	v	file:
optimistic_data_enabled	or/circuituse.c	/^optimistic_data_enabled(void)$/;"	f	file:
option_clear	or/config.c	/^option_clear(const config_format_t *fmt, or_options_t *options,$/;"	f	file:
option_get_assignment	or/config.c	/^option_get_assignment(const or_options_t *options, const char *key)$/;"	f
option_get_canonical_name	or/config.c	/^option_get_canonical_name(const char *key)$/;"	f
option_is_recognized	or/config.c	/^option_is_recognized(const char *key)$/;"	f
option_is_same	or/config.c	/^option_is_same(const config_format_t *fmt,$/;"	f	file:
option_reset	or/config.c	/^option_reset(const config_format_t *fmt, or_options_t *options,$/;"	f	file:
options_act	or/config.c	/^options_act(const or_options_t *old_options)$/;"	f	file:
options_act_reversible	or/config.c	/^options_act_reversible(const or_options_t *old_options, char **msg)$/;"	f	file:
options_dump	or/config.c	/^options_dump(const or_options_t *options, int minimal)$/;"	f
options_dup	or/config.c	/^options_dup(const config_format_t *fmt, const or_options_t *old)$/;"	f	file:
options_format	or/config.c	/^static config_format_t options_format = {$/;"	v	file:
options_get_datadir_fname2_suffix	or/config.c	/^options_get_datadir_fname2_suffix(const or_options_t *options,$/;"	f
options_init	or/config.c	/^options_init(or_options_t *options)$/;"	f
options_init_from_string	or/config.c	/^options_init_from_string(const char *cf_defaults, const char *cf,$/;"	f
options_init_from_torrc	or/config.c	/^options_init_from_torrc(int argc, char **argv)$/;"	f
options_init_logs	or/config.c	/^options_init_logs(or_options_t *options, int validate_only)$/;"	f	file:
options_need_geoip_info	or/config.c	/^options_need_geoip_info(const or_options_t *options, const char **reason_out)$/;"	f
options_new	or/config.c	/^options_new(void)$/;"	f
options_save_current	or/config.c	/^options_save_current(void)$/;"	f
options_transition_affects_descriptor	or/config.c	/^options_transition_affects_descriptor(const or_options_t *old_options,$/;"	f	file:
options_transition_affects_workers	or/config.c	/^options_transition_affects_workers(const or_options_t *old_options,$/;"	f	file:
options_transition_allowed	or/config.c	/^options_transition_allowed(const or_options_t *old,$/;"	f	file:
options_transition_requires_fresh_tls_context	or/config.c	/^options_transition_requires_fresh_tls_context(const or_options_t *old_options,$/;"	f	file:
options_trial_assign	or/config.c	/^options_trial_assign(config_line_t *list, int use_defaults,$/;"	f
options_validate	or/config.c	/^options_validate(or_options_t *old_options, or_options_t *options,$/;"	f	file:
or_circuit_new	or/circuitlist.c	/^or_circuit_new(circid_t p_circ_id, or_connection_t *p_conn)$/;"	f
or_circuit_t	or/or.h	/^typedef struct or_circuit_t {$/;"	s
or_circuit_t	or/or.h	/^} or_circuit_t;$/;"	t	typeref:struct:or_circuit_t
or_conn	or/circuitlist.c	/^  or_connection_t *or_conn;$/;"	m	struct:orconn_circid_circuit_map_t	file:
or_conn_status_event_t	or/or.h	/^typedef enum or_conn_status_event_t {$/;"	g
or_conn_status_event_t	or/or.h	/^} or_conn_status_event_t;$/;"	t	typeref:enum:or_conn_status_event_t
or_connection_new	or/connection.c	/^or_connection_new(int socket_family)$/;"	f
or_connection_t	or/or.h	/^typedef struct or_connection_t {$/;"	s
or_connection_t	or/or.h	/^} or_connection_t;$/;"	t	typeref:struct:or_connection_t
or_handshake_state_free	or/connection_or.c	/^or_handshake_state_free(or_handshake_state_t *state)$/;"	f
or_handshake_state_record_cell	or/connection_or.c	/^or_handshake_state_record_cell(or_handshake_state_t *state,$/;"	f
or_handshake_state_record_var_cell	or/connection_or.c	/^or_handshake_state_record_var_cell(or_handshake_state_t *state,$/;"	f
or_handshake_state_t	or/or.h	/^typedef struct or_handshake_state_t {$/;"	s
or_handshake_state_t	or/or.h	/^} or_handshake_state_t;$/;"	t	typeref:struct:or_handshake_state_t
or_history_t	or/rephist.c	/^typedef struct or_history_t {$/;"	s	file:
or_history_t	or/rephist.c	/^} or_history_t;$/;"	t	typeref:struct:or_history_t	file:
or_options_free	or/config.c	/^or_options_free(or_options_t *options)$/;"	f	file:
or_options_t	or/or.h	/^} or_options_t;$/;"	t	typeref:struct:__anon49
or_port	or/or.h	/^  uint16_t or_port; \/**< OR port for this router. *\/$/;"	m	struct:routerstatus_t
or_port	or/or.h	/^  uint16_t or_port; \/**< OR port of this voter *\/$/;"	m	struct:networkstatus_voter_info_t
or_port	or/or.h	/^  uint16_t or_port; \/**< OR port: Used for tunneling connections. *\/$/;"	m	struct:trusted_dir_server_t
or_port	or/or.h	/^  uint16_t or_port; \/**< Port for TLS connections. *\/$/;"	m	struct:__anon41
or_protocol_versions	or/connection_or.c	/^static const uint16_t or_protocol_versions[] = { 1, 2, 3 };$/;"	v	file:
or_state_load	or/config.c	/^or_state_load(void)$/;"	f	file:
or_state_mark_dirty	or/or.h	/^static INLINE void or_state_mark_dirty(or_state_t *state, time_t when)$/;"	f
or_state_save	or/config.c	/^or_state_save(time_t now)$/;"	f
or_state_save_broken	or/config.c	/^or_state_save_broken(char *fname)$/;"	f	file:
or_state_set	or/config.c	/^or_state_set(or_state_t *new_state)$/;"	f	file:
or_state_t	or/or.h	/^} or_state_t;$/;"	t	typeref:struct:__anon52
or_state_validate	or/config.c	/^or_state_validate(or_state_t *old_state, or_state_t *state,$/;"	f	file:
orconn_circid_circuit_map_t	or/circuitlist.c	/^typedef struct orconn_circid_circuit_map_t {$/;"	s	file:
orconn_circid_circuit_map_t	or/circuitlist.c	/^} orconn_circid_circuit_map_t;$/;"	t	typeref:struct:orconn_circid_circuit_map_t	file:
orconn_end_reason_to_control_string	or/reasons.c	/^orconn_end_reason_to_control_string(int r)$/;"	f
orconn_identity_map	or/connection_or.c	/^static digestmap_t *orconn_identity_map = NULL;$/;"	v	file:
orconn_target_get_name	or/control.c	/^orconn_target_get_name(char *name, size_t len, or_connection_t *conn)$/;"	f	file:
orig_length	test/test_util.c	/^  int orig_length; \/\/ Length of orig_line$/;"	m	struct:split_lines_test_t	file:
orig_line	test/test_util.c	/^  const char *orig_line; \/\/ Line to be split (may contain \\0's)$/;"	m	struct:split_lines_test_t	file:
origin_circuit_init	or/circuitbuild.c	/^origin_circuit_init(uint8_t purpose, int flags)$/;"	f
origin_circuit_new	or/circuitlist.c	/^origin_circuit_new(void)$/;"	f
origin_circuit_t	or/or.h	/^typedef struct origin_circuit_t {$/;"	s
origin_circuit_t	or/or.h	/^} origin_circuit_t;$/;"	t	typeref:struct:origin_circuit_t
original_dest_address	or/or.h	/^  char *original_dest_address;$/;"	m	struct:entry_connection_t
os	or/routerparse.c	/^  obj_syntax os;$/;"	m	struct:token_rule_t	file:
outbuf	or/or.h	/^  buf_t *outbuf; \/**< Buffer holding data to write over this connection. *\/$/;"	m	struct:connection_t
outbuf_flushlen	or/or.h	/^  size_t outbuf_flushlen; \/**< How much data should we try to flush from the$/;"	m	struct:connection_t
outcome	test/tinytest.c	/^enum outcome { SKIP=2, OK=1, FAIL=0 };$/;"	g	file:
outgoing_addrs	or/connection.c	/^static smartlist_t *outgoing_addrs = NULL;$/;"	v	file:
output_so_far	common/torgzip.c	/^  size_t output_so_far;$/;"	m	struct:tor_zlib_state_t	file:
owning_controller_process_monitor	or/control.c	/^static tor_process_monitor_t *owning_controller_process_monitor = NULL;$/;"	v	file:
owning_controller_process_spec	or/control.c	/^static char *owning_controller_process_spec = NULL;$/;"	v	file:
owning_controller_procmon_cb	or/control.c	/^owning_controller_procmon_cb(void *unused)$/;"	f	file:
p	common/OpenBSD_malloc_Linux.c	/^	void		*p;$/;"	m	struct:ut	file:
p_cell_ewma	or/or.h	/^  cell_ewma_t p_cell_ewma;$/;"	m	struct:or_circuit_t
p_circ_id	or/or.h	/^  circid_t p_circ_id;$/;"	m	struct:or_circuit_t
p_conn	or/or.h	/^  or_connection_t *p_conn;$/;"	m	struct:or_circuit_t
p_conn_cells	or/or.h	/^  cell_queue_t p_conn_cells;$/;"	m	struct:or_circuit_t
p_crypto	or/or.h	/^  crypto_cipher_t *p_crypto;$/;"	m	struct:or_circuit_t
p_digest	or/or.h	/^  crypto_digest_t *p_digest;$/;"	m	struct:or_circuit_t
p_streams	or/or.h	/^  edge_connection_t *p_streams;$/;"	m	struct:origin_circuit_t
package_window	or/or.h	/^  int package_window; \/**< How many cells are we allowed to originate ending$/;"	m	struct:crypt_path_t
package_window	or/or.h	/^  int package_window; \/**< How many more relay cells can I send into the$/;"	m	struct:edge_connection_t
package_window	or/or.h	/^  int package_window;$/;"	m	struct:circuit_t
packed_cell_alloc	or/relay.c	/^packed_cell_alloc(void)$/;"	f	file:
packed_cell_copy	or/relay.c	/^packed_cell_copy(const cell_t *cell)$/;"	f	file:
packed_cell_free_unchecked	or/relay.c	/^packed_cell_free_unchecked(packed_cell_t *cell)$/;"	f	file:
packed_cell_t	or/or.h	/^typedef struct packed_cell_t {$/;"	s
packed_cell_t	or/or.h	/^} packed_cell_t;$/;"	t	typeref:struct:packed_cell_t
page	common/OpenBSD_malloc_Linux.c	/^	void		*page;	\/* Pointer to the page *\/$/;"	m	struct:pginfo	file:
page	common/OpenBSD_malloc_Linux.c	/^	void		*page;	\/* pointer to free pages *\/$/;"	m	struct:pgfree	file:
page_dir	common/OpenBSD_malloc_Linux.c	/^static struct pginfo **page_dir;$/;"	v	typeref:struct:pginfo	file:
pageround	common/OpenBSD_malloc_Linux.c	/^#define	pageround(/;"	d	file:
parse_addr_and_port_range	common/address.c	/^parse_addr_and_port_range(const char *s, uint32_t *addr_out,$/;"	f
parse_addr_policy	or/policies.c	/^parse_addr_policy(config_line_t *cfg, smartlist_t **dest,$/;"	f	file:
parse_bridge_line	or/config.c	/^parse_bridge_line(const char *line, int validate_only)$/;"	f	file:
parse_client_method_error	or/transports.c	/^#define parse_client_method_error(/;"	d	file:
parse_client_transport_line	or/config.c	/^parse_client_transport_line(const char *line, int validate_only)$/;"	f	file:
parse_cmethod_line	or/transports.c	/^parse_cmethod_line(const char *line, managed_proxy_t *mp)$/;"	f
parse_commandline	tools/tor-gencert.c	/^parse_commandline(int argc, char **argv)$/;"	f	file:
parse_config_line_from_str	common/util.c	/^parse_config_line_from_str(const char *line, char **key_out, char **value_out)$/;"	f
parse_dir_server_line	or/config.c	/^parse_dir_server_line(const char *line, dirinfo_type_t required_type,$/;"	f	file:
parse_env_error	or/transports.c	/^parse_env_error(const char *line)$/;"	f
parse_extended_hostname	or/connection_edge.c	/^parse_extended_hostname(char *address, int allowdotexit)$/;"	f
parse_http_response	or/directory.c	/^parse_http_response(const char *headers, int *code, time_t *date,$/;"	f
parse_http_time	common/util.c	/^parse_http_time(const char *date, struct tm *tm)$/;"	f
parse_http_url	or/directory.c	/^parse_http_url(const char *headers, char **url)$/;"	f	file:
parse_iso_time	common/util.c	/^parse_iso_time(const char *cp, time_t *t)$/;"	f
parse_log_domain	common/log.c	/^parse_log_domain(const char *domain)$/;"	f	file:
parse_log_level	common/log.c	/^parse_log_level(const char *level)$/;"	f
parse_log_severity_config	common/log.c	/^parse_log_severity_config(const char **cfg_ptr,$/;"	f
parse_method_error	or/transports.c	/^parse_method_error(const char *line, int is_server)$/;"	f	file:
parse_port_config	or/config.c	/^parse_port_config(smartlist_t *out,$/;"	f	file:
parse_port_config	or/rendservice.c	/^parse_port_config(const char *string)$/;"	f	file:
parse_port_range	common/address.c	/^parse_port_range(const char *port, uint16_t *port_min_out,$/;"	f
parse_ports	or/config.c	/^parse_ports(const or_options_t *options, int validate_only,$/;"	f	file:
parse_possibly_bad_iso_time	or/rephist.c	/^parse_possibly_bad_iso_time(const char *s, time_t *time_out)$/;"	f	file:
parse_process_specifier	common/procmon.c	/^parse_process_specifier(const char *process_spec,$/;"	f	file:
parse_reachable_addresses	or/policies.c	/^parse_reachable_addresses(void)$/;"	f	file:
parse_rfc1123_time	common/util.c	/^parse_rfc1123_time(const char *buf, time_t *t)$/;"	f
parse_server_method_error	or/transports.c	/^#define parse_server_method_error(/;"	d	file:
parse_server_transport_line	or/config.c	/^parse_server_transport_line(const char *line, int validate_only)$/;"	f	file:
parse_short_policy	or/policies.c	/^parse_short_policy(const char *summary)$/;"	f
parse_smethod_line	or/transports.c	/^parse_smethod_line(const char *line, managed_proxy_t *mp)$/;"	f
parse_socket_config	or/config.c	/^parse_socket_config(smartlist_t *out, const config_line_t *cfg,$/;"	f	file:
parse_socks	or/buffers.c	/^parse_socks(const char *data, size_t datalen, socks_request_t *req,$/;"	f	file:
parse_socks4a_resolve_response	tools/tor-resolve.c	/^parse_socks4a_resolve_response(const char *hostname,$/;"	f	file:
parse_socks_client	or/buffers.c	/^parse_socks_client(const uint8_t *data, size_t datalen,$/;"	f	file:
parse_version	or/transports.c	/^parse_version(const char *line, managed_proxy_t *mp)$/;"	f
parse_virtual_addr_network	or/connection_edge.c	/^parse_virtual_addr_network(const char *val, int validate_only,$/;"	f
parsed	or/or.h	/^  rend_service_descriptor_t *parsed; \/**< Parsed value of 'desc' *\/$/;"	m	struct:rend_cache_entry_t
parsed_process_specifier_t	common/procmon.c	/^struct parsed_process_specifier_t {$/;"	s	file:
pass_data	test/test_crypto.c	/^static const struct testcase_setup_t pass_data = {$/;"	v	typeref:struct:testcase_setup_t	file:
pass_data_cleanup_fn	test/test_crypto.c	/^pass_data_cleanup_fn(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
pass_data_setup_fn	test/test_crypto.c	/^pass_data_setup_fn(const struct testcase_t *testcase)$/;"	f	file:
passphrase	tools/tor-gencert.c	/^char *passphrase = NULL;$/;"	v
passphrase_fd	tools/tor-gencert.c	/^int passphrase_fd = -1;$/;"	v
passphrase_len	tools/tor-gencert.c	/^size_t passphrase_len = 0;$/;"	v
password	or/or.h	/^  char *password;$/;"	m	struct:socks_request_t
passwordlen	or/or.h	/^  uint8_t passwordlen;$/;"	m	struct:socks_request_t
patchlevel	or/or.h	/^  int patchlevel;$/;"	m	struct:tor_version_t
path_is_relative	common/util.c	/^path_is_relative(const char *filename)$/;"	f
payload	or/or.h	/^  uint8_t payload[CELL_PAYLOAD_SIZE]; \/**< Cell body. *\/$/;"	m	struct:cell_t
payload	or/or.h	/^  uint8_t payload[FLEXIBLE_ARRAY_MEMBER];$/;"	m	struct:var_cell_t
payload_len	or/or.h	/^  uint16_t payload_len;$/;"	m	struct:var_cell_t
pdi_mod	common/OpenBSD_malloc_Linux.c	/^static u_long	pdi_mod;$/;"	v	file:
pdi_off	common/OpenBSD_malloc_Linux.c	/^static size_t	pdi_off;$/;"	v	file:
pdinfo	common/OpenBSD_malloc_Linux.c	/^struct pdinfo {$/;"	s	file:
pdir	common/OpenBSD_malloc_Linux.c	/^	void		*pdir;	\/* pointer to the base page's dir *\/$/;"	m	struct:pgfree	file:
pdir_lookup	common/OpenBSD_malloc_Linux.c	/^pdir_lookup(u_long index, struct pdinfo ** pdi)$/;"	f	file:
peek_buf_has_control0_command	or/buffers.c	/^peek_buf_has_control0_command(buf_t *buf)$/;"	f
peek_connection_has_control0_command	or/control.c	/^peek_connection_has_control0_command(connection_t *conn)$/;"	f	file:
peek_evbuffer_has_control0_command	or/buffers.c	/^peek_evbuffer_has_control0_command(struct evbuffer *buf)$/;"	f
peek_from_buf	or/buffers.c	/^peek_from_buf(char *string, size_t string_len, const buf_t *buf)$/;"	f	file:
pending_cb_message_t	common/log.c	/^typedef struct pending_cb_message_t {$/;"	s	file:
pending_cb_message_t	common/log.c	/^} pending_cb_message_t;$/;"	t	typeref:struct:pending_cb_message_t	file:
pending_cb_messages	common/log.c	/^static smartlist_t *pending_cb_messages = NULL;$/;"	v	file:
pending_connection_t	or/dns.c	/^typedef struct pending_connection_t {$/;"	s	file:
pending_connection_t	or/dns.c	/^} pending_connection_t;$/;"	t	typeref:struct:pending_connection_t	file:
pending_connections	or/dns.c	/^  pending_connection_t *pending_connections;$/;"	m	struct:cached_resolve_t	file:
pending_consensus_signature_list	or/dirvote.c	/^static smartlist_t *pending_consensus_signature_list = NULL;$/;"	v	file:
pending_consensus_signatures	or/dirvote.c	/^static char *pending_consensus_signatures = NULL;$/;"	v	file:
pending_consensus_t	or/dirvote.c	/^typedef struct pending_consensus_t {$/;"	s	file:
pending_consensus_t	or/dirvote.c	/^} pending_consensus_t;$/;"	t	typeref:struct:pending_consensus_t	file:
pending_consensuses	or/dirvote.c	/^static pending_consensus_t pending_consensuses[N_CONSENSUS_FLAVORS];$/;"	v	file:
pending_final_cpath	or/or.h	/^  crypt_path_t *pending_final_cpath;$/;"	m	struct:__anon47
pending_optimistic_data	or/or.h	/^  generic_buffer_t *pending_optimistic_data;$/;"	m	struct:entry_connection_t
pending_replies	or/eventdns.c	/^	struct server_request *pending_replies;$/;"	m	struct:evdns_server_port	typeref:struct:evdns_server_port::server_request	file:
pending_sig	or/or.h	/^  char *pending_sig;$/;"	m	struct:extrainfo_t
pending_sig_len	or/or.h	/^  size_t pending_sig_len;$/;"	m	struct:extrainfo_t
pending_vote_list	or/dirvote.c	/^static smartlist_t *pending_vote_list = NULL;$/;"	v	file:
pending_vote_t	or/dirvote.c	/^typedef struct pending_vote_t {$/;"	s	file:
pending_vote_t	or/dirvote.c	/^} pending_vote_t;$/;"	t	typeref:struct:pending_vote_t	file:
perftime	test/bench.c	/^perftime(void)$/;"	f	file:
periodic_timer_cb	common/compat_libevent.c	/^periodic_timer_cb(evutil_socket_t fd, short what, void *arg)$/;"	f	file:
periodic_timer_free	common/compat_libevent.c	/^periodic_timer_free(periodic_timer_t *timer)$/;"	f
periodic_timer_new	common/compat_libevent.c	/^periodic_timer_new(struct event_base *base,$/;"	f
periodic_timer_t	common/compat_libevent.c	/^struct periodic_timer_t {$/;"	s	file:
periodic_timer_t	common/compat_libevent.h	/^typedef struct periodic_timer_t periodic_timer_t;$/;"	t	typeref:struct:periodic_timer_t
pf_socket	or/connection_edge.c	/^static int pf_socket = -1;$/;"	v	file:
pgfree	common/OpenBSD_malloc_Linux.c	/^struct pgfree {$/;"	s	file:
pginfo	common/OpenBSD_malloc_Linux.c	/^struct pginfo {$/;"	s	file:
pick_entry_guards	or/circuitbuild.c	/^pick_entry_guards(const or_options_t *options)$/;"	f	file:
pid	common/procmon.c	/^  pid_t pid;$/;"	m	struct:parsed_process_specifier_t	file:
pid	common/procmon.c	/^  pid_t pid;$/;"	m	struct:tor_process_monitor_t	file:
pid	common/util.h	/^  PROCESS_INFORMATION pid;$/;"	m	struct:process_handle_t
pid	common/util.h	/^  pid_t pid;$/;"	m	struct:process_handle_t
pid	or/transports.h	/^  int pid; \/* The Process ID this managed proxy is using. *\/$/;"	m	struct:__anon71
pid_t	common/procmon.c	/^typedef int pid_t;$/;"	t	file:
pk	or/or.h	/^  crypto_pk_t *pk; \/**< This service's public key. *\/$/;"	m	struct:rend_service_descriptor_t
pk_digest	or/rendservice.c	/^  char pk_digest[DIGEST_LEN]; \/**< Hash of permanent hidden-service key. *\/$/;"	m	struct:rend_service_t	file:
pk_generate	test/test.c	/^pk_generate(int idx)$/;"	f
pk_op_counts	or/rephist.c	/^} pk_op_counts = {0,0,0,0,0,0,0,0,0,0,0};$/;"	v	typeref:struct:__anon68	file:
pk_op_t	or/or.h	/^} pk_op_t;$/;"	t	typeref:enum:__anon65
pkey_digests	common/tortls.c	/^  digests_t pkey_digests;$/;"	m	struct:tor_cert_t	file:
pkey_digests_set	common/tortls.c	/^  unsigned pkey_digests_set : 1;$/;"	m	struct:tor_cert_t	file:
pkey_eq	common/tortls.c	/^pkey_eq(EVP_PKEY *a, EVP_PKEY *b)$/;"	f	file:
platform	or/or.h	/^  char *platform; \/**< What software\/operating system is this OR using? *\/$/;"	m	struct:__anon41
policies	or/routerlist.c	/^  smartlist_t *policies;$/;"	m	struct:routerset_t	file:
policies_exit_policy_append_reject_star	or/policies.c	/^policies_exit_policy_append_reject_star(smartlist_t **dest)$/;"	f
policies_free_all	or/policies.c	/^policies_free_all(void)$/;"	f
policies_parse_exit_policy	or/policies.c	/^policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,$/;"	f
policies_parse_from_options	or/policies.c	/^policies_parse_from_options(const or_options_t *options)$/;"	f
policies_set_node_exitpolicy_to_reject_all	or/policies.c	/^policies_set_node_exitpolicy_to_reject_all(node_t *node)$/;"	f
policy	or/policies.c	/^  addr_policy_t *policy;$/;"	m	struct:policy_map_ent_t	file:
policy_eq	or/policies.c	/^policy_eq(policy_map_ent_t *a, policy_map_ent_t *b)$/;"	f	file:
policy_expand_private	or/policies.c	/^policy_expand_private(smartlist_t **policy)$/;"	f
policy_hash	or/policies.c	/^policy_hash(policy_map_ent_t *ent)$/;"	f	file:
policy_is_reject_star	or/or.h	/^  unsigned int policy_is_reject_star:1; \/**< True iff the exit policy for this$/;"	m	struct:__anon41
policy_is_reject_star	or/policies.c	/^policy_is_reject_star(const smartlist_t *policy)$/;"	f
policy_map_ent_t	or/policies.c	/^typedef struct policy_map_ent_t {$/;"	s	file:
policy_map_ent_t	or/policies.c	/^} policy_map_ent_t;$/;"	t	typeref:struct:policy_map_ent_t	file:
policy_summarize	or/policies.c	/^policy_summarize(smartlist_t *policy)$/;"	f
policy_summary_accept	or/policies.c	/^policy_summary_accept(smartlist_t *summary,$/;"	f	file:
policy_summary_add_item	or/policies.c	/^policy_summary_add_item(smartlist_t *summary, addr_policy_t *p)$/;"	f	file:
policy_summary_create	or/policies.c	/^policy_summary_create(void)$/;"	f	file:
policy_summary_item_split	or/policies.c	/^policy_summary_item_split(policy_summary_item_t* old, uint16_t new_starts)$/;"	f	file:
policy_summary_item_t	or/policies.c	/^typedef struct policy_summary_item_t {$/;"	s	file:
policy_summary_item_t	or/policies.c	/^} policy_summary_item_t;$/;"	t	typeref:struct:policy_summary_item_t	file:
policy_summary_reject	or/policies.c	/^policy_summary_reject(smartlist_t *summary,$/;"	f	file:
policy_summary_split	or/policies.c	/^policy_summary_split(smartlist_t *summary,$/;"	f	file:
policy_type	or/or.h	/^  addr_policy_action_t policy_type:2;\/**< What to do when the policy matches.*\/$/;"	m	struct:addr_policy_t
policy_write_item	or/policies.c	/^policy_write_item(char *buf, size_t buflen, addr_policy_t *policy,$/;"	f
poll_hproc	common/procmon.c	/^  int poll_hproc;$/;"	m	struct:tor_process_monitor_t	file:
poll_interval_tv	common/procmon.c	/^static struct timeval poll_interval_tv = {15, 0};$/;"	v	typeref:struct:timeval	file:
pool	common/mempool.c	/^  mp_pool_t *pool; \/**< The pool that this chunk is part of. *\/$/;"	m	struct:mp_chunk_t	file:
pop_first_cell_ewma_from_conn	or/relay.c	/^pop_first_cell_ewma_from_conn(or_connection_t *conn)$/;"	f	file:
port	common/address.h	/^  uint16_t port;$/;"	m	struct:tor_addr_port_t
port	or/circuitbuild.c	/^  uint16_t port;$/;"	m	struct:__anon19	file:
port	or/circuitbuild.h	/^  uint16_t port;$/;"	m	struct:__anon20
port	or/eventdns.c	/^	struct evdns_server_port *port; \/* Which port received this request on? *\/$/;"	m	struct:server_request	typeref:struct:server_request::evdns_server_port	file:
port	or/or.h	/^  int port; \/**< The configured port, or CFG_AUTO_PORT to tell Tor to pick its$/;"	m	struct:port_cfg_t
port	or/or.h	/^  uint16_t port; \/**< If non-zero, port on the other end$/;"	m	struct:connection_t
port	or/or.h	/^  uint16_t port; \/**< OR port. *\/$/;"	m	struct:extend_info_t
port	or/or.h	/^  uint16_t port; \/**< What port did the client ask to connect to? *\/$/;"	m	struct:socks_request_t
port	or/rephist.c	/^  uint16_t port;$/;"	m	struct:predicted_port_t	file:
port_cfg_free	or/config.c	/^port_cfg_free(port_cfg_t *port)$/;"	f	file:
port_cfg_t	or/or.h	/^typedef struct port_cfg_t {$/;"	s
port_cfg_t	or/or.h	/^} port_cfg_t;$/;"	t	typeref:struct:port_cfg_t
ports	or/rendservice.c	/^  smartlist_t *ports; \/**< List of rend_service_port_config_t *\/$/;"	m	struct:rend_service_t	file:
pos	common/aes.c	/^  unsigned int pos;$/;"	m	struct:aes_cnt_cipher	file:
pos	or/buffers.c	/^  int pos;\/**< Which character inside the chunk's data are we pointing to? *\/$/;"	m	struct:buf_pos_t	file:
pos	or/eventdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:
pos	or/routerparse.c	/^  int pos;$/;"	m	struct:token_rule_t	file:
posix_memalign	common/OpenBSD_malloc_Linux.c	/^int posix_memalign(void **memptr, size_t alignment, size_t size)$/;"	f
pq_entry_t	test/test_containers.c	/^typedef struct pq_entry_t {$/;"	s	file:
pq_entry_t	test/test_containers.c	/^} pq_entry_t;$/;"	t	typeref:struct:pq_entry_t	file:
predicted_internal_capacity_time	or/rephist.c	/^static time_t predicted_internal_capacity_time = 0;$/;"	v	file:
predicted_internal_time	or/rephist.c	/^static time_t predicted_internal_time = 0;$/;"	v	file:
predicted_internal_uptime_time	or/rephist.c	/^static time_t predicted_internal_uptime_time = 0;$/;"	v	file:
predicted_port_t	or/rephist.c	/^typedef struct predicted_port_t {$/;"	s	file:
predicted_port_t	or/rephist.c	/^} predicted_port_t;$/;"	t	typeref:struct:predicted_port_t	file:
predicted_ports_free	or/rephist.c	/^predicted_ports_free(void)$/;"	f	file:
predicted_ports_init	or/rephist.c	/^predicted_ports_init(void)$/;"	f	file:
predicted_ports_list	or/rephist.c	/^static smartlist_t *predicted_ports_list=NULL;$/;"	v	file:
preferred_chunk_size	or/buffers.c	/^preferred_chunk_size(size_t target)$/;"	f	file:
prefix	test/tinytest.h	/^	const char *prefix; \/**< Prefix to prepend to testnames. *\/$/;"	m	struct:testgroup_t
pregen_keys	test/test.c	/^static crypto_pk_t *pregen_keys[5] = {NULL, NULL, NULL, NULL, NULL};$/;"	v	file:
prev	common/OpenBSD_malloc_Linux.c	/^	struct pdinfo	*prev;$/;"	m	struct:pdinfo	typeref:struct:pdinfo::pdinfo	file:
prev	common/OpenBSD_malloc_Linux.c	/^	struct pgfree	*prev;	\/* prev run of free pages *\/$/;"	m	struct:pgfree	typeref:struct:pgfree::pgfree	file:
prev	common/mempool.c	/^  mp_chunk_t *prev; \/**< The previous free, used, or full chunk in sequence. *\/$/;"	m	struct:mp_chunk_t	file:
prev	or/eventdns.c	/^	struct evdns_request *next, *prev;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::	file:
prev	or/eventdns.c	/^	struct nameserver *next, *prev;$/;"	m	struct:nameserver	typeref:struct:nameserver::	file:
prev	or/or.h	/^  struct crypt_path_t *prev; \/**< Link to previous crypt_path_t in the$/;"	m	struct:crypt_path_t	typeref:struct:crypt_path_t::crypt_path_t
prev_active_on_n_conn	or/or.h	/^  struct circuit_t *prev_active_on_n_conn;$/;"	m	struct:circuit_t	typeref:struct:circuit_t::circuit_t
prev_active_on_p_conn	or/or.h	/^  struct circuit_t *prev_active_on_p_conn;$/;"	m	struct:or_circuit_t	typeref:struct:or_circuit_t::circuit_t
prev_circ_on_conn_p	or/relay.c	/^prev_circ_on_conn_p(circuit_t *circ, or_connection_t *conn)$/;"	f	file:
prev_dir	common/OpenBSD_malloc_Linux.c	/^static struct pdinfo *prev_dir;	\/* referenced directory pages. *\/$/;"	v	typeref:struct:pdinfo	file:
prev_pending	or/eventdns.c	/^	struct server_request *prev_pending;$/;"	m	struct:server_request	typeref:struct:server_request::server_request	file:
previous_vote_list	or/dirvote.c	/^static smartlist_t *previous_vote_list = NULL;$/;"	v	file:
print_usage	or/config.c	/^print_usage(void)$/;"	f	file:
private_dir_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t private_dir_port;$/;"	m	struct:__anon72
private_key	or/rendservice.c	/^  crypto_pk_t *private_key; \/**< Permanent hidden-service key. *\/$/;"	m	struct:rend_service_t	file:
private_nets	or/policies.c	/^static const char *private_nets[] = {$/;"	v	file:
private_or_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t private_or_port;$/;"	m	struct:__anon72
process_environment_free	common/util.c	/^process_environment_free(process_environment_t *env)$/;"	f
process_environment_make	common/util.c	/^process_environment_make(struct smartlist_t *env_vars)$/;"	f
process_environment_t	common/util.h	/^struct process_environment_t {$/;"	s
process_environment_t	common/util.h	/^typedef struct process_environment_t process_environment_t;$/;"	t	typeref:struct:process_environment_t
process_handle	or/transports.h	/^  process_handle_t *process_handle;$/;"	m	struct:__anon71
process_handle_new	common/util.c	/^process_handle_new(void)$/;"	f	file:
process_handle_t	common/util.h	/^struct process_handle_t {$/;"	s
process_handle_t	common/util.h	/^typedef struct process_handle_t process_handle_t;$/;"	t	typeref:struct:process_handle_t
process_pending_task	or/cpuworker.c	/^process_pending_task(connection_t *cpuworker)$/;"	f	file:
process_signal	or/main.c	/^process_signal(uintptr_t sig)$/;"	f
processed_cells	or/or.h	/^  uint32_t processed_cells;$/;"	m	struct:or_circuit_t
processed_cells	or/rephist.c	/^  uint32_t processed_cells;$/;"	m	struct:circ_buffer_stats_t	file:
protocol	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  int protocol; \/**< This will only be TCP. *\/$/;"	m	struct:natpmp_state_t
protocols	or/or.h	/^  uint16_t protocols; \/**< Bitmask: which rendezvous protocols are supported?$/;"	m	struct:rend_service_descriptor_t
proxy_configuration_finished	or/transports.c	/^proxy_configuration_finished(const managed_proxy_t *mp)$/;"	f	file:
proxy_mode	or/router.c	/^proxy_mode(const or_options_t *options)$/;"	f
proxy_needs_restart	or/transports.c	/^proxy_needs_restart(const managed_proxy_t *mp)$/;"	f	file:
proxy_prepare_for_restart	or/transports.c	/^proxy_prepare_for_restart(managed_proxy_t *mp)$/;"	f	file:
proxy_state	or/or.h	/^  unsigned int proxy_state:4;$/;"	m	struct:connection_t
proxy_type	or/or.h	/^  unsigned int proxy_type:2; \/**< One of PROXY_NONE...PROXY_SOCKS5 *\/$/;"	m	struct:or_connection_t
proxy_type_to_string	or/connection.c	/^proxy_type_to_string(int proxy_type)$/;"	f	file:
prt_max	or/or.h	/^  uint16_t prt_max; \/**< Highest port number to accept\/reject. *\/$/;"	m	struct:addr_policy_t
prt_max	or/policies.c	/^    uint16_t prt_max; \/**< Highest port number to accept\/reject. *\/$/;"	m	struct:policy_summary_item_t	file:
prt_min	or/or.h	/^  uint16_t prt_min; \/**< Lowest port number to accept\/reject. *\/$/;"	m	struct:addr_policy_t
prt_min	or/policies.c	/^    uint16_t prt_min; \/**< Lowest port number to accept\/reject. *\/$/;"	m	struct:policy_summary_item_t	file:
pt_configure_remaining_proxies	or/transports.c	/^pt_configure_remaining_proxies(void)$/;"	f
pt_free_all	or/transports.c	/^pt_free_all(void)$/;"	f
pt_kickstart_client_proxy	or/transports.h	/^#define pt_kickstart_client_proxy(/;"	d
pt_kickstart_proxy	or/transports.c	/^pt_kickstart_proxy(const smartlist_t *transport_list,$/;"	f
pt_kickstart_server_proxy	or/transports.h	/^#define pt_kickstart_server_proxy(/;"	d
pt_prepare_proxy_list_for_config_read	or/transports.c	/^pt_prepare_proxy_list_for_config_read(void)$/;"	f
pt_proto_state	or/transports.h	/^enum pt_proto_state {$/;"	g
pt_proxies_configuration_pending	or/transports.c	/^pt_proxies_configuration_pending(void)$/;"	f
pt_tests	test/test_pt.c	/^struct testcase_t pt_tests[] = {$/;"	v	typeref:struct:testcase_t
ptr	or/eventdns.c	/^		} ptr;$/;"	m	union:reply::__anon28	typeref:struct:reply::__anon28::__anon31	file:
ptr2index	common/OpenBSD_malloc_Linux.c	/^#define	ptr2index(/;"	d	file:
public_dir_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t public_dir_port;$/;"	m	struct:__anon72
public_ip_status	tools/tor-fw-helper/tor-fw-helper.h	/^  int public_ip_status;$/;"	m	struct:__anon72
public_or_port	tools/tor-fw-helper/tor-fw-helper.h	/^  uint16_t public_or_port;$/;"	m	struct:__anon72
public_server_mode	or/router.c	/^public_server_mode(const or_options_t *options)$/;"	f
published	or/or.h	/^  time_t published; \/**< Vote only: Time when vote was written. *\/$/;"	m	struct:networkstatus_t
published	or/or.h	/^  time_t published; \/**< When was this object published. *\/$/;"	m	struct:cached_dir_t
published_on	or/or.h	/^  time_t published_on; \/**< Declared publication date. *\/$/;"	m	struct:networkstatus_v2_t
published_on	or/or.h	/^  time_t published_on; \/**< When was this router published? *\/$/;"	m	struct:routerstatus_t
published_on	or/or.h	/^  time_t published_on;$/;"	m	struct:signed_descriptor_t
purge_expired_resolves	or/dns.c	/^purge_expired_resolves(time_t now)$/;"	f	file:
purge_hid_serv_from_last_hid_serv_requests	or/rendclient.c	/^purge_hid_serv_from_last_hid_serv_requests(const char *onion_address)$/;"	f	file:
purpose	or/or.h	/^  uint8_t purpose; \/**< Why are we creating this circuit? *\/$/;"	m	struct:circuit_t
purpose	or/or.h	/^  uint8_t purpose;$/;"	m	struct:__anon41
purpose	or/or.h	/^  unsigned int purpose:5; \/**< Only used for DIR and EXIT types currently. *\/$/;"	m	struct:connection_t
purpose_needs_anonymity	or/directory.c	/^purpose_needs_anonymity(uint8_t dir_purpose, uint8_t router_purpose)$/;"	f	file:
px	common/OpenBSD_malloc_Linux.c	/^static struct pgfree *px;$/;"	v	typeref:struct:pgfree	file:
questions	or/eventdns.h	/^	struct evdns_server_question **questions;$/;"	m	struct:evdns_server_request	typeref:struct:evdns_server_request::evdns_server_question
quiet_level	or/main.c	/^int quiet_level = 0;$/;"	v
r	common/OpenBSD_malloc_Linux.c	/^	void		*r;$/;"	m	struct:ut	file:
rand_bytes_function	or/eventdns.c	/^static void (*rand_bytes_function)(char *buf, size_t n) =$/;"	v	file:
rate	common/util.h	/^  int rate;$/;"	m	struct:ratelim_t
rate_limit_is_ready	common/util.c	/^rate_limit_is_ready(ratelim_t *lim, time_t now)$/;"	f	file:
rate_limit_log	common/util.c	/^rate_limit_log(ratelim_t *lim, time_t now)$/;"	f
ratelim_t	common/util.h	/^typedef struct ratelim_t {$/;"	s
ratelim_t	common/util.h	/^} ratelim_t;$/;"	t	typeref:struct:ratelim_t
rcsid	common/strlcat.c	/^static char *rcsid = "$OpenBSD: strlcat.c,v 1.8 2001\/05\/13 15:40:15 deraadt Exp $";$/;"	v	file:
rcsid	common/strlcpy.c	/^static char *rcsid = "$OpenBSD: strlcpy.c,v 1.2 1998\/11\/06 04:33:16 wvdputte Exp $";$/;"	v	file:
reachable_dir_addr_policy	or/policies.c	/^static smartlist_t *reachable_dir_addr_policy = NULL;$/;"	v	file:
reachable_or_addr_policy	or/policies.c	/^static smartlist_t *reachable_or_addr_policy = NULL;$/;"	v	file:
read	or/rephist.c	/^  size_t read; \/**< Number of read bytes *\/$/;"	m	struct:bidi_map_entry_t	file:
read_all	common/util.c	/^read_all(tor_socket_t fd, char *buf, size_t count, int isSocket)$/;"	f
read_array	or/rephist.c	/^static bw_array_t *read_array = NULL;$/;"	v	file:
read_bandwidth_usage	or/hibernate.c	/^read_bandwidth_usage(void)$/;"	f	file:
read_blocked_on_bw	or/or.h	/^  unsigned int read_blocked_on_bw:1; \/**< Boolean: should we start reading$/;"	m	struct:connection_t
read_bucket	or/or.h	/^  int read_bucket; \/**< When this hits 0, stop receiving. Every second we$/;"	m	struct:or_connection_t
read_escaped_data	or/control.c	/^read_escaped_data(const char *data, size_t len, char **out)$/;"	f
read_event	or/or.h	/^  struct event *read_event; \/**< Libevent event structure. *\/$/;"	m	struct:connection_t	typeref:struct:connection_t::event
read_file_to_str	common/util.c	/^read_file_to_str(const char *filename, int flags, struct stat *stat_out)$/;"	f
read_to_buf	or/buffers.c	/^read_to_buf(tor_socket_t s, size_t at_most, buf_t *buf, int *reached_eof,$/;"	f
read_to_buf_tls	or/buffers.c	/^read_to_buf_tls(tor_tls_t *tls, size_t at_most, buf_t *buf)$/;"	f
read_to_chunk	or/buffers.c	/^read_to_chunk(buf_t *buf, chunk_t *chunk, tor_socket_t fd, size_t at_most,$/;"	f	file:
read_to_chunk_tls	or/buffers.c	/^read_to_chunk_tls(buf_t *buf, chunk_t *chunk, tor_tls_t *tls,$/;"	f	file:
reading_from_linked_conn	or/or.h	/^  unsigned int reading_from_linked_conn:1;$/;"	m	struct:connection_t
real_addr	or/or.h	/^  tor_addr_t real_addr; \/**< The actual address that this connection came from$/;"	m	struct:or_connection_t
real_addr	or/rendservice.c	/^  tor_addr_t real_addr;$/;"	m	struct:rend_service_port_config_t	file:
real_port	or/rendservice.c	/^  uint16_t real_port;$/;"	m	struct:rend_service_port_config_t	file:
real_uptime	or/dirserv.c	/^real_uptime(const routerinfo_t *router, time_t now)$/;"	f	file:
realign_pointer	common/memarea.c	/^realign_pointer(void *ptr)$/;"	f	file:
realloc	common/OpenBSD_malloc_Linux.c	/^realloc(void *ptr, size_t size)$/;"	f
received	or/or.h	/^  time_t received; \/**< When was the descriptor received? *\/$/;"	m	struct:rend_cache_entry_t
received_auth_challenge	or/or.h	/^  unsigned int received_auth_challenge : 1;$/;"	m	struct:or_handshake_state_t
received_authenticate	or/or.h	/^  unsigned int received_authenticate : 1;$/;"	m	struct:or_handshake_state_t
received_certs_cell	or/or.h	/^  unsigned int received_certs_cell : 1;$/;"	m	struct:or_handshake_state_t
received_on	or/or.h	/^  time_t received_on;$/;"	m	struct:networkstatus_v2_t
received_versions	or/or.h	/^  unsigned int received_versions : 1;$/;"	m	struct:or_handshake_state_t
recognized	or/or.h	/^  uint16_t recognized; \/**< Used to tell whether cell is for us. *\/$/;"	m	struct:__anon36
recommends_versions	or/or.h	/^  unsigned int recommends_versions:1; \/**< True iff this directory server$/;"	m	struct:networkstatus_v2_t
record_num_bytes_transferred	or/connection.c	/^record_num_bytes_transferred(connection_t *conn,$/;"	f	file:
record_num_bytes_transferred_impl	or/connection.c	/^record_num_bytes_transferred_impl(connection_t *conn,$/;"	f	file:
refcnt	common/tortls.c	/^  int refcnt;$/;"	m	struct:tor_tls_context_t	file:
refcnt	or/eventdns.c	/^	int refcnt; \/* reference count. *\/$/;"	m	struct:evdns_server_port	file:
refcnt	or/or.h	/^  int refcnt; \/**< Reference count *\/$/;"	m	struct:addr_policy_t
refcnt	or/or.h	/^  int refcnt; \/**< Reference count for this cached_dir_t. *\/$/;"	m	struct:cached_dir_t
refcount	or/eventdns.c	/^	int refcount;$/;"	m	struct:search_state	file:
refcount	or/or.h	/^  unsigned int refcount;$/;"	m	struct:__anon46
refill_callback	or/main.c	/^refill_callback(periodic_timer_t *timer, void *arg)$/;"	f	file:
refill_timer	or/main.c	/^static periodic_timer_t *refill_timer = NULL;$/;"	v	file:
refresh_all_country_info	or/routerlist.c	/^refresh_all_country_info(void)$/;"	f
refs	common/crypto.c	/^  int refs; \/**< reference count, so we don't have to copy keys *\/$/;"	m	struct:crypto_pk_t	file:
register_client_proxy	or/transports.c	/^register_client_proxy(managed_proxy_t *mp)$/;"	f	file:
register_proxy	or/transports.c	/^register_proxy(managed_proxy_t *mp)$/;"	f	file:
register_server_proxy	or/transports.c	/^register_server_proxy(managed_proxy_t *mp)$/;"	f	file:
reissue_count	or/eventdns.c	/^	int reissue_count;$/;"	m	struct:evdns_request	file:
reject_count	or/policies.c	/^    uint64_t reject_count; \/**< Number of IP-Addresses that are rejected to$/;"	m	struct:policy_summary_item_t	file:
rejects_all	or/or.h	/^  unsigned int rejects_all:1;$/;"	m	struct:node_t
relay_command_to_string	or/relay.c	/^relay_command_to_string(uint8_t command)$/;"	f	file:
relay_crypt	or/relay.c	/^relay_crypt(circuit_t *circ, cell_t *cell, cell_direction_t cell_direction,$/;"	f
relay_crypt_one_payload	or/relay.c	/^relay_crypt_one_payload(crypto_cipher_t *cipher, uint8_t *in,$/;"	f	file:
relay_digest_matches	or/relay.c	/^relay_digest_matches(crypto_digest_t *digest, cell_t *cell)$/;"	f	file:
relay_early_cells_sent	or/or.h	/^  int relay_early_cells_sent;$/;"	m	struct:origin_circuit_t
relay_early_commands	or/or.h	/^  uint8_t relay_early_commands[MAX_RELAY_EARLY_CELLS_PER_CIRCUIT];$/;"	m	struct:origin_circuit_t
relay_header_pack	or/relay.c	/^relay_header_pack(uint8_t *dest, const relay_header_t *src)$/;"	f
relay_header_t	or/or.h	/^} relay_header_t;$/;"	t	typeref:struct:__anon36
relay_header_unpack	or/relay.c	/^relay_header_unpack(relay_header_t *dest, const uint8_t *src)$/;"	f
relay_lookup_conn	or/relay.c	/^relay_lookup_conn(circuit_t *circ, cell_t *cell,$/;"	f	file:
relay_send_command_from_edge	or/relay.c	/^relay_send_command_from_edge(streamid_t stream_id, circuit_t *circ,$/;"	f
relay_send_end_cell_from_edge	or/connection_edge.c	/^relay_send_end_cell_from_edge(streamid_t stream_id, circuit_t *circ,$/;"	f	file:
relay_set_digest	or/relay.c	/^relay_set_digest(crypto_digest_t *digest, cell_t *cell)$/;"	f	file:
release_lockfile	or/main.c	/^release_lockfile(void)$/;"	f
remaining_relay_early_cells	or/or.h	/^  unsigned int remaining_relay_early_cells : 4;$/;"	m	struct:or_circuit_t
remaining_relay_early_cells	or/or.h	/^  unsigned int remaining_relay_early_cells : 4;$/;"	m	struct:origin_circuit_t
remap_event_helper	or/relay.c	/^remap_event_helper(entry_connection_t *conn, uint32_t new_addr)$/;"	f	file:
remove_cell_ewma_from_conn	or/relay.c	/^remove_cell_ewma_from_conn(or_connection_t *conn, cell_ewma_t *ewma)$/;"	f	file:
remove_dead_entry_guards	or/circuitbuild.c	/^remove_dead_entry_guards(time_t now)$/;"	f	file:
remove_directory	test/test.c	/^remove_directory(void)$/;"	f	file:
remove_file_if_very_old	or/config.c	/^remove_file_if_very_old(const char *fname, time_t now)$/;"	f
remove_obsolete_entry_guards	or/circuitbuild.c	/^remove_obsolete_entry_guards(time_t now)$/;"	f	file:
rename_on_close	common/util.c	/^  unsigned rename_on_close:1; \/**< Are we using the temporary file or not? *\/$/;"	m	struct:open_file_t	file:
rend_add_service	or/rendservice.c	/^rend_add_service(rend_service_t *service)$/;"	f	file:
rend_auth_type_t	or/or.h	/^typedef enum rend_auth_type_t {$/;"	g
rend_auth_type_t	or/or.h	/^} rend_auth_type_t;$/;"	t	typeref:enum:rend_auth_type_t
rend_authorized_client_free	or/rendservice.c	/^rend_authorized_client_free(rend_authorized_client_t *client)$/;"	f	file:
rend_authorized_client_strmap_item_free	or/rendservice.c	/^rend_authorized_client_strmap_item_free(void *authorized_client)$/;"	f	file:
rend_authorized_client_t	or/or.h	/^typedef struct rend_authorized_client_t {$/;"	s
rend_authorized_client_t	or/or.h	/^} rend_authorized_client_t;$/;"	t	typeref:struct:rend_authorized_client_t
rend_cache	or/rendcommon.c	/^static strmap_t *rend_cache = NULL;$/;"	v	file:
rend_cache_clean	or/rendcommon.c	/^rend_cache_clean(time_t now)$/;"	f
rend_cache_clean_v2_descs_as_dir	or/rendcommon.c	/^rend_cache_clean_v2_descs_as_dir(time_t now)$/;"	f
rend_cache_entry_free	or/rendcommon.c	/^rend_cache_entry_free(rend_cache_entry_t *e)$/;"	f	file:
rend_cache_entry_t	or/or.h	/^typedef struct rend_cache_entry_t {$/;"	s
rend_cache_entry_t	or/or.h	/^} rend_cache_entry_t;$/;"	t	typeref:struct:rend_cache_entry_t
rend_cache_free_all	or/rendcommon.c	/^rend_cache_free_all(void)$/;"	f
rend_cache_init	or/rendcommon.c	/^rend_cache_init(void)$/;"	f
rend_cache_lookup_desc	or/rendcommon.c	/^rend_cache_lookup_desc(const char *query, int version, const char **desc,$/;"	f
rend_cache_lookup_entry	or/rendcommon.c	/^rend_cache_lookup_entry(const char *query, int version, rend_cache_entry_t **e)$/;"	f
rend_cache_lookup_v2_desc_as_dir	or/rendcommon.c	/^rend_cache_lookup_v2_desc_as_dir(const char *desc_id, const char **desc)$/;"	f
rend_cache_purge	or/rendcommon.c	/^rend_cache_purge(void)$/;"	f
rend_cache_size	or/rendcommon.c	/^rend_cache_size(void)$/;"	f
rend_cache_store	or/rendcommon.c	/^rend_cache_store(const char *desc, size_t desc_len, int published,$/;"	f
rend_cache_store_v2_desc_as_client	or/rendcommon.c	/^rend_cache_store_v2_desc_as_client(const char *desc,$/;"	f
rend_cache_store_v2_desc_as_dir	or/rendcommon.c	/^rend_cache_store_v2_desc_as_dir(const char *desc)$/;"	f
rend_cache_v2_dir	or/rendcommon.c	/^static digestmap_t *rend_cache_v2_dir = NULL;$/;"	v	file:
rend_check_authorization	or/rendservice.c	/^rend_check_authorization(rend_service_t *service,$/;"	f	file:
rend_client_any_intro_points_usable	or/rendclient.c	/^rend_client_any_intro_points_usable(const rend_cache_entry_t *entry)$/;"	f
rend_client_cancel_descriptor_fetches	or/rendclient.c	/^rend_client_cancel_descriptor_fetches(void)$/;"	f
rend_client_desc_trynow	or/rendclient.c	/^rend_client_desc_trynow(const char *query)$/;"	f
rend_client_get_random_intro	or/rendclient.c	/^rend_client_get_random_intro(const rend_data_t *rend_query)$/;"	f
rend_client_get_random_intro_impl	or/rendclient.c	/^rend_client_get_random_intro_impl(const rend_cache_entry_t *entry,$/;"	f	file:
rend_client_introcirc_has_opened	or/rendclient.c	/^rend_client_introcirc_has_opened(origin_circuit_t *circ)$/;"	f
rend_client_introduction_acked	or/rendclient.c	/^rend_client_introduction_acked(origin_circuit_t *circ,$/;"	f
rend_client_lookup_service_authorization	or/rendclient.c	/^rend_client_lookup_service_authorization(const char *onion_address)$/;"	f
rend_client_note_connection_attempt_ended	or/rendclient.c	/^rend_client_note_connection_attempt_ended(const char *onion_address)$/;"	f
rend_client_purge_last_hid_serv_requests	or/rendclient.c	/^rend_client_purge_last_hid_serv_requests(void)$/;"	f
rend_client_purge_state	or/rendclient.c	/^rend_client_purge_state(void)$/;"	f
rend_client_receive_rendezvous	or/rendclient.c	/^rend_client_receive_rendezvous(origin_circuit_t *circ, const uint8_t *request,$/;"	f
rend_client_reextend_intro_circuit	or/rendclient.c	/^rend_client_reextend_intro_circuit(origin_circuit_t *circ)$/;"	f	file:
rend_client_refetch_v2_renddesc	or/rendclient.c	/^rend_client_refetch_v2_renddesc(const rend_data_t *rend_query)$/;"	f
rend_client_rendcirc_has_opened	or/rendclient.c	/^rend_client_rendcirc_has_opened(origin_circuit_t *circ)$/;"	f
rend_client_rendezvous_acked	or/rendclient.c	/^rend_client_rendezvous_acked(origin_circuit_t *circ, const uint8_t *request,$/;"	f
rend_client_report_intro_point_failure	or/rendclient.c	/^rend_client_report_intro_point_failure(extend_info_t *failed_intro,$/;"	f
rend_client_send_establish_rendezvous	or/rendclient.c	/^rend_client_send_establish_rendezvous(origin_circuit_t *circ)$/;"	f	file:
rend_client_send_introduction	or/rendclient.c	/^rend_client_send_introduction(origin_circuit_t *introcirc,$/;"	f
rend_cmp_service_ids	or/rendcommon.c	/^rend_cmp_service_ids(const char *one, const char *two)$/;"	f
rend_compute_v2_desc_id	or/rendcommon.c	/^rend_compute_v2_desc_id(char *desc_id_out, const char *service_id,$/;"	f
rend_config_services	or/rendservice.c	/^rend_config_services(const or_options_t *options, int validate_only)$/;"	f
rend_consider_descriptor_republication	or/rendservice.c	/^rend_consider_descriptor_republication(void)$/;"	f
rend_consider_services_upload	or/rendservice.c	/^rend_consider_services_upload(time_t now)$/;"	f
rend_cookie	or/or.h	/^  char rend_cookie[REND_COOKIE_LEN];$/;"	m	struct:rend_data_t
rend_data	or/or.h	/^  rend_data_t *rend_data;$/;"	m	struct:dir_connection_t
rend_data	or/or.h	/^  rend_data_t *rend_data;$/;"	m	struct:edge_connection_t
rend_data	or/or.h	/^  rend_data_t *rend_data;$/;"	m	struct:origin_circuit_t
rend_data_dup	or/rendcommon.c	/^rend_data_dup(const rend_data_t *data)$/;"	f
rend_data_free	or/rendcommon.h	/^rend_data_free(rend_data_t *data)$/;"	f
rend_data_t	or/or.h	/^typedef struct rend_data_t {$/;"	s
rend_data_t	or/or.h	/^} rend_data_t;$/;"	t	typeref:struct:rend_data_t
rend_decrypt_introduction_points	or/routerparse.c	/^rend_decrypt_introduction_points(char **ipos_decrypted,$/;"	f
rend_desc_v2_is_parsable	or/rendcommon.c	/^rend_desc_v2_is_parsable(rend_encoded_v2_service_descriptor_t *desc)$/;"	f	file:
rend_encode_v2_descriptors	or/rendcommon.c	/^rend_encode_v2_descriptors(smartlist_t *descs_out,$/;"	f
rend_encode_v2_intro_points	or/rendcommon.c	/^rend_encode_v2_intro_points(char **encoded, rend_service_descriptor_t *desc)$/;"	f	file:
rend_encoded_v2_service_descriptor_free	or/rendcommon.c	/^rend_encoded_v2_service_descriptor_free($/;"	f
rend_encoded_v2_service_descriptor_t	or/or.h	/^typedef struct rend_encoded_v2_service_descriptor_t {$/;"	s
rend_encoded_v2_service_descriptor_t	or/or.h	/^} rend_encoded_v2_service_descriptor_t;$/;"	t	typeref:struct:rend_encoded_v2_service_descriptor_t
rend_encrypt_v2_intro_points_basic	or/rendcommon.c	/^rend_encrypt_v2_intro_points_basic(char **encrypted_out,$/;"	f	file:
rend_encrypt_v2_intro_points_stealth	or/rendcommon.c	/^rend_encrypt_v2_intro_points_stealth(char **encrypted_out,$/;"	f	file:
rend_get_descriptor_id_bytes	or/rendcommon.c	/^rend_get_descriptor_id_bytes(char *descriptor_id_out,$/;"	f
rend_get_service_id	or/rendcommon.c	/^rend_get_service_id(crypto_pk_t *pk, char *out)$/;"	f
rend_hsdir_routers_changed	or/rendservice.c	/^rend_hsdir_routers_changed(void)$/;"	f
rend_id_is_in_interval	or/rendcommon.c	/^rend_id_is_in_interval(const char *a, const char *b, const char *c)$/;"	f
rend_intro_point_free	or/rendcommon.c	/^rend_intro_point_free(rend_intro_point_t *intro)$/;"	f
rend_intro_point_t	or/or.h	/^typedef struct rend_intro_point_t {$/;"	s
rend_intro_point_t	or/or.h	/^} rend_intro_point_t;$/;"	t	typeref:struct:rend_intro_point_t
rend_mid_establish_intro	or/rendmid.c	/^rend_mid_establish_intro(or_circuit_t *circ, const uint8_t *request,$/;"	f
rend_mid_establish_rendezvous	or/rendmid.c	/^rend_mid_establish_rendezvous(or_circuit_t *circ, const uint8_t *request,$/;"	f
rend_mid_introduce	or/rendmid.c	/^rend_mid_introduce(or_circuit_t *circ, const uint8_t *request,$/;"	f
rend_mid_rendezvous	or/rendmid.c	/^rend_mid_rendezvous(or_circuit_t *circ, const uint8_t *request,$/;"	f
rend_parse_client_keys	or/routerparse.c	/^rend_parse_client_keys(strmap_t *parsed_clients, const char *ckstr)$/;"	f
rend_parse_introduction_points	or/routerparse.c	/^rend_parse_introduction_points(rend_service_descriptor_t *parsed,$/;"	f
rend_parse_service_authorization	or/rendclient.c	/^rend_parse_service_authorization(const or_options_t *options,$/;"	f
rend_parse_service_descriptor	or/rendcommon.c	/^rend_parse_service_descriptor(const char *str, size_t len)$/;"	f
rend_parse_v2_service_descriptor	or/routerparse.c	/^rend_parse_v2_service_descriptor(rend_service_descriptor_t **parsed_out,$/;"	f
rend_pk_digest	or/or.h	/^  char rend_pk_digest[DIGEST_LEN];$/;"	m	struct:rend_data_t
rend_process_relay_cell	or/rendcommon.c	/^rend_process_relay_cell(circuit_t *circ, const crypt_path_t *layer_hint,$/;"	f
rend_service_authorization_free	or/rendclient.c	/^rend_service_authorization_free(rend_service_authorization_t *auth)$/;"	f	file:
rend_service_authorization_free_all	or/rendclient.c	/^rend_service_authorization_free_all(void)$/;"	f
rend_service_authorization_strmap_item_free	or/rendclient.c	/^rend_service_authorization_strmap_item_free(void *service_auth)$/;"	f	file:
rend_service_authorization_t	or/or.h	/^typedef struct rend_service_authorization_t {$/;"	s
rend_service_authorization_t	or/or.h	/^} rend_service_authorization_t;$/;"	t	typeref:struct:rend_service_authorization_t
rend_service_describe_for_log	or/rendservice.c	/^rend_service_describe_for_log(rend_service_t *service)$/;"	f	file:
rend_service_descriptor_free	or/rendcommon.c	/^rend_service_descriptor_free(rend_service_descriptor_t *desc)$/;"	f
rend_service_descriptor_t	or/or.h	/^typedef struct rend_service_descriptor_t {$/;"	s
rend_service_descriptor_t	or/or.h	/^} rend_service_descriptor_t;$/;"	t	typeref:struct:rend_service_descriptor_t
rend_service_dump_stats	or/rendservice.c	/^rend_service_dump_stats(int severity)$/;"	f
rend_service_free	or/rendservice.c	/^rend_service_free(rend_service_t *service)$/;"	f	file:
rend_service_free_all	or/rendservice.c	/^rend_service_free_all(void)$/;"	f
rend_service_get_by_pk_digest	or/rendservice.c	/^rend_service_get_by_pk_digest(const char* digest)$/;"	f	file:
rend_service_intro_established	or/rendservice.c	/^rend_service_intro_established(origin_circuit_t *circuit,$/;"	f
rend_service_intro_has_opened	or/rendservice.c	/^rend_service_intro_has_opened(origin_circuit_t *circuit)$/;"	f
rend_service_introduce	or/rendservice.c	/^rend_service_introduce(origin_circuit_t *circuit, const uint8_t *request,$/;"	f
rend_service_launch_establish_intro	or/rendservice.c	/^rend_service_launch_establish_intro(rend_service_t *service,$/;"	f	file:
rend_service_list	or/rendservice.c	/^static smartlist_t *rend_service_list = NULL;$/;"	v	file:
rend_service_load_keys	or/rendservice.c	/^rend_service_load_keys(void)$/;"	f
rend_service_note_removing_intro_point	or/rendservice.c	/^rend_service_note_removing_intro_point(rend_service_t *service,$/;"	f	file:
rend_service_note_removing_intro_point_called	or/or.h	/^  unsigned int rend_service_note_removing_intro_point_called : 1;$/;"	m	struct:rend_intro_point_t
rend_service_port_config_t	or/rendservice.c	/^typedef struct rend_service_port_config_t {$/;"	s	file:
rend_service_port_config_t	or/rendservice.c	/^} rend_service_port_config_t;$/;"	t	typeref:struct:rend_service_port_config_t	file:
rend_service_relaunch_rendezvous	or/rendservice.c	/^rend_service_relaunch_rendezvous(origin_circuit_t *oldcirc)$/;"	f
rend_service_rendezvous_has_opened	or/rendservice.c	/^rend_service_rendezvous_has_opened(origin_circuit_t *circuit)$/;"	f
rend_service_requires_uptime	or/rendservice.c	/^rend_service_requires_uptime(rend_service_t *service)$/;"	f	file:
rend_service_set_connection_addr_port	or/rendservice.c	/^rend_service_set_connection_addr_port(edge_connection_t *conn,$/;"	f
rend_service_t	or/rendservice.c	/^typedef struct rend_service_t {$/;"	s	file:
rend_service_t	or/rendservice.c	/^} rend_service_t;$/;"	t	typeref:struct:rend_service_t	file:
rend_service_update_descriptor	or/rendservice.c	/^rend_service_update_descriptor(rend_service_t *service)$/;"	f	file:
rend_services_introduce	or/rendservice.c	/^rend_services_introduce(void)$/;"	f
rend_splice	or/or.h	/^  struct or_circuit_t *rend_splice;$/;"	m	struct:or_circuit_t	typeref:struct:or_circuit_t::or_circuit_t
rend_token	or/or.h	/^  char rend_token[REND_TOKEN_LEN];$/;"	m	struct:or_circuit_t
rend_valid_service_id	or/rendcommon.c	/^rend_valid_service_id(const char *query)$/;"	f
rep_hist_add_buffer_stats	or/rephist.c	/^rep_hist_add_buffer_stats(double mean_num_cells_in_queue,$/;"	f
rep_hist_bandwidth_assess	or/rephist.c	/^rep_hist_bandwidth_assess(void)$/;"	f
rep_hist_buffer_stats_add_circ	or/rephist.c	/^rep_hist_buffer_stats_add_circ(circuit_t *circ, time_t end_of_interval)$/;"	f
rep_hist_buffer_stats_init	or/rephist.c	/^rep_hist_buffer_stats_init(time_t now)$/;"	f
rep_hist_buffer_stats_term	or/rephist.c	/^rep_hist_buffer_stats_term(void)$/;"	f
rep_hist_buffer_stats_write	or/rephist.c	/^rep_hist_buffer_stats_write(time_t now)$/;"	f
rep_hist_circbuilding_dormant	or/rephist.c	/^rep_hist_circbuilding_dormant(time_t now)$/;"	f
rep_hist_conn_stats_init	or/rephist.c	/^rep_hist_conn_stats_init(time_t now)$/;"	f
rep_hist_conn_stats_term	or/rephist.c	/^rep_hist_conn_stats_term(void)$/;"	f
rep_hist_conn_stats_write	or/rephist.c	/^rep_hist_conn_stats_write(time_t now)$/;"	f
rep_hist_desc_stats_init	or/rephist.c	/^rep_hist_desc_stats_init(time_t now)$/;"	f
rep_hist_desc_stats_term	or/rephist.c	/^rep_hist_desc_stats_term(void)$/;"	f
rep_hist_desc_stats_write	or/rephist.c	/^rep_hist_desc_stats_write(time_t now)$/;"	f
rep_hist_downrate_old_runs	or/rephist.c	/^rep_hist_downrate_old_runs(time_t now)$/;"	f
rep_hist_dump_stats	or/rephist.c	/^rep_hist_dump_stats(time_t now, int severity)$/;"	f
rep_hist_exit_stats_init	or/rephist.c	/^rep_hist_exit_stats_init(time_t now)$/;"	f
rep_hist_exit_stats_term	or/rephist.c	/^rep_hist_exit_stats_term(void)$/;"	f
rep_hist_exit_stats_write	or/rephist.c	/^rep_hist_exit_stats_write(time_t now)$/;"	f
rep_hist_fill_bandwidth_history	or/rephist.c	/^rep_hist_fill_bandwidth_history(char *buf, size_t len, const bw_array_t *b)$/;"	f	file:
rep_hist_format_buffer_stats	or/rephist.c	/^rep_hist_format_buffer_stats(time_t now)$/;"	f
rep_hist_format_conn_stats	or/rephist.c	/^rep_hist_format_conn_stats(time_t now)$/;"	f
rep_hist_format_desc_stats	or/rephist.c	/^rep_hist_format_desc_stats(time_t now)$/;"	f	file:
rep_hist_format_exit_stats	or/rephist.c	/^rep_hist_format_exit_stats(time_t now)$/;"	f
rep_hist_format_router_status	or/rephist.c	/^rep_hist_format_router_status(or_history_t *hist, time_t now)$/;"	f	file:
rep_hist_free_all	or/rephist.c	/^rep_hist_free_all(void)$/;"	f
rep_hist_get_bandwidth_lines	or/rephist.c	/^rep_hist_get_bandwidth_lines(void)$/;"	f
rep_hist_get_predicted_internal	or/rephist.c	/^rep_hist_get_predicted_internal(time_t now, int *need_uptime,$/;"	f
rep_hist_get_predicted_ports	or/rephist.c	/^rep_hist_get_predicted_ports(time_t now)$/;"	f
rep_hist_get_router_stability_doc	or/rephist.c	/^rep_hist_get_router_stability_doc(time_t now)$/;"	f
rep_hist_get_stability	or/rephist.c	/^rep_hist_get_stability(const char *id, time_t when)$/;"	f
rep_hist_get_uptime	or/rephist.c	/^rep_hist_get_uptime(const char *id, time_t when)$/;"	f
rep_hist_get_weighted_fractional_uptime	or/rephist.c	/^rep_hist_get_weighted_fractional_uptime(const char *id, time_t when)$/;"	f
rep_hist_get_weighted_time_known	or/rephist.c	/^rep_hist_get_weighted_time_known(const char *id, time_t when)$/;"	f
rep_hist_have_measured_enough_stability	or/rephist.c	/^rep_hist_have_measured_enough_stability(void)$/;"	f
rep_hist_init	or/rephist.c	/^rep_hist_init(void)$/;"	f
rep_hist_load_bwhist_state_section	or/rephist.c	/^rep_hist_load_bwhist_state_section(bw_array_t *b,$/;"	f	file:
rep_hist_load_mtbf_data	or/rephist.c	/^rep_hist_load_mtbf_data(time_t now)$/;"	f
rep_hist_load_state	or/rephist.c	/^rep_hist_load_state(or_state_t *state, char **err)$/;"	f
rep_hist_note_bytes_read	or/rephist.c	/^rep_hist_note_bytes_read(size_t num_bytes, time_t when)$/;"	f
rep_hist_note_bytes_written	or/rephist.c	/^rep_hist_note_bytes_written(size_t num_bytes, time_t when)$/;"	f
rep_hist_note_connect_failed	or/rephist.c	/^rep_hist_note_connect_failed(const char* id, time_t when)$/;"	f
rep_hist_note_connect_succeeded	or/rephist.c	/^rep_hist_note_connect_succeeded(const char* id, time_t when)$/;"	f
rep_hist_note_connection_died	or/rephist.c	/^rep_hist_note_connection_died(const char* id, time_t when)$/;"	f
rep_hist_note_desc_served	or/rephist.c	/^rep_hist_note_desc_served(const char * desc)$/;"	f
rep_hist_note_dir_bytes_read	or/rephist.c	/^rep_hist_note_dir_bytes_read(size_t num_bytes, time_t when)$/;"	f
rep_hist_note_dir_bytes_written	or/rephist.c	/^rep_hist_note_dir_bytes_written(size_t num_bytes, time_t when)$/;"	f
rep_hist_note_disconnect	or/rephist.c	/^rep_hist_note_disconnect(const char* id, time_t when)$/;"	f
rep_hist_note_exit_bytes	or/rephist.c	/^rep_hist_note_exit_bytes(uint16_t port, size_t num_written,$/;"	f
rep_hist_note_exit_stream_opened	or/rephist.c	/^rep_hist_note_exit_stream_opened(uint16_t port)$/;"	f
rep_hist_note_extend_failed	or/rephist.c	/^rep_hist_note_extend_failed(const char *from_id, const char *to_id)$/;"	f
rep_hist_note_extend_succeeded	or/rephist.c	/^rep_hist_note_extend_succeeded(const char *from_id, const char *to_id)$/;"	f
rep_hist_note_or_conn_bytes	or/rephist.c	/^rep_hist_note_or_conn_bytes(uint64_t conn_id, size_t num_read,$/;"	f
rep_hist_note_router_reachable	or/rephist.c	/^rep_hist_note_router_reachable(const char *id, const tor_addr_t *at_addr,$/;"	f
rep_hist_note_router_unreachable	or/rephist.c	/^rep_hist_note_router_unreachable(const char *id, time_t when)$/;"	f
rep_hist_note_used_internal	or/rephist.c	/^rep_hist_note_used_internal(time_t now, int need_uptime, int need_capacity)$/;"	f
rep_hist_note_used_port	or/rephist.c	/^rep_hist_note_used_port(time_t now, uint16_t port)$/;"	f
rep_hist_note_used_resolve	or/rephist.c	/^rep_hist_note_used_resolve(time_t now)$/;"	f
rep_hist_record_mtbf_data	or/rephist.c	/^rep_hist_record_mtbf_data(time_t now, int missing_means_down)$/;"	f
rep_hist_reset_buffer_stats	or/rephist.c	/^rep_hist_reset_buffer_stats(time_t now)$/;"	f
rep_hist_reset_conn_stats	or/rephist.c	/^rep_hist_reset_conn_stats(time_t now)$/;"	f
rep_hist_reset_desc_stats	or/rephist.c	/^rep_hist_reset_desc_stats(time_t now)$/;"	f	file:
rep_hist_reset_exit_stats	or/rephist.c	/^rep_hist_reset_exit_stats(time_t now)$/;"	f
rep_hist_update_bwhist_state_section	or/rephist.c	/^rep_hist_update_bwhist_state_section(or_state_t *state,$/;"	f	file:
rep_hist_update_state	or/rephist.c	/^rep_hist_update_state(or_state_t *state)$/;"	f
rep_history_clean	or/rephist.c	/^rep_history_clean(time_t before)$/;"	f
rephist_total_alloc	or/rephist.c	/^uint64_t rephist_total_alloc=0;$/;"	v
rephist_total_num	or/rephist.c	/^uint32_t rephist_total_num=0;$/;"	v
replace_file	common/compat.c	/^replace_file(const char *from, const char *to)$/;"	f
reply	or/eventdns.c	/^struct reply {$/;"	s	file:
reply	or/or.h	/^  uint8_t reply[MAX_SOCKS_REPLY_LEN]; \/**< Write an entry into this string if$/;"	m	struct:socks_request_t
reply_callback	or/eventdns.c	/^reply_callback(struct evdns_request *const req, u32 ttl, u32 err, struct reply *reply) {$/;"	f	file:
reply_handle	or/eventdns.c	/^reply_handle(struct evdns_request *const req, u16 flags, u32 ttl, struct reply *reply) {$/;"	f	file:
reply_parse	or/eventdns.c	/^reply_parse(u8 *packet, int length) {$/;"	f	file:
replylen	or/or.h	/^  size_t replylen; \/**< Length of <b>reply<\/b>. *\/$/;"	m	struct:socks_request_t
req	test/test.c	/^  socks_request_t *req;$/;"	m	struct:socks_test_data_t	file:
req_head	or/eventdns.c	/^static struct evdns_request *req_head = NULL, *req_waiting_head = NULL;$/;"	v	typeref:struct:evdns_request	file:
req_waiting_head	or/eventdns.c	/^static struct evdns_request *req_head = NULL, *req_waiting_head = NULL;$/;"	v	typeref:struct:	file:
request	or/eventdns.c	/^	u8 *request; \/* the dns packet data *\/$/;"	m	struct:evdns_request	file:
request_appended	or/eventdns.c	/^	char request_appended;	\/* true if the request pointer is data which follows this struct *\/$/;"	m	struct:evdns_request	file:
request_find_from_trans_id	or/eventdns.c	/^request_find_from_trans_id(u16 trans_id) {$/;"	f	file:
request_finished	or/eventdns.c	/^request_finished(struct evdns_request *const req, struct evdns_request **head) {$/;"	f	file:
request_len	or/eventdns.c	/^	unsigned int request_len;$/;"	m	struct:evdns_request	file:
request_map	or/directory.c	/^static strmap_t *request_map = NULL;$/;"	v	file:
request_new	or/eventdns.c	/^request_new(int type, const char *name, int flags,$/;"	f	file:
request_parse	or/eventdns.c	/^request_parse(u8 *packet, ssize_t length, struct evdns_server_port *port, struct sockaddr *addr, socklen_t addrlen)$/;"	f	file:
request_reissue	or/eventdns.c	/^request_reissue(struct evdns_request *req) {$/;"	f	file:
request_submit	or/eventdns.c	/^request_submit(struct evdns_request *const req) {$/;"	f	file:
request_t	or/directory.c	/^typedef struct request_t {$/;"	s	file:
request_t	or/directory.c	/^} request_t;$/;"	t	typeref:struct:request_t	file:
request_time	or/geoip.c	/^  struct timeval request_time;$/;"	m	struct:dirreq_map_entry_t	typeref:struct:dirreq_map_entry_t::timeval	file:
request_trans_id_set	or/eventdns.c	/^request_trans_id_set(struct evdns_request *const req, const u16 trans_id) {$/;"	f	file:
request_type	or/eventdns.c	/^	unsigned int request_type; \/* TYPE_PTR or TYPE_A *\/$/;"	m	struct:evdns_request	file:
requested_resource	or/or.h	/^  char *requested_resource;$/;"	m	struct:dir_connection_t
reset_accounting	or/hibernate.c	/^reset_accounting(time_t now)$/;"	f	file:
reset_bandwidth_test	or/circuituse.c	/^reset_bandwidth_test(void)$/;"	f
reset_mp	test/test_pt.c	/^reset_mp(managed_proxy_t *mp)$/;"	f	file:
reset_perftime	test/bench.c	/^reset_perftime(void)$/;"	f	file:
resolv_conf_fname	or/dns.c	/^static char *resolv_conf_fname = NULL;$/;"	v	file:
resolv_conf_mtime	or/dns.c	/^static time_t resolv_conf_mtime = 0;$/;"	v	file:
resolv_conf_parse_line	or/eventdns.c	/^resolv_conf_parse_line(char *const start, int flags) {$/;"	f	file:
resolve_my_address	or/config.c	/^resolve_my_address(int warn_severity, const or_options_t *options,$/;"	f
resolving_streams	or/or.h	/^  edge_connection_t *resolving_streams;$/;"	m	struct:or_circuit_t
response	or/eventdns.c	/^	char *response;$/;"	m	struct:server_request	file:
response	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  natpmpresp_t response;$/;"	m	struct:natpmp_state_t
response_len	or/eventdns.c	/^	size_t response_len;$/;"	m	struct:server_request	file:
response_size	or/geoip.c	/^  size_t response_size; \/**< What is the size of the response in bytes? *\/$/;"	m	struct:dirreq_map_entry_t	file:
result	or/dns.c	/^  } result;$/;"	m	struct:cached_resolve_t	typeref:union:cached_resolve_t::__anon26	file:
retry_all_listeners	or/connection.c	/^retry_all_listeners(smartlist_t *replaced_conns,$/;"	f
retry_bridge_descriptor_fetch_directly	or/circuitbuild.c	/^retry_bridge_descriptor_fetch_directly(const char *digest)$/;"	f
retry_listener_ports	or/connection.c	/^retry_listener_ports(smartlist_t *old_conns,$/;"	f	file:
reuse_signing_key	tools/tor-gencert.c	/^int reuse_signing_key = 0;$/;"	v
rewrite_node_address_for_bridge	or/circuitbuild.c	/^rewrite_node_address_for_bridge(const bridge_info_t *bridge, node_t *node)$/;"	f	file:
ri	or/or.h	/^  routerinfo_t *ri;$/;"	m	struct:node_t
rlim_t	common/compat.h	/^typedef unsigned long rlim_t;$/;"	t
rm_rf	test/test.c	/^rm_rf(const char *dir)$/;"	f	file:
rollback_log_changes	common/log.c	/^rollback_log_changes(void)$/;"	f
rotate_onion_key	or/router.c	/^rotate_onion_key(void)$/;"	f
round_to_next_multiple_of	common/util.c	/^round_to_next_multiple_of(unsigned number, unsigned divisor)$/;"	f
round_to_power_of_2	common/util.c	/^round_to_power_of_2(uint64_t u64)$/;"	f
round_uint32_to_next_multiple_of	common/util.c	/^round_uint32_to_next_multiple_of(uint32_t number, uint32_t divisor)$/;"	f
round_uint64_to_next_multiple_of	common/util.c	/^round_uint64_to_next_multiple_of(uint64_t number, uint64_t divisor)$/;"	f
router_add_exit_policy	or/routerparse.c	/^router_add_exit_policy(routerinfo_t *router, directory_token_t *tok)$/;"	f	file:
router_add_extrainfo_to_routerlist	or/routerlist.c	/^router_add_extrainfo_to_routerlist(extrainfo_t *ei, const char **msg,$/;"	f
router_add_running_nodes_to_smartlist	or/routerlist.c	/^router_add_running_nodes_to_smartlist(smartlist_t *sl, int allow_invalid,$/;"	f	file:
router_add_to_routerlist	or/routerlist.c	/^router_add_to_routerlist(routerinfo_t *router, const char **msg,$/;"	f
router_addr_is_trusted_dir	or/routerlist.c	/^router_addr_is_trusted_dir(uint32_t addr)$/;"	f
router_append_dirobj_signature	or/routerparse.c	/^router_append_dirobj_signature(char *buf, size_t buf_len, const char *digest,$/;"	f
router_choose_random_node	or/routerlist.c	/^router_choose_random_node(smartlist_t *excludedsmartlist,$/;"	f
router_compare_to_my_exit_policy	or/router.c	/^router_compare_to_my_exit_policy(edge_connection_t *conn)$/;"	f
router_crn_flags_t	or/or.h	/^} router_crn_flags_t;$/;"	t	typeref:enum:__anon66
router_describe	or/router.c	/^router_describe(const routerinfo_t *ri)$/;"	f
router_differences_are_cosmetic	or/routerlist.c	/^router_differences_are_cosmetic(const routerinfo_t *r1, const routerinfo_t *r2)$/;"	f
router_digest_is_me	or/router.c	/^router_digest_is_me(const char *digest)$/;"	f
router_digest_is_trusted_dir	or/routerlist.h	/^#define router_digest_is_trusted_dir(/;"	d
router_digest_is_trusted_dir_type	or/routerlist.c	/^router_digest_is_trusted_dir_type(const char *digest, dirinfo_type_t type)$/;"	f
router_dir_info_changed	or/routerlist.c	/^router_dir_info_changed(void)$/;"	f
router_dirport_found_reachable	or/router.c	/^router_dirport_found_reachable(void)$/;"	f
router_dump_router_to_string	or/router.c	/^router_dump_router_to_string(char *s, size_t maxlen, routerinfo_t *router,$/;"	f
router_exit_policy_all_nodes_reject	or/routerlist.c	/^router_exit_policy_all_nodes_reject(const tor_addr_t *addr, uint16_t port,$/;"	f
router_exit_policy_rejects_all	or/routerlist.c	/^router_exit_policy_rejects_all(const routerinfo_t *router)$/;"	f
router_extrainfo_digest_is_me	or/router.c	/^router_extrainfo_digest_is_me(const char *digest)$/;"	f
router_find_exact_exit_enclave	or/routerlist.c	/^router_find_exact_exit_enclave(const char *address, uint16_t port)$/;"	f
router_fingerprint_is_me	or/router.c	/^router_fingerprint_is_me(const char *fp)$/;"	f
router_free_all	or/router.c	/^router_free_all(void)$/;"	f
router_get_advertised_bandwidth	or/routerlist.c	/^router_get_advertised_bandwidth(const routerinfo_t *router)$/;"	f
router_get_advertised_bandwidth_capped	or/routerlist.c	/^router_get_advertised_bandwidth_capped(const routerinfo_t *router)$/;"	f
router_get_advertised_dir_port	or/router.c	/^router_get_advertised_dir_port(const or_options_t *options, uint16_t dirport)$/;"	f
router_get_advertised_or_port	or/router.c	/^router_get_advertised_or_port(const or_options_t *options)$/;"	f
router_get_by_descriptor_digest	or/routerlist.c	/^router_get_by_descriptor_digest(const char *digest)$/;"	f
router_get_by_extrainfo_digest	or/routerlist.c	/^router_get_by_extrainfo_digest(const char *digest)$/;"	f
router_get_by_hexdigest	or/routerlist.c	/^router_get_by_hexdigest(const char *hexdigest)$/;"	f
router_get_by_id_digest	or/routerlist.c	/^router_get_by_id_digest(const char *digest)$/;"	f
router_get_by_nickname	or/routerlist.c	/^router_get_by_nickname(const char *nickname, int warn_if_unnamed)$/;"	f
router_get_consensus_status_by_descriptor_digest	or/networkstatus.c	/^router_get_consensus_status_by_descriptor_digest(networkstatus_t *consensus,$/;"	f
router_get_consensus_status_by_id	or/networkstatus.c	/^router_get_consensus_status_by_id(const char *digest)$/;"	f
router_get_consensus_status_by_nickname	or/networkstatus.c	/^router_get_consensus_status_by_nickname(const char *nickname,$/;"	f
router_get_description	or/router.c	/^router_get_description(char *buf, const routerinfo_t *ri)$/;"	f
router_get_descriptor_gen_reason	or/router.c	/^router_get_descriptor_gen_reason(void)$/;"	f
router_get_dir_hash	or/routerparse.c	/^router_get_dir_hash(const char *s, char *digest)$/;"	f
router_get_dl_status_by_descriptor_digest	or/networkstatus.c	/^router_get_dl_status_by_descriptor_digest(const char *d)$/;"	f
router_get_extrainfo_hash	or/routerparse.c	/^router_get_extrainfo_hash(const char *s, char *digest)$/;"	f
router_get_hash_impl	or/routerparse.c	/^router_get_hash_impl(const char *s, size_t s_len, char *digest,$/;"	f	file:
router_get_hash_impl_helper	or/routerparse.c	/^router_get_hash_impl_helper(const char *s, size_t s_len,$/;"	f	file:
router_get_hashes_impl	or/routerparse.c	/^router_get_hashes_impl(const char *s, size_t s_len, digests_t *digests,$/;"	f	file:
router_get_mutable_by_digest	or/routerlist.c	/^router_get_mutable_by_digest(const char *digest)$/;"	f
router_get_mutable_consensus_status_by_descriptor_digest	or/networkstatus.c	/^router_get_mutable_consensus_status_by_descriptor_digest($/;"	f
router_get_mutable_consensus_status_by_id	or/networkstatus.c	/^router_get_mutable_consensus_status_by_id(const char *digest)$/;"	f
router_get_my_descriptor	or/router.c	/^router_get_my_descriptor(void)$/;"	f
router_get_my_extrainfo	or/router.c	/^router_get_my_extrainfo(void)$/;"	f
router_get_my_routerinfo	or/router.c	/^router_get_my_routerinfo(void)$/;"	f
router_get_my_share_of_directory_requests	or/routerlist.c	/^router_get_my_share_of_directory_requests(double *v2_share_out,$/;"	f
router_get_networkstatus_v2_hash	or/routerparse.c	/^router_get_networkstatus_v2_hash(const char *s, char *digest)$/;"	f
router_get_networkstatus_v3_hash	or/routerparse.c	/^router_get_networkstatus_v3_hash(const char *s, char *digest,$/;"	f
router_get_networkstatus_v3_hashes	or/routerparse.c	/^router_get_networkstatus_v3_hashes(const char *s, digests_t *digests)$/;"	f
router_get_pref_ipv6_orport	or/router.c	/^router_get_pref_ipv6_orport(const routerinfo_t *router,$/;"	f
router_get_pref_orport	or/router.c	/^router_get_pref_orport(const routerinfo_t *router, tor_addr_port_t *ap_out)$/;"	f
router_get_prim_orport	or/router.c	/^router_get_prim_orport(const routerinfo_t *router, tor_addr_port_t *ap_out)$/;"	f
router_get_router_hash	or/routerparse.c	/^router_get_router_hash(const char *s, size_t s_len, char *digest)$/;"	f
router_get_routerlist	or/routerlist.c	/^router_get_routerlist(void)$/;"	f
router_get_runningrouters_hash	or/routerparse.c	/^router_get_runningrouters_hash(const char *s, char *digest)$/;"	f
router_get_trusted_dir_servers	or/routerlist.c	/^router_get_trusted_dir_servers(void)$/;"	f
router_get_trusteddirserver_by_digest	or/routerlist.c	/^router_get_trusteddirserver_by_digest(const char *digest)$/;"	f
router_get_verbose_nickname	or/router.c	/^router_get_verbose_nickname(char *buf, const routerinfo_t *router)$/;"	f
router_guess_address_from_dir_headers	or/router.c	/^router_guess_address_from_dir_headers(uint32_t *guess)$/;"	f	file:
router_have_minimum_dir_info	or/routerlist.c	/^router_have_minimum_dir_info(void)$/;"	f
router_hex_digest_matches	or/routerlist.c	/^router_hex_digest_matches(const routerinfo_t *router, const char *hexdigest)$/;"	f	file:
router_initialize_tls_context	or/router.c	/^router_initialize_tls_context(void)$/;"	f
router_ipv6_preferred	or/router.c	/^router_ipv6_preferred(const routerinfo_t *router)$/;"	f
router_is_active	or/dirserv.c	/^router_is_active(const routerinfo_t *ri, const node_t *node, time_t now)$/;"	f	file:
router_is_me	or/router.c	/^router_is_me(const routerinfo_t *router)$/;"	f
router_is_named	or/routerlist.c	/^router_is_named(const routerinfo_t *router)$/;"	f
router_load_extrainfo_from_string	or/routerlist.c	/^router_load_extrainfo_from_string(const char *s, const char *eos,$/;"	f
router_load_routers_from_string	or/routerlist.c	/^router_load_routers_from_string(const char *s, const char *eos,$/;"	f
router_load_single_router	or/routerlist.c	/^router_load_single_router(const char *s, uint8_t purpose, int cache,$/;"	f
router_my_exit_policy_is_reject_star	or/router.c	/^router_my_exit_policy_is_reject_star(void)$/;"	f
router_new_address_suggestion	or/router.c	/^router_new_address_suggestion(const char *suggestion,$/;"	f
router_nickname_is_in_list	or/routerlist.c	/^router_nickname_is_in_list(const routerinfo_t *router, const char *list)$/;"	f
router_nickname_matches	or/routerlist.c	/^router_nickname_matches(const routerinfo_t *router, const char *nickname)$/;"	f	file:
router_orport_found_reachable	or/router.c	/^router_orport_found_reachable(void)$/;"	f
router_parse_addr_policy	or/routerparse.c	/^router_parse_addr_policy(directory_token_t *tok)$/;"	f	file:
router_parse_addr_policy_item_from_string	or/routerparse.c	/^router_parse_addr_policy_item_from_string(const char *s, int assume_action)$/;"	f
router_parse_addr_policy_private	or/routerparse.c	/^router_parse_addr_policy_private(directory_token_t *tok)$/;"	f	file:
router_parse_directory	or/routerparse.c	/^router_parse_directory(const char *str)$/;"	f
router_parse_entry_from_string	or/routerparse.c	/^router_parse_entry_from_string(const char *s, const char *end,$/;"	f
router_parse_list_from_string	or/routerparse.c	/^router_parse_list_from_string(const char **s, const char *eos,$/;"	f
router_parse_runningrouters	or/routerparse.c	/^router_parse_runningrouters(const char *str)$/;"	f
router_perform_bandwidth_test	or/router.c	/^router_perform_bandwidth_test(int num_circs, time_t now)$/;"	f
router_pick_directory_server	or/routerlist.c	/^router_pick_directory_server(dirinfo_type_t type, int flags)$/;"	f
router_pick_directory_server_impl	or/routerlist.c	/^router_pick_directory_server_impl(dirinfo_type_t type, int flags)$/;"	f	file:
router_pick_published_address	or/router.c	/^router_pick_published_address(const or_options_t *options, uint32_t *addr)$/;"	f
router_pick_trusteddirserver	or/routerlist.c	/^router_pick_trusteddirserver(dirinfo_type_t type, int flags)$/;"	f
router_pick_trusteddirserver_impl	or/routerlist.c	/^router_pick_trusteddirserver_impl(dirinfo_type_t type, int flags,$/;"	f	file:
router_purpose	or/or.h	/^  uint8_t router_purpose;$/;"	m	struct:dir_connection_t
router_purpose_from_string	or/router.c	/^router_purpose_from_string(const char *s)$/;"	f
router_purpose_to_string	or/router.c	/^router_purpose_to_string(uint8_t p)$/;"	f
router_rebuild_descriptor	or/router.c	/^router_rebuild_descriptor(int force)$/;"	f
router_rebuild_store	or/routerlist.c	/^router_rebuild_store(int flags, desc_store_t *store)$/;"	f	file:
router_reload_consensus_networkstatus	or/networkstatus.c	/^router_reload_consensus_networkstatus(void)$/;"	f
router_reload_router_list	or/routerlist.c	/^router_reload_router_list(void)$/;"	f
router_reload_router_list_impl	or/routerlist.c	/^router_reload_router_list_impl(desc_store_t *store)$/;"	f	file:
router_reload_v2_networkstatus	or/networkstatus.c	/^router_reload_v2_networkstatus(void)$/;"	f
router_reset_descriptor_download_failures	or/routerlist.c	/^router_reset_descriptor_download_failures(void)$/;"	f
router_reset_reachability	or/router.c	/^router_reset_reachability(void)$/;"	f
router_reset_status_download_failures	or/routerlist.c	/^router_reset_status_download_failures(void)$/;"	f
router_reset_warnings	or/router.c	/^router_reset_warnings(void)$/;"	f
router_set_networkstatus_v2	or/networkstatus.c	/^router_set_networkstatus_v2(const char *s, time_t arrived_at,$/;"	f
router_set_status	or/routerlist.c	/^router_set_status(const char *digest, int up)$/;"	f
router_should_rebuild_store	or/routerlist.c	/^router_should_rebuild_store(desc_store_t *store)$/;"	f	file:
router_status_t	or/dirserv.c	/^typedef struct router_status_t {$/;"	s	file:
router_status_t	or/dirserv.c	/^} router_status_t;$/;"	t	typeref:struct:router_status_t	file:
router_supports_extrainfo	or/directory.c	/^router_supports_extrainfo(const char *identity_digest, int is_authority)$/;"	f
router_upload_dir_desc_to_dirservers	or/router.c	/^router_upload_dir_desc_to_dirservers(int force)$/;"	f
routerdesc_token_table	or/routerparse.c	/^static token_rule_t routerdesc_token_table[] = {$/;"	v	file:
routerinfo_free	or/routerlist.c	/^routerinfo_free(routerinfo_t *router)$/;"	f
routerinfo_incompatible_with_extrainfo	or/routerlist.c	/^routerinfo_incompatible_with_extrainfo(const routerinfo_t *ri,$/;"	f
routerinfo_is_a_configured_bridge	or/circuitbuild.c	/^routerinfo_is_a_configured_bridge(const routerinfo_t *ri)$/;"	f
routerinfo_t	or/or.h	/^} routerinfo_t;$/;"	t	typeref:struct:__anon41
routerlist	or/routerlist.c	/^static routerlist_t *routerlist = NULL;$/;"	v	file:
routerlist_add_node_and_family	or/routerlist.c	/^routerlist_add_node_and_family(smartlist_t *sl, const routerinfo_t *router)$/;"	f	file:
routerlist_assert_ok	or/routerlist.c	/^routerlist_assert_ok(const routerlist_t *rl)$/;"	f
routerlist_descriptors_added	or/routerlist.c	/^routerlist_descriptors_added(smartlist_t *sl, int from_cache)$/;"	f
routerlist_find_my_routerinfo	or/routerlist.c	/^routerlist_find_my_routerinfo(void)$/;"	f
routerlist_free	or/routerlist.c	/^routerlist_free(routerlist_t *rl)$/;"	f
routerlist_free_all	or/routerlist.c	/^routerlist_free_all(void)$/;"	f
routerlist_index	or/or.h	/^  int routerlist_index;$/;"	m	struct:signed_descriptor_t
routerlist_insert	or/routerlist.c	/^routerlist_insert(routerlist_t *rl, routerinfo_t *ri)$/;"	f	file:
routerlist_insert_old	or/routerlist.c	/^routerlist_insert_old(routerlist_t *rl, routerinfo_t *ri)$/;"	f	file:
routerlist_remove	or/routerlist.c	/^routerlist_remove(routerlist_t *rl, routerinfo_t *ri, int make_old, time_t now)$/;"	f
routerlist_remove_old	or/routerlist.c	/^routerlist_remove_old(routerlist_t *rl, signed_descriptor_t *sd, int idx)$/;"	f	file:
routerlist_remove_old_cached_routers_with_id	or/routerlist.c	/^routerlist_remove_old_cached_routers_with_id(time_t now,$/;"	f	file:
routerlist_remove_old_routers	or/routerlist.c	/^routerlist_remove_old_routers(void)$/;"	f
routerlist_reparse_old	or/routerlist.c	/^routerlist_reparse_old(routerlist_t *rl, signed_descriptor_t *sd)$/;"	f	file:
routerlist_replace	or/routerlist.c	/^routerlist_replace(routerlist_t *rl, routerinfo_t *ri_old,$/;"	f	file:
routerlist_reset_warnings	or/routerlist.c	/^routerlist_reset_warnings(void)$/;"	f
routerlist_retry_directory_downloads	or/routerlist.c	/^routerlist_retry_directory_downloads(time_t now)$/;"	f
routerlist_t	or/or.h	/^} routerlist_t;$/;"	t	typeref:struct:__anon44
routers	or/or.h	/^  smartlist_t *routers;$/;"	m	struct:__anon44
routers_have_same_or_addr	or/routerlist.c	/^routers_have_same_or_addr(const routerinfo_t *r1, const routerinfo_t *r2)$/;"	f
routers_sort_by_identity	or/routerlist.c	/^routers_sort_by_identity(smartlist_t *routers)$/;"	f
routers_update_all_from_networkstatus	or/networkstatus.c	/^routers_update_all_from_networkstatus(time_t now, int dir_version)$/;"	f
routers_update_status_from_consensus_networkstatus	or/networkstatus.c	/^routers_update_status_from_consensus_networkstatus(smartlist_t *routers,$/;"	f
routerset_contains	or/routerlist.c	/^routerset_contains(const routerset_t *set, const tor_addr_t *addr,$/;"	f	file:
routerset_contains_bridge	or/circuitbuild.c	/^routerset_contains_bridge(const routerset_t *routerset,$/;"	f	file:
routerset_contains_extendinfo	or/routerlist.c	/^routerset_contains_extendinfo(const routerset_t *set, const extend_info_t *ei)$/;"	f
routerset_contains_node	or/routerlist.c	/^routerset_contains_node(const routerset_t *set, const node_t *node)$/;"	f
routerset_contains_router	or/routerlist.c	/^routerset_contains_router(const routerset_t *set, const routerinfo_t *ri,$/;"	f
routerset_contains_routerstatus	or/routerlist.c	/^routerset_contains_routerstatus(const routerset_t *set,$/;"	f
routerset_equal	or/routerlist.c	/^routerset_equal(const routerset_t *old, const routerset_t *new)$/;"	f
routerset_free	or/routerlist.c	/^routerset_free(routerset_t *routerset)$/;"	f
routerset_get_all_nodes	or/routerlist.c	/^routerset_get_all_nodes(smartlist_t *out, const routerset_t *routerset,$/;"	f
routerset_get_countryname	or/routerlist.c	/^routerset_get_countryname(const char *c)$/;"	f	file:
routerset_is_empty	or/routerlist.c	/^routerset_is_empty(const routerset_t *set)$/;"	f
routerset_is_list	or/routerlist.c	/^routerset_is_list(const routerset_t *set)$/;"	f
routerset_needs_geoip	or/routerlist.c	/^routerset_needs_geoip(const routerset_t *set)$/;"	f
routerset_new	or/routerlist.c	/^routerset_new(void)$/;"	f
routerset_parse	or/routerlist.c	/^routerset_parse(routerset_t *target, const char *s, const char *description)$/;"	f
routerset_refresh_countries	or/routerlist.c	/^routerset_refresh_countries(routerset_t *target)$/;"	f
routerset_subtract_nodes	or/routerlist.c	/^routerset_subtract_nodes(smartlist_t *lst, const routerset_t *routerset)$/;"	f
routerset_t	or/or.h	/^typedef struct routerset_t routerset_t;$/;"	t	typeref:struct:routerset_t
routerset_t	or/routerlist.c	/^struct routerset_t {$/;"	s	file:
routerset_to_string	or/routerlist.c	/^routerset_to_string(const routerset_t *set)$/;"	f
routerset_union	or/routerlist.c	/^routerset_union(routerset_t *target, const routerset_t *source)$/;"	f
routerstatus_describe	or/router.c	/^routerstatus_describe(const routerstatus_t *rs)$/;"	f
routerstatus_format_entry	or/dirserv.c	/^routerstatus_format_entry(char *buf, size_t buf_len,$/;"	f
routerstatus_format_type_t	or/or.h	/^} routerstatus_format_type_t;$/;"	t	typeref:enum:__anon58
routerstatus_free	or/networkstatus.c	/^routerstatus_free(routerstatus_t *rs)$/;"	f
routerstatus_get_description	or/router.c	/^routerstatus_get_description(char *buf, const routerstatus_t *rs)$/;"	f
routerstatus_get_verbose_nickname	or/router.c	/^routerstatus_get_verbose_nickname(char *buf, const routerstatus_t *router)$/;"	f
routerstatus_has_changed	or/networkstatus.c	/^routerstatus_has_changed(const routerstatus_t *a, const routerstatus_t *b)$/;"	f	file:
routerstatus_list	or/or.h	/^  smartlist_t *routerstatus_list;$/;"	m	struct:networkstatus_t
routerstatus_list_update_named_server_map	or/networkstatus.c	/^routerstatus_list_update_named_server_map(void)$/;"	f	file:
routerstatus_parse_entry_from_string	or/routerparse.c	/^routerstatus_parse_entry_from_string(memarea_t *area,$/;"	f	file:
routerstatus_t	or/or.h	/^typedef struct routerstatus_t {$/;"	s
routerstatus_t	or/or.h	/^} routerstatus_t;$/;"	t	typeref:struct:routerstatus_t
rs	or/or.h	/^  routerstatus_t *rs;$/;"	m	struct:node_t
rtrstatus_token_table	or/routerparse.c	/^static token_rule_t rtrstatus_token_table[] = {$/;"	v	file:
run_connection_housekeeping	or/main.c	/^run_connection_housekeeping(int i, time_t now)$/;"	f	file:
run_scheduled_events	or/main.c	/^run_scheduled_events(time_t now)$/;"	f	file:
run_util_spawn_background	test/test_util.c	/^run_util_spawn_background(const char *argv[], const char *expected_out,$/;"	f	file:
running_long_enough_to_decide_unreachable	or/dirserv.c	/^running_long_enough_to_decide_unreachable(void)$/;"	f	file:
runningrouters_is_dirty	or/dirserv.c	/^static time_t runningrouters_is_dirty = 1;$/;"	v	file:
s	common/OpenBSD_malloc_Linux.c	/^	size_t		s;$/;"	m	struct:ut	file:
s	or/or.h	/^  tor_socket_t s;$/;"	m	struct:connection_t
s6_addr	common/compat.h	/^#define s6_addr /;"	d
s6_addr	or/eventdns.c	/^	u8 s6_addr[16];$/;"	m	struct:in6_addr	file:
s6_addr16	common/compat.h	/^#define s6_addr16 /;"	d
s6_addr32	common/compat.h	/^#define s6_addr32 /;"	d
sa_family_t	common/compat.h	/^typedef uint16_t sa_family_t;$/;"	t
safe_str	or/config.c	/^safe_str(const char *address)$/;"	f
safe_str_client	or/config.c	/^safe_str_client(const char *address)$/;"	f
safecookie_client_hash	or/or.h	/^  char *safecookie_client_hash;$/;"	m	struct:control_connection_t
save_transport_to_state	or/config.c	/^save_transport_to_state(const char *transport,$/;"	f
saved_location	or/or.h	/^  saved_location_t saved_location : 3;$/;"	m	struct:microdesc_t
saved_location	or/or.h	/^  saved_location_t saved_location;$/;"	m	struct:signed_descriptor_t
saved_location_t	or/or.h	/^} saved_location_t;$/;"	t	typeref:enum:__anon39
saved_offset	or/or.h	/^  off_t saved_offset;$/;"	m	struct:signed_descriptor_t
scale_active_circuits	or/relay.c	/^scale_active_circuits(or_connection_t *conn, unsigned cur_tick)$/;"	f	file:
scale_single_cell_ewma	or/relay.c	/^scale_single_cell_ewma(cell_ewma_t *ewma, unsigned cur_tick)$/;"	f	file:
scan_string	common/util.c	/^scan_string(const char **bufp, char *out, int width)$/;"	f	file:
scan_unsigned	common/util.c	/^scan_unsigned(const char **bufp, unsigned *out, int width, int base)$/;"	f	file:
schedule	or/or.h	/^  download_schedule_t schedule : 8;$/;"	m	struct:download_status_t
search_domain	or/eventdns.c	/^struct search_domain {$/;"	s	file:
search_flags	or/eventdns.c	/^	int search_flags;$/;"	m	struct:evdns_request	file:
search_index	or/eventdns.c	/^	int search_index;$/;"	m	struct:evdns_request	file:
search_make_new	or/eventdns.c	/^search_make_new(const struct search_state *const state, int n, const char *const base_name) {$/;"	f	file:
search_origname	or/eventdns.c	/^	char *search_origname;	\/* needs to be mm_free()ed *\/$/;"	m	struct:evdns_request	file:
search_postfix_add	or/eventdns.c	/^search_postfix_add(const char *domain) {$/;"	f	file:
search_postfix_clear	or/eventdns.c	/^search_postfix_clear(void) {$/;"	f	file:
search_request_finished	or/eventdns.c	/^search_request_finished(struct evdns_request *const req) {$/;"	f	file:
search_request_new	or/eventdns.c	/^search_request_new(int type, const char *const name, int flags, evdns_callback_type user_callback, void *user_arg) {$/;"	f	file:
search_reverse	or/eventdns.c	/^search_reverse(void) {$/;"	f	file:
search_set_from_hostname	or/eventdns.c	/^search_set_from_hostname(void) {$/;"	f	file:
search_state	or/eventdns.c	/^	struct search_state *search_state;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::search_state	file:
search_state	or/eventdns.c	/^struct search_state {$/;"	s	file:
search_state_decref	or/eventdns.c	/^search_state_decref(struct search_state *const state) {$/;"	f	file:
search_state_new	or/eventdns.c	/^search_state_new(void) {$/;"	f	file:
search_try_next	or/eventdns.c	/^search_try_next(struct evdns_request *const req) {$/;"	f	file:
second	or/or.h	/^  char second[DIGEST_LEN];$/;"	m	struct:__anon57
second_elapsed_callback	or/main.c	/^second_elapsed_callback(periodic_timer_t *timer, void *arg)$/;"	f	file:
second_timer	or/main.c	/^static periodic_timer_t *second_timer = NULL;$/;"	v	file:
secret_to_key	common/crypto.c	/^secret_to_key(char *key_out, size_t key_out_len, const char *secret,$/;"	f
secs_to_uptime	or/status.c	/^secs_to_uptime(long secs)$/;"	f	file:
seed_weak_rng	common/crypto.c	/^seed_weak_rng(void)$/;"	f	file:
seems_dead	common/log.c	/^  int seems_dead; \/**< Boolean: true if the stream seems to be kaput. *\/$/;"	m	struct:logfile_t	file:
send_control_done	or/control.c	/^send_control_done(control_connection_t *conn)$/;"	f	file:
send_control_event	or/control.c	/^send_control_event(uint16_t event, event_format_t which,$/;"	f	file:
send_control_event_impl	or/control.c	/^send_control_event_impl(uint16_t event, event_format_t which,$/;"	f	file:
send_control_event_string	or/control.c	/^send_control_event_string(uint16_t event, event_format_t which,$/;"	f	file:
send_resolved_cell	or/dns.c	/^send_resolved_cell(edge_connection_t *conn, uint8_t answer_type)$/;"	f	file:
send_resolved_hostname_cell	or/dns.c	/^send_resolved_hostname_cell(edge_connection_t *conn, const char *hostname)$/;"	f	file:
send_unencrypted	or/or.h	/^  unsigned int send_unencrypted : 1;$/;"	m	struct:signed_descriptor_t
sending_optimistic_data	or/or.h	/^  generic_buffer_t *sending_optimistic_data;$/;"	m	struct:entry_connection_t
sent_versions_at	or/or.h	/^  time_t sent_versions_at;$/;"	m	struct:or_handshake_state_t
served_descs	or/rephist.c	/^static digestmap_t *served_descs = NULL;$/;"	v	file:
server_consensus_dl_schedule	or/directory.c	/^static const int server_consensus_dl_schedule[] = {$/;"	v	file:
server_dl_schedule	or/directory.c	/^static const int server_dl_schedule[] = {$/;"	v	file:
server_handshake_count	common/tortls.c	/^  uint8_t server_handshake_count;$/;"	m	struct:tor_tls_t	file:
server_head	or/eventdns.c	/^static struct nameserver *server_head = NULL;$/;"	v	typeref:struct:nameserver	file:
server_identity_key_is_set	or/router.c	/^server_identity_key_is_set(void)$/;"	f
server_identitykey	or/router.c	/^static crypto_pk_t *server_identitykey=NULL;$/;"	v	file:
server_identitykey_digest	or/router.c	/^static char server_identitykey_digest[DIGEST_LEN];$/;"	v	file:
server_is_advertised	or/router.c	/^static int server_is_advertised=0;$/;"	v	file:
server_mode	or/router.c	/^server_mode(const or_options_t *options)$/;"	f
server_port_flush	or/eventdns.c	/^server_port_flush(struct evdns_server_port *port)$/;"	f	file:
server_port_free	or/eventdns.c	/^server_port_free(struct evdns_server_port *port)$/;"	f	file:
server_port_read	or/eventdns.c	/^server_port_read(struct evdns_server_port *s) {$/;"	f	file:
server_port_ready_callback	or/eventdns.c	/^server_port_ready_callback(int fd, short events, void *arg) {$/;"	f	file:
server_reply_item	or/eventdns.c	/^struct server_reply_item {$/;"	s	file:
server_request	or/eventdns.c	/^struct server_request {$/;"	s	file:
server_request_free	or/eventdns.c	/^server_request_free(struct server_request *req)$/;"	f	file:
server_request_free_answers	or/eventdns.c	/^server_request_free_answers(struct server_request *req)$/;"	f	file:
server_tls_context	common/tortls.c	/^static tor_tls_context_t *server_tls_context = NULL;$/;"	v	file:
server_versions	or/or.h	/^  char *server_versions; \/**< comma-separated list of recommended server$/;"	m	struct:networkstatus_v2_t
server_versions	or/or.h	/^  char *server_versions;$/;"	m	struct:networkstatus_t
service_fns	or/ntmain.c	/^struct service_fns {$/;"	s	file:
service_fns	or/ntmain.c	/^} service_fns = { 0,$/;"	v	typeref:struct:service_fns
service_id	or/rendservice.c	/^  char service_id[REND_SERVICE_ID_LEN_BASE32+1]; \/**< Onion address without$/;"	m	struct:rend_service_t	file:
service_pending_final_cpath_ref	or/or.h	/^  crypt_path_reference_t *service_pending_final_cpath_ref;$/;"	m	struct:__anon47
service_status	or/ntmain.c	/^static SERVICE_STATUS service_status;$/;"	v	file:
session_group	or/or.h	/^  int session_group; \/**< A session group, or -1 if this port is not in a$/;"	m	struct:port_cfg_t
session_group	or/or.h	/^  int session_group;$/;"	m	struct:entry_connection_t
session_group	or/or.h	/^  int session_group;$/;"	m	struct:listener_connection_t
session_group	or/or.h	/^  int session_group;$/;"	m	struct:origin_circuit_t
set_at	or/networkstatus.c	/^  time_t set_at;$/;"	m	struct:consensus_waiting_for_certs_t	file:
set_buffer_lengths_to_zero	or/main.c	/^set_buffer_lengths_to_zero(tor_socket_t s)$/;"	f	file:
set_cached_dir	or/dirserv.c	/^set_cached_dir(cached_dir_t *d, char *directory, time_t when)$/;"	f	file:
set_client_identity_key	or/router.c	/^set_client_identity_key(crypto_pk_t *k)$/;"	f
set_constrained_socket_buffers	or/connection.c	/^set_constrained_socket_buffers(tor_socket_t sock, int size)$/;"	f	file:
set_environment_variable_in_smartlist	common/util.c	/^set_environment_variable_in_smartlist(struct smartlist_t *env_vars,$/;"	f
set_expiry	or/dns.c	/^set_expiry(cached_resolve_t *resolve, time_t expires)$/;"	f	file:
set_log_severity_config	common/log.c	/^set_log_severity_config(int loglevelMin, int loglevelMax,$/;"	f
set_log_time_granularity	common/log.c	/^set_log_time_granularity(int granularity_msec)$/;"	f
set_main_thread	common/compat.c	/^set_main_thread(void)$/;"	f
set_max_file_descriptors	common/compat.c	/^set_max_file_descriptors(rlim_t limit, int *max_out)$/;"	f
set_onion_key	or/router.c	/^set_onion_key(crypto_pk_t *k)$/;"	f	file:
set_options	or/config.c	/^set_options(or_options_t *new_val, char **msg)$/;"	f
set_routerstatus_from_routerinfo	or/dirserv.c	/^set_routerstatus_from_routerinfo(routerstatus_t *rs,$/;"	f
set_server_advertised	or/router.c	/^set_server_advertised(int s)$/;"	f	file:
set_server_identity_key	or/router.c	/^set_server_identity_key(crypto_pk_t *k)$/;"	f
set_socket_nonblocking	common/compat.c	/^set_socket_nonblocking(tor_socket_t socket)$/;"	f
set_streams_blocked_on_circ	or/relay.c	/^set_streams_blocked_on_circ(circuit_t *circ, or_connection_t *orconn,$/;"	f	file:
set_uint16	common/compat.c	/^set_uint16(void *cp, uint16_t v)$/;"	f
set_uint32	common/compat.c	/^set_uint32(void *cp, uint32_t v)$/;"	f
set_uint64	common/compat.c	/^set_uint64(void *cp, uint64_t v)$/;"	f
set_uint8	common/compat.h	/^set_uint8(void *cp, uint8_t v)$/;"	f
setopt_err_t	or/or.h	/^typedef enum setopt_err_t {$/;"	g
setopt_err_t	or/or.h	/^} setopt_err_t;$/;"	t	typeref:enum:setopt_err_t
setup	test/tinytest.h	/^	const struct testcase_setup_t *setup; \/**< Optional setup\/cleanup fns*\/$/;"	m	struct:testcase_t	typeref:struct:testcase_t::testcase_setup_t
setup_data	test/tinytest.h	/^	void *setup_data; \/**< Extra data usable by setup function *\/$/;"	m	struct:testcase_t
setup_data_buffer	test/tinytest_demo.c	/^setup_data_buffer(const struct testcase_t *testcase)$/;"	f
setup_directory	test/test.c	/^setup_directory(void)$/;"	f	file:
setup_fn	test/tinytest.h	/^	void *(*setup_fn)(const struct testcase_t *);$/;"	m	struct:testcase_setup_t
setup_openssl_threading	common/crypto.c	/^setup_openssl_threading(void)$/;"	f	file:
sev_to_string	common/log.c	/^sev_to_string(int severity)$/;"	f	file:
severities	common/log.c	/^  log_severity_list_t *severities; \/**< Which severity of messages should we$/;"	m	struct:logfile_t	file:
severity	common/log.c	/^  int severity; \/**< The severity of the message *\/$/;"	m	struct:pending_cb_message_t	file:
sha1	common/crypto.c	/^    SHA_CTX sha1; \/**< state for SHA1 *\/$/;"	m	union:crypto_digest_t::__anon9	file:
sha2	common/crypto.c	/^    SHA256_CTX sha2; \/**< state for SHA256 *\/$/;"	m	union:crypto_digest_t::__anon9	file:
sha256_compress	common/sha256.c	/^static int sha256_compress(sha256_state * md, unsigned char *buf)$/;"	f	file:
sha256_done	common/sha256.c	/^static int sha256_done(sha256_state * md, unsigned char *out)$/;"	f	file:
sha256_init	common/sha256.c	/^static int sha256_init(sha256_state * md)$/;"	f	file:
sha256_process	common/sha256.c	/^static int sha256_process (sha256_state * md, const unsigned char *in, unsigned long inlen)$/;"	f	file:
sha256_state	common/sha256.c	/^typedef struct sha256_state {$/;"	s	file:
sha256_state	common/sha256.c	/^} sha256_state;$/;"	t	typeref:struct:sha256_state	file:
share_seconds	or/geoip.c	/^static int share_seconds;$/;"	v	file:
shift	common/OpenBSD_malloc_Linux.c	/^	u_short		shift;	\/* How far to shift for this size chunks *\/$/;"	m	struct:pginfo	file:
short_policy_entry_t	or/or.h	/^typedef struct short_policy_entry_t {$/;"	s
short_policy_entry_t	or/or.h	/^} short_policy_entry_t;$/;"	t	typeref:struct:short_policy_entry_t
short_policy_free	or/policies.c	/^short_policy_free(short_policy_t *policy)$/;"	f
short_policy_is_reject_star	or/policies.c	/^short_policy_is_reject_star(const short_policy_t *policy)$/;"	f
short_policy_t	or/or.h	/^typedef struct short_policy_t {$/;"	s
short_policy_t	or/or.h	/^} short_policy_t;$/;"	t	typeref:struct:short_policy_t
should_add_entry_nodes	or/circuitbuild.c	/^static int should_add_entry_nodes = 0;$/;"	v	file:
should_cache_old_descriptors	or/routerlist.c	/^#define should_cache_old_descriptors(/;"	d	file:
should_delay_dir_fetches	or/networkstatus.c	/^should_delay_dir_fetches(const or_options_t *options)$/;"	f
should_generate_v2_networkstatus	or/dirserv.c	/^should_generate_v2_networkstatus(void)$/;"	f	file:
should_log_function_name	common/log.c	/^should_log_function_name(log_domain_mask_t domain, int severity)$/;"	f	file:
should_rebuild_md_cache	or/microdesc.c	/^should_rebuild_md_cache(microdesc_cache_t *cache)$/;"	f	file:
should_record_bridge_info	or/geoip.c	/^should_record_bridge_info(const or_options_t *options)$/;"	f
should_refuse_unknown_exits	or/router.c	/^should_refuse_unknown_exits(const or_options_t *options)$/;"	f
should_use_EVP	common/aes.c	/^static int should_use_EVP = 0;$/;"	v	file:
should_use_create_fast_for_circuit	or/circuitbuild.c	/^should_use_create_fast_for_circuit(origin_circuit_t *circ)$/;"	f	file:
should_use_openssl_CTR	common/aes.c	/^static int should_use_openssl_CTR = 0;$/;"	v	file:
show_help	tools/tor-gencert.c	/^show_help(void)$/;"	f	file:
shutdown_time	or/hibernate.c	/^static time_t shutdown_time = 0;$/;"	v	file:
signal_callback	or/main.c	/^signal_callback(int fd, short events, void *arg)$/;"	f	file:
signature	or/or.h	/^  char *signature;$/;"	m	struct:document_signature_t
signature_len	or/or.h	/^  int signature_len;$/;"	m	struct:document_signature_t
signatures	or/or.h	/^  strmap_t *signatures; \/**< Map from flavor name to list of$/;"	m	struct:ns_detached_signatures_t
signed_desc_append_to_journal	or/routerlist.c	/^signed_desc_append_to_journal(signed_descriptor_t *desc,$/;"	f	file:
signed_desc_digest_is_recognized	or/routerlist.c	/^signed_desc_digest_is_recognized(signed_descriptor_t *desc)$/;"	f	file:
signed_descriptor_body	or/or.h	/^  char *signed_descriptor_body;$/;"	m	struct:signed_descriptor_t
signed_descriptor_digest	or/or.h	/^  char signed_descriptor_digest[DIGEST_LEN];$/;"	m	struct:signed_descriptor_t
signed_descriptor_free	or/routerlist.c	/^signed_descriptor_free(signed_descriptor_t *sd)$/;"	f	file:
signed_descriptor_from_routerinfo	or/routerlist.c	/^signed_descriptor_from_routerinfo(routerinfo_t *ri)$/;"	f	file:
signed_descriptor_get_annotations	or/routerlist.c	/^signed_descriptor_get_annotations(const signed_descriptor_t *desc)$/;"	f
signed_descriptor_get_body	or/routerlist.c	/^signed_descriptor_get_body(const signed_descriptor_t *desc)$/;"	f
signed_descriptor_get_body_impl	or/routerlist.c	/^signed_descriptor_get_body_impl(const signed_descriptor_t *desc,$/;"	f	file:
signed_descriptor_len	or/or.h	/^  size_t signed_descriptor_len;$/;"	m	struct:signed_descriptor_t
signed_descriptor_t	or/or.h	/^typedef struct signed_descriptor_t {$/;"	s
signed_descriptor_t	or/or.h	/^} signed_descriptor_t;$/;"	t	typeref:struct:signed_descriptor_t
signed_descs_update_status_from_consensus_networkstatus	or/networkstatus.c	/^signed_descs_update_status_from_consensus_networkstatus(smartlist_t *descs)$/;"	f
signewnym_impl	or/main.c	/^signewnym_impl(time_t now)$/;"	f	file:
signewnym_is_pending	or/main.c	/^static int signewnym_is_pending = 0;$/;"	v	file:
signing_key	or/or.h	/^  crypto_pk_t *signing_key; \/**< Key used to sign this directory. *\/$/;"	m	struct:networkstatus_v2_t
signing_key	or/or.h	/^  crypto_pk_t *signing_key;$/;"	m	struct:authority_cert_t
signing_key	tools/tor-gencert.c	/^EVP_PKEY *signing_key = NULL;$/;"	v
signing_key_digest	or/or.h	/^  char signing_key_digest[DIGEST_LEN];$/;"	m	struct:authority_cert_t
signing_key_digest	or/or.h	/^  char signing_key_digest[DIGEST_LEN];$/;"	m	struct:document_signature_t
signing_key_file	tools/tor-gencert.c	/^char *signing_key_file = NULL;$/;"	v
sigs	or/or.h	/^  smartlist_t *sigs;$/;"	m	struct:networkstatus_voter_info_t
sin6_addr	common/compat.h	/^  struct in6_addr sin6_addr;$/;"	m	struct:sockaddr_in6	typeref:struct:sockaddr_in6::in6_addr
sin6_family	common/compat.h	/^  sa_family_t sin6_family;$/;"	m	struct:sockaddr_in6
sin6_port	common/compat.h	/^  uint16_t sin6_port;$/;"	m	struct:sockaddr_in6
since	or/rephist.c	/^  time_t since;$/;"	m	struct:link_history_t	file:
since	or/rephist.c	/^  time_t since;$/;"	m	struct:or_history_t	file:
size	common/OpenBSD_malloc_Linux.c	/^	size_t		size;	\/* number of bytes free *\/$/;"	m	struct:pgfree	file:
size	common/OpenBSD_malloc_Linux.c	/^	u_short		size;	\/* size of this page's chunks *\/$/;"	m	struct:pginfo	file:
size	common/compat.h	/^  size_t size; \/**< Size of the file. *\/$/;"	m	struct:tor_mmap_t
size	or/config.c	/^  size_t size; \/**< Size of the struct that everything gets parsed into. *\/$/;"	m	struct:__anon21	file:
sized_chunk_t	common/util.h	/^typedef struct sized_chunk_t {$/;"	s
sized_chunk_t	common/util.h	/^} sized_chunk_t;$/;"	t	typeref:struct:sized_chunk_t
sl_last_total_weighted_bw	or/routerlist.c	/^static uint64_t sl_last_total_weighted_bw = 0,$/;"	v	file:
sl_last_weighted_bw_of_me	or/routerlist.c	/^  sl_last_weighted_bw_of_me = 0;$/;"	v	file:
slack	or/buffers.c	/^  int slack; \/**< When trimming the freelist, leave this number of extra$/;"	m	struct:chunk_freelist_t	file:
smartlist_add	common/container.c	/^smartlist_add(smartlist_t *sl, void *element)$/;"	f
smartlist_add_all	common/container.c	/^smartlist_add_all(smartlist_t *s1, const smartlist_t *s2)$/;"	f
smartlist_add_asprintf	common/util.c	/^smartlist_add_asprintf(struct smartlist_t *sl, const char *pattern, ...)$/;"	f
smartlist_add_vasprintf	common/util.c	/^smartlist_add_vasprintf(struct smartlist_t *sl, const char *pattern,$/;"	f
smartlist_bsearch	common/container.c	/^smartlist_bsearch(smartlist_t *sl, const void *key,$/;"	f
smartlist_bsearch_idx	common/container.c	/^smartlist_bsearch_idx(const smartlist_t *sl, const void *key,$/;"	f
smartlist_choose	common/crypto.c	/^smartlist_choose(const smartlist_t *sl)$/;"	f
smartlist_choose_node_by_bandwidth	or/routerlist.c	/^smartlist_choose_node_by_bandwidth(smartlist_t *sl,$/;"	f	file:
smartlist_choose_node_by_bandwidth_weights	or/routerlist.c	/^smartlist_choose_node_by_bandwidth_weights(smartlist_t *sl,$/;"	f	file:
smartlist_clear	common/container.c	/^smartlist_clear(smartlist_t *sl)$/;"	f
smartlist_del	common/container.c	/^smartlist_del(smartlist_t *sl, int idx)$/;"	f
smartlist_del_keeporder	common/container.c	/^smartlist_del_keeporder(smartlist_t *sl, int idx)$/;"	f
smartlist_digest_isin	common/container.c	/^smartlist_digest_isin(const smartlist_t *sl, const char *element)$/;"	f
smartlist_ensure_capacity	common/container.c	/^smartlist_ensure_capacity(smartlist_t *sl, int size)$/;"	f	file:
smartlist_free	common/container.c	/^smartlist_free(smartlist_t *sl)$/;"	f
smartlist_get	common/container.h	/^#define smartlist_get(/;"	d
smartlist_get	common/container.h	/^static INLINE void *smartlist_get(const smartlist_t *sl, int idx) {$/;"	f
smartlist_get_most_frequent	common/container.c	/^smartlist_get_most_frequent(const smartlist_t *sl,$/;"	f
smartlist_get_most_frequent_digest256	common/container.c	/^smartlist_get_most_frequent_digest256(smartlist_t *sl)$/;"	f
smartlist_get_most_frequent_string	common/container.c	/^smartlist_get_most_frequent_string(smartlist_t *sl)$/;"	f
smartlist_heapify	common/container.c	/^smartlist_heapify(smartlist_t *sl,$/;"	f	file:
smartlist_insert	common/container.c	/^smartlist_insert(smartlist_t *sl, int idx, void *val)$/;"	f
smartlist_intersect	common/container.c	/^smartlist_intersect(smartlist_t *sl1, const smartlist_t *sl2)$/;"	f
smartlist_isin	common/container.c	/^smartlist_isin(const smartlist_t *sl, const void *element)$/;"	f
smartlist_join_strings	common/container.c	/^smartlist_join_strings(smartlist_t *sl, const char *join,$/;"	f
smartlist_join_strings2	common/container.c	/^smartlist_join_strings2(smartlist_t *sl, const char *join,$/;"	f
smartlist_len	common/container.h	/^#define smartlist_len(/;"	d
smartlist_len	common/container.h	/^static INLINE int smartlist_len(const smartlist_t *sl) {$/;"	f
smartlist_new	common/container.c	/^smartlist_new(void)$/;"	f
smartlist_new_from_text_lines	test/test_util.c	/^smartlist_new_from_text_lines(const char *lines)$/;"	f	file:
smartlist_overlap	common/container.c	/^smartlist_overlap(const smartlist_t *sl1, const smartlist_t *sl2)$/;"	f
smartlist_pop_last	common/container.c	/^smartlist_pop_last(smartlist_t *sl)$/;"	f
smartlist_pqueue_add	common/container.c	/^smartlist_pqueue_add(smartlist_t *sl,$/;"	f
smartlist_pqueue_assert_ok	common/container.c	/^smartlist_pqueue_assert_ok(smartlist_t *sl,$/;"	f
smartlist_pqueue_pop	common/container.c	/^smartlist_pqueue_pop(smartlist_t *sl,$/;"	f
smartlist_pqueue_remove	common/container.c	/^smartlist_pqueue_remove(smartlist_t *sl,$/;"	f
smartlist_remove	common/container.c	/^smartlist_remove(smartlist_t *sl, const void *element)$/;"	f
smartlist_reverse	common/container.c	/^smartlist_reverse(smartlist_t *sl)$/;"	f
smartlist_set	common/container.h	/^#define smartlist_set(/;"	d
smartlist_set	common/container.h	/^static INLINE void smartlist_set(smartlist_t *sl, int idx, void *val) {$/;"	f
smartlist_shuffle	common/crypto.c	/^smartlist_shuffle(smartlist_t *sl)$/;"	f
smartlist_sort	common/container.c	/^smartlist_sort(smartlist_t *sl, int (*compare)(const void **a, const void **b))$/;"	f
smartlist_sort_digests	common/container.c	/^smartlist_sort_digests(smartlist_t *sl)$/;"	f
smartlist_sort_digests256	common/container.c	/^smartlist_sort_digests256(smartlist_t *sl)$/;"	f
smartlist_sort_strings	common/container.c	/^smartlist_sort_strings(smartlist_t *sl)$/;"	f
smartlist_split_string	common/container.c	/^smartlist_split_string(smartlist_t *sl, const char *str, const char *sep,$/;"	f
smartlist_string_isin	common/container.c	/^smartlist_string_isin(const smartlist_t *sl, const char *element)$/;"	f
smartlist_string_isin_case	common/container.c	/^smartlist_string_isin_case(const smartlist_t *sl, const char *element)$/;"	f
smartlist_string_num_isin	common/container.c	/^smartlist_string_num_isin(const smartlist_t *sl, int num)$/;"	f
smartlist_string_pos	common/container.c	/^smartlist_string_pos(const smartlist_t *sl, const char *element)$/;"	f
smartlist_string_remove	common/container.c	/^smartlist_string_remove(smartlist_t *sl, const char *element)$/;"	f
smartlist_strings_eq	common/container.c	/^smartlist_strings_eq(const smartlist_t *sl1, const smartlist_t *sl2)$/;"	f
smartlist_subtract	common/container.c	/^smartlist_subtract(smartlist_t *sl1, const smartlist_t *sl2)$/;"	f
smartlist_swap	common/container.h	/^static INLINE void smartlist_swap(smartlist_t *sl, int idx1, int idx2)$/;"	f
smartlist_t	common/container.h	/^typedef struct smartlist_t {$/;"	s
smartlist_t	common/container.h	/^} smartlist_t;$/;"	t	typeref:struct:smartlist_t
smartlist_uniq	common/container.c	/^smartlist_uniq(smartlist_t *sl,$/;"	f
smartlist_uniq_digests	common/container.c	/^smartlist_uniq_digests(smartlist_t *sl)$/;"	f
smartlist_uniq_digests256	common/container.c	/^smartlist_uniq_digests256(smartlist_t *sl)$/;"	f
smartlist_uniq_strings	common/container.c	/^smartlist_uniq_strings(smartlist_t *sl)$/;"	f
snprintf	common/compat.h	/^#define snprintf /;"	d
snprintf	or/or.h	/^#define snprintf /;"	d
sockaddr_eq	or/eventdns.c	/^sockaddr_eq(const struct sockaddr *sa1, const struct sockaddr *sa2,$/;"	f	file:
sockaddr_in6	common/compat.h	/^struct sockaddr_in6 {$/;"	s
sockaddr_is_loopback	or/eventdns.c	/^sockaddr_is_loopback(const struct sockaddr *addr)$/;"	f	file:
socket	common/tortls.c	/^  int socket; \/**< The underlying file descriptor for this TLS connection. *\/$/;"	m	struct:tor_tls_t	file:
socket	or/eventdns.c	/^	int socket;	 \/* a connected UDP socket *\/$/;"	m	struct:nameserver	file:
socket	or/eventdns.c	/^	int socket; \/* socket we use to read queries and write replies. *\/$/;"	m	struct:evdns_server_port	file:
socket_accounting_lock	common/compat.c	/^socket_accounting_lock(void)$/;"	f	file:
socket_accounting_mutex	common/compat.c	/^static tor_mutex_t *socket_accounting_mutex = NULL;$/;"	v	file:
socket_accounting_unlock	common/compat.c	/^socket_accounting_unlock(void)$/;"	f	file:
socket_family	or/or.h	/^  int socket_family; \/**< Address family of this connection's socket.  Usually$/;"	m	struct:connection_t
socklen_t	common/compat.h	/^typedef int socklen_t;$/;"	t
socklen_t	or/eventdns.c	/^typedef int socklen_t;$/;"	t	file:
socks4_response_code_to_string	or/reasons.c	/^socks4_response_code_to_string(uint8_t code)$/;"	f
socks5_reason_to_string	tools/tor-resolve.c	/^socks5_reason_to_string(char reason)$/;"	f	file:
socks5_reply_status_t	common/compat.h	/^} socks5_reply_status_t;$/;"	t	typeref:enum:__anon7
socks5_response_code_to_string	or/reasons.c	/^socks5_response_code_to_string(uint8_t code)$/;"	f
socks_password	or/or.h	/^  char *socks_password;$/;"	m	struct:origin_circuit_t
socks_password_len	or/or.h	/^  uint8_t socks_password_len;$/;"	m	struct:origin_circuit_t
socks_policy	or/policies.c	/^static smartlist_t *socks_policy = NULL;$/;"	v	file:
socks_policy_permits_address	or/policies.c	/^socks_policy_permits_address(const tor_addr_t *addr)$/;"	f
socks_request	or/or.h	/^  socks_request_t *socks_request; \/**< SOCKS structure describing request (AP$/;"	m	struct:entry_connection_t
socks_request_clear	test/test.c	/^socks_request_clear(socks_request_t *socks)$/;"	f	file:
socks_request_free	or/buffers.c	/^socks_request_free(socks_request_t *req)$/;"	f
socks_request_new	or/buffers.c	/^socks_request_new(void)$/;"	f
socks_request_t	or/or.h	/^struct socks_request_t {$/;"	s
socks_request_t	or/or.h	/^typedef struct socks_request_t socks_request_t;$/;"	t	typeref:struct:socks_request_t
socks_setup	test/test.c	/^const struct testcase_setup_t socks_setup = {$/;"	v	typeref:struct:testcase_setup_t
socks_test_cleanup	test/test.c	/^socks_test_cleanup(const struct testcase_t *testcase, void *ptr)$/;"	f	file:
socks_test_data_t	test/test.c	/^typedef struct socks_test_data_t {$/;"	s	file:
socks_test_data_t	test/test.c	/^} socks_test_data_t;$/;"	t	typeref:struct:socks_test_data_t	file:
socks_test_setup	test/test.c	/^socks_test_setup(const struct testcase_t *testcase)$/;"	f	file:
socks_tests	test/test.c	/^static struct testcase_t socks_tests[] = {$/;"	v	typeref:struct:testcase_t	file:
socks_username	or/or.h	/^  char *socks_username;$/;"	m	struct:origin_circuit_t
socks_username_len	or/or.h	/^  size_t socks_username_len;$/;"	m	struct:origin_circuit_t
socks_version	or/circuitbuild.h	/^  int socks_version;$/;"	m	struct:__anon20
socks_version	or/or.h	/^  uint8_t socks_version;$/;"	m	struct:socks_request_t
soft_limit_hit_at	or/hibernate.c	/^static time_t soft_limit_hit_at = 0;$/;"	v	file:
sort_version_list	or/routerparse.c	/^sort_version_list(smartlist_t *versions, int remove_duplicates)$/;"	f
source	or/connection_edge.c	/^  addressmap_entry_source_t source:3;$/;"	m	struct:__anon22	file:
source_addr	or/or.h	/^  uint32_t source_addr; \/**< Canonical directory server IP. *\/$/;"	m	struct:networkstatus_v2_t
source_address	or/or.h	/^  char *source_address; \/**< Canonical directory server hostname. *\/$/;"	m	struct:networkstatus_v2_t
source_dirport	or/or.h	/^  uint16_t source_dirport; \/**< Canonical directory server dirport. *\/$/;"	m	struct:networkstatus_v2_t
spawn_cpuworker	or/cpuworker.c	/^spawn_cpuworker(void)$/;"	f	file:
spawn_enough_cpuworkers	or/cpuworker.c	/^spawn_enough_cpuworkers(void)$/;"	f	file:
spawn_exit	common/compat.c	/^spawn_exit(void)$/;"	f
spawn_func	common/compat.c	/^spawn_func(void (*func)(void *), void *data)$/;"	f
split_line	test/test_util.c	/^  const char *split_line[MAX_SPLIT_LINE_COUNT]; \/\/ Split lines$/;"	m	struct:split_lines_test_t	file:
split_lines_test_t	test/test_util.c	/^struct split_lines_test_t {$/;"	s	file:
src_wildcard	or/connection_edge.c	/^  unsigned src_wildcard:1;$/;"	m	struct:__anon22	file:
ssize_t	common/torint.h	/^typedef int32_t ssize_t;$/;"	t
ssize_t	common/torint.h	/^typedef int64_t ssize_t;$/;"	t
ssl	common/tortls.c	/^  SSL *ssl; \/**< An OpenSSL SSL object. *\/$/;"	m	struct:tor_tls_t	file:
stability_last_downrated	or/rephist.c	/^static time_t stability_last_downrated = 0;$/;"	v	file:
stable_mtbf	or/dirserv.c	/^static double stable_mtbf = 0.0;$/;"	v	file:
stable_uptime	or/dirserv.c	/^static uint32_t stable_uptime = 0; \/* start at a safe value *\/$/;"	v	file:
start_daemon	common/util.c	/^start_daemon(void)$/;"	f
start_daemon_called	common/util.c	/^static int start_daemon_called = 0;$/;"	v	file:
start_of_accounting_period_after	or/hibernate.c	/^start_of_accounting_period_after(time_t now)$/;"	f	file:
start_of_accounting_period_containing	or/hibernate.c	/^start_of_accounting_period_containing(time_t now)$/;"	f	file:
start_of_bridge_stats_interval	or/geoip.c	/^static time_t start_of_bridge_stats_interval;$/;"	v	file:
start_of_buffer_stats_interval	or/rephist.c	/^static time_t start_of_buffer_stats_interval;$/;"	v	file:
start_of_conn_stats_interval	or/rephist.c	/^static time_t start_of_conn_stats_interval;$/;"	v	file:
start_of_dirreq_stats_interval	or/geoip.c	/^static time_t start_of_dirreq_stats_interval;$/;"	v	file:
start_of_downtime	or/rephist.c	/^  time_t start_of_downtime;$/;"	m	struct:or_history_t	file:
start_of_entry_stats_interval	or/geoip.c	/^static time_t start_of_entry_stats_interval;$/;"	v	file:
start_of_exit_stats_interval	or/rephist.c	/^static time_t start_of_exit_stats_interval;$/;"	v	file:
start_of_run	or/rephist.c	/^  time_t start_of_run;$/;"	m	struct:or_history_t	file:
start_of_served_descs_stats_interval	or/rephist.c	/^static time_t start_of_served_descs_stats_interval;$/;"	v	file:
start_writing_to_file	common/util.c	/^start_writing_to_file(const char *fname, int open_flags, int mode,$/;"	f
start_writing_to_stdio_file	common/util.c	/^start_writing_to_stdio_file(const char *fname, int open_flags, int mode,$/;"	f
started_here	or/or.h	/^  unsigned int started_here : 1;$/;"	m	struct:or_handshake_state_t
started_tracking_stability	or/rephist.c	/^static time_t started_tracking_stability = 0;$/;"	v	file:
state	common/sha256.c	/^    uint32_t state[8], curlen;$/;"	m	struct:sha256_state	file:
state	common/tortls.c	/^  } state : 3; \/**< The current SSL state, depending on which operations have$/;"	m	struct:tor_tls_t	typeref:enum:tor_tls_t::__anon16	file:
state	or/connection_or.c	/^  const char *state;$/;"	m	struct:broken_state_count_t	file:
state	or/dns.c	/^  uint8_t state; \/**< Is this cached entry pending\/done\/valid\/failed? *\/$/;"	m	struct:cached_resolve_t	file:
state	or/eventdns.c	/^	char state;	 \/* zero if we think that this server is down *\/$/;"	m	struct:nameserver	file:
state	or/geoip.c	/^  unsigned int state:3; \/**< State of this directory request. *\/$/;"	m	struct:dirreq_map_entry_t	file:
state	or/or.h	/^  uint8_t state; \/**< Current state of this connection. *\/$/;"	m	struct:connection_t
state	or/or.h	/^  uint8_t state; \/**< Current status of this circuit. *\/$/;"	m	struct:circuit_t
state	or/or.h	/^  uint8_t state;$/;"	m	struct:crypt_path_t
state_extra_var	or/config.c	/^static config_var_t state_extra_var = {$/;"	v	file:
state_format	or/config.c	/^static const config_format_t state_format = {$/;"	v	file:
state_len	tools/tor-fw-helper/tor-fw-helper.h	/^  size_t state_len;$/;"	m	struct:tor_fw_backend_t
state_transport_line_is_valid	or/config.c	/^state_transport_line_is_valid(const char *line)$/;"	f	file:
stats_n_auth_challenge_cells_processed	or/command.c	/^uint64_t stats_n_auth_challenge_cells_processed = 0;$/;"	v
stats_n_authenticate_cells_processed	or/command.c	/^uint64_t stats_n_authenticate_cells_processed = 0;$/;"	v
stats_n_authorize_cells_processed	or/command.c	/^uint64_t stats_n_authorize_cells_processed = 0;$/;"	v
stats_n_bytes_read	or/main.c	/^static uint64_t stats_n_bytes_read = 0;$/;"	v	file:
stats_n_bytes_written	or/main.c	/^static uint64_t stats_n_bytes_written = 0;$/;"	v	file:
stats_n_certs_cells_processed	or/command.c	/^uint64_t stats_n_certs_cells_processed = 0;$/;"	v
stats_n_create_cells_processed	or/command.c	/^uint64_t stats_n_create_cells_processed = 0;$/;"	v
stats_n_created_cells_processed	or/command.c	/^uint64_t stats_n_created_cells_processed = 0;$/;"	v
stats_n_data_bytes_packaged	or/relay.c	/^uint64_t stats_n_data_bytes_packaged = 0;$/;"	v
stats_n_data_bytes_received	or/relay.c	/^uint64_t stats_n_data_bytes_received = 0;$/;"	v
stats_n_data_cells_packaged	or/relay.c	/^uint64_t stats_n_data_cells_packaged = 0;$/;"	v
stats_n_data_cells_received	or/relay.c	/^uint64_t stats_n_data_cells_received = 0;$/;"	v
stats_n_destroy_cells_processed	or/command.c	/^uint64_t stats_n_destroy_cells_processed = 0;$/;"	v
stats_n_netinfo_cells_processed	or/command.c	/^uint64_t stats_n_netinfo_cells_processed = 0;$/;"	v
stats_n_padding_cells_processed	or/command.c	/^uint64_t stats_n_padding_cells_processed = 0;$/;"	v
stats_n_relay_cells_delivered	or/relay.c	/^uint64_t stats_n_relay_cells_delivered = 0;$/;"	v
stats_n_relay_cells_processed	or/command.c	/^uint64_t stats_n_relay_cells_processed = 0;$/;"	v
stats_n_relay_cells_relayed	or/relay.c	/^uint64_t stats_n_relay_cells_relayed = 0;$/;"	v
stats_n_seconds_working	or/main.c	/^long stats_n_seconds_working = 0;$/;"	v
stats_n_versions_cells_processed	or/command.c	/^uint64_t stats_n_versions_cells_processed = 0;$/;"	v
stats_n_vpadding_cells_processed	or/command.c	/^uint64_t stats_n_vpadding_cells_processed = 0;$/;"	v
stats_prev_global_read_bucket	or/main.c	/^static int stats_prev_global_read_bucket;$/;"	v	file:
stats_prev_global_write_bucket	or/main.c	/^static int stats_prev_global_write_bucket;$/;"	v	file:
stats_prev_n_read	or/main.c	/^static uint64_t stats_prev_n_read = 0;$/;"	v	file:
stats_prev_n_written	or/main.c	/^static uint64_t stats_prev_n_written = 0;$/;"	v	file:
status	common/util.h	/^  int status;$/;"	m	struct:process_handle_t
status	or/dirserv.c	/^  uint32_t status;$/;"	m	struct:router_status_t	file:
status	or/or.h	/^  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;$/;"	m	struct:tor_version_t	typeref:enum:tor_version_t::__anon67
status	or/or.h	/^  routerstatus_t status; \/**< Underlying 'status' object for this router.$/;"	m	struct:vote_routerstatus_t
status	tools/tor-fw-helper/tor-fw-helper-natpmp.h	/^  int status;$/;"	m	struct:natpmp_state_t
status_by_digest	or/dirserv.c	/^  digestmap_t *status_by_digest; \/**< Map from digest to router_status_t. *\/$/;"	m	struct:authdir_config_t	file:
status_tag	or/or.h	/^  char status_tag[MAX_STATUS_TAG_LEN];$/;"	m	struct:tor_version_t
stderr_handle	common/util.h	/^  FILE *stderr_handle;$/;"	m	struct:process_handle_t
stderr_pipe	common/util.h	/^  HANDLE stderr_pipe;$/;"	m	struct:process_handle_t
stderr_pipe	common/util.h	/^  int stderr_pipe;$/;"	m	struct:process_handle_t
stdio_file	common/util.c	/^  FILE *stdio_file; \/**< stdio wrapper for <b>fd<\/b>. *\/$/;"	m	struct:open_file_t	file:
stdout_handle	common/util.h	/^  FILE *stdout_handle;$/;"	m	struct:process_handle_t
stdout_pipe	common/util.h	/^  HANDLE stdout_pipe;$/;"	m	struct:process_handle_t
stdout_pipe	common/util.h	/^  int stdout_pipe;$/;"	m	struct:process_handle_t
store_len	or/or.h	/^  size_t store_len;$/;"	m	struct:desc_store_t
store_type_t	or/or.h	/^typedef enum store_type_t {$/;"	g
store_type_t	or/or.h	/^} store_type_t;$/;"	t	typeref:enum:store_type_t
strcasecmp	common/compat.h	/^#define strcasecmp /;"	d
strcasecmpend	common/util.c	/^strcasecmpend(const char *s1, const char *s2)$/;"	f
strcasecmpstart	common/util.c	/^strcasecmpstart(const char *s1, const char *s2)$/;"	f
strcmp_len	common/util.c	/^strcmp_len(const char *s1, const char *s2, size_t s1_len)$/;"	f
strcmp_opt	common/util.c	/^strcmp_opt(const char *s1, const char *s2)$/;"	f
strcmpend	common/util.c	/^strcmpend(const char *s1, const char *s2)$/;"	f
strcmpstart	common/util.c	/^strcmpstart(const char *s1, const char *s2)$/;"	f
stream	common/torgzip.c	/^  struct z_stream_s stream; \/**< The zlib stream *\/$/;"	m	struct:tor_zlib_state_t	typeref:struct:tor_zlib_state_t::z_stream_s	file:
stream_end_reason_to_control_string	or/reasons.c	/^stream_end_reason_to_control_string(int reason)$/;"	f
stream_end_reason_to_socks5_response	or/reasons.c	/^stream_end_reason_to_socks5_response(int reason)$/;"	f
stream_end_reason_to_string	or/reasons.c	/^stream_end_reason_to_string(int reason)$/;"	f
stream_id	or/or.h	/^  streamid_t stream_id; \/**< The stream ID used for this edge connection on its$/;"	m	struct:edge_connection_t
stream_id	or/or.h	/^  streamid_t stream_id; \/**< Which stream is this cell associated with? *\/$/;"	m	struct:__anon36
stream_status	common/util.h	/^enum stream_status {$/;"	g
stream_status_event_t	or/or.h	/^typedef enum stream_status_event_t {$/;"	g
stream_status_event_t	or/or.h	/^} stream_status_event_t;$/;"	t	typeref:enum:stream_status_event_t
streamid_t	or/or.h	/^typedef uint16_t streamid_t;$/;"	t
streams_blocked_on_n_conn	or/or.h	/^  unsigned int streams_blocked_on_n_conn : 1;$/;"	m	struct:circuit_t
streams_blocked_on_p_conn	or/or.h	/^  unsigned int streams_blocked_on_p_conn : 1;$/;"	m	struct:circuit_t
string_is_C_identifier	common/util.c	/^string_is_C_identifier(const char *string)$/;"	f
string_num_dots	or/eventdns.c	/^string_num_dots(const char *s) {$/;"	f	file:
strlcat	common/strlcat.c	/^strlcat(char *dst, const char *src, size_t siz)$/;"	f
strlcpy	common/strlcpy.c	/^size_t strlcpy(char *dst, const char *src, size_t siz)$/;"	f
strmap_assert_ok	common/container.c	/^strmap_assert_ok(const strmap_t *map)$/;"	f
strmap_entries_eq	common/container.c	/^strmap_entries_eq(const strmap_entry_t *a, const strmap_entry_t *b)$/;"	f	file:
strmap_entry_hash	common/container.c	/^strmap_entry_hash(const strmap_entry_t *a)$/;"	f	file:
strmap_free	common/container.c	/^strmap_free(strmap_t *map, void (*free_val)(void*))$/;"	f
strmap_get	common/container.c	/^strmap_get(const strmap_t *map, const char *key)$/;"	f
strmap_get_lc	common/container.c	/^strmap_get_lc(const strmap_t *map, const char *key)$/;"	f
strmap_isempty	common/container.c	/^strmap_isempty(const strmap_t *map)$/;"	f
strmap_iter_done	common/container.c	/^strmap_iter_done(strmap_iter_t *iter)$/;"	f
strmap_iter_get	common/container.c	/^strmap_iter_get(strmap_iter_t *iter, const char **keyp, void **valp)$/;"	f
strmap_iter_init	common/container.c	/^strmap_iter_init(strmap_t *map)$/;"	f
strmap_iter_next	common/container.c	/^strmap_iter_next(strmap_t *map, strmap_iter_t *iter)$/;"	f
strmap_iter_next_rmv	common/container.c	/^strmap_iter_next_rmv(strmap_t *map, strmap_iter_t *iter)$/;"	f
strmap_remove	common/container.c	/^strmap_remove(strmap_t *map, const char *key)$/;"	f
strmap_remove_lc	common/container.c	/^strmap_remove_lc(strmap_t *map, const char *key)$/;"	f
strmap_set	common/container.c	/^strmap_set(strmap_t *map, const char *key, void *val)$/;"	f
strmap_set_lc	common/container.c	/^strmap_set_lc(strmap_t *map, const char *key, void *val)$/;"	f
strmap_size	common/container.c	/^strmap_size(const strmap_t *map)$/;"	f
strncasecmp	common/compat.h	/^#define strncasecmp /;"	d
strndup	common/util.c	/^ #undef strndup$/;"	d	file:
strtoint	or/eventdns.c	/^strtoint(const char *const str) {$/;"	f	file:
strtoint_clipped	or/eventdns.c	/^strtoint_clipped(const char *const str, int min, int max)$/;"	f	file:
successful_uploads	or/or.h	/^  smartlist_t *successful_uploads;$/;"	m	struct:rend_service_descriptor_t
suicide	common/OpenBSD_malloc_Linux.c	/^static int	suicide;$/;"	v	file:
supported_methods	or/or.h	/^  smartlist_t *supported_methods;$/;"	m	struct:networkstatus_t
suppress_libevent_log_msg	common/compat_libevent.c	/^suppress_libevent_log_msg(const char *msg)$/;"	f
suppress_msg	common/compat_libevent.c	/^static const char *suppress_msg = NULL;$/;"	v	file:
svn_revision	or/or.h	/^  int svn_revision;$/;"	m	struct:tor_version_t
sweep_bridge_list	or/circuitbuild.c	/^sweep_bridge_list(void)$/;"	f
sweep_proxy_list	or/transports.c	/^sweep_proxy_list(void)$/;"	f
sweep_transport_list	or/circuitbuild.c	/^sweep_transport_list(void)$/;"	f
switch_id	common/compat.c	/^switch_id(const char *user)$/;"	f
switch_logs_debug	common/log.c	/^switch_logs_debug(void)$/;"	f
syslog_count	common/log.c	/^static int syslog_count = 0;$/;"	v	file:
t	or/routerparse.c	/^  const char *t;$/;"	m	struct:token_rule_t	file:
t1_count	test/test_util.c	/^static int t1_count = 0, t2_count = 0;$/;"	v	file:
t2_count	test/test_util.c	/^static int t1_count = 0, t2_count = 0;$/;"	v	file:
tag_pack	or/cpuworker.c	/^tag_pack(char *tag, uint64_t conn_id, circid_t circ_id)$/;"	f	file:
tag_unpack	or/cpuworker.c	/^tag_unpack(const char *tag, uint64_t *conn_id, circid_t *circ_id)$/;"	f	file:
tail	or/buffers.c	/^  chunk_t *tail; \/**< Last chunk in the list, or NULL for none. *\/$/;"	m	struct:buf_t	file:
tail	or/or.h	/^  packed_cell_t *tail; \/**< The last cell, or NULL if the queue is empty. *\/$/;"	m	struct:cell_queue_t
tell_controller_about_resolved_result	or/connection_edge.c	/^tell_controller_about_resolved_result(entry_connection_t *conn,$/;"	f	file:
temp_dir	test/test.c	/^static char temp_dir[256];$/;"	v	file:
temp_dir_setup_in_pid	test/test.c	/^static pid_t temp_dir_setup_in_pid = 0;$/;"	v	file:
tempname	common/util.c	/^  char *tempname; \/**< Name of the temporary file. *\/$/;"	m	struct:open_file_t	file:
test_addr_basic	test/test_addr.c	/^test_addr_basic(void)$/;"	f	file:
test_addr_compare	test/test_addr.c	/^#define test_addr_compare(/;"	d	file:
test_addr_compare_masked	test/test_addr.c	/^#define test_addr_compare_masked(/;"	d	file:
test_addr_ip6_helpers	test/test_addr.c	/^test_addr_ip6_helpers(void)$/;"	f	file:
test_addr_mask_ports_parse	test/test_addr.c	/^#define test_addr_mask_ports_parse(/;"	d	file:
test_array	test/test.c	/^static struct testcase_t test_array[] = {$/;"	v	typeref:struct:testcase_t	file:
test_assert	test/test.h	/^#define test_assert(/;"	d
test_buffer_copy	test/test.c	/^test_buffer_copy(void *arg)$/;"	f	file:
test_buffers	test/test.c	/^test_buffers(void)$/;"	f	file:
test_circuit_timeout	test/test.c	/^test_circuit_timeout(void)$/;"	f	file:
test_commandline	tools/tor-fw-helper/tor-fw-helper.h	/^  int test_commandline;$/;"	m	struct:__anon72
test_config_addressmap	test/test_config.c	/^test_config_addressmap(void *arg)$/;"	f	file:
test_container_bitarray	test/test_containers.c	/^test_container_bitarray(void)$/;"	f	file:
test_container_digestset	test/test_containers.c	/^test_container_digestset(void)$/;"	f	file:
test_container_order_functions	test/test_containers.c	/^test_container_order_functions(void)$/;"	f	file:
test_container_pqueue	test/test_containers.c	/^test_container_pqueue(void)$/;"	f	file:
test_container_smartlist_basic	test/test_containers.c	/^test_container_smartlist_basic(void)$/;"	f	file:
test_container_smartlist_digests	test/test_containers.c	/^test_container_smartlist_digests(void)$/;"	f	file:
test_container_smartlist_join	test/test_containers.c	/^test_container_smartlist_join(void)$/;"	f	file:
test_container_smartlist_overlap	test/test_containers.c	/^test_container_smartlist_overlap(void)$/;"	f	file:
test_container_smartlist_strings	test/test_containers.c	/^test_container_smartlist_strings(void)$/;"	f	file:
test_container_strmap	test/test_containers.c	/^test_container_strmap(void)$/;"	f	file:
test_crypto_aes	test/test_crypto.c	/^test_crypto_aes(void *arg)$/;"	f	file:
test_crypto_aes_iv	test/test_crypto.c	/^test_crypto_aes_iv(void *arg)$/;"	f	file:
test_crypto_base32_decode	test/test_crypto.c	/^test_crypto_base32_decode(void)$/;"	f	file:
test_crypto_dh	test/test_crypto.c	/^test_crypto_dh(void)$/;"	f	file:
test_crypto_formats	test/test_crypto.c	/^test_crypto_formats(void)$/;"	f	file:
test_crypto_pk	test/test_crypto.c	/^test_crypto_pk(void)$/;"	f	file:
test_crypto_rng	test/test_crypto.c	/^test_crypto_rng(void)$/;"	f	file:
test_crypto_s2k	test/test_crypto.c	/^test_crypto_s2k(void)$/;"	f	file:
test_crypto_sha	test/test_crypto.c	/^test_crypto_sha(void)$/;"	f	file:
test_dir_formats	test/test_dir.c	/^test_dir_formats(void)$/;"	f	file:
test_dir_fp_pairs	test/test_dir.c	/^test_dir_fp_pairs(void)$/;"	f	file:
test_dir_measured_bw	test/test_dir.c	/^test_dir_measured_bw(void)$/;"	f	file:
test_dir_nicknames	test/test_dir.c	/^test_dir_nicknames(void)$/;"	f	file:
test_dir_param_voting	test/test_dir.c	/^test_dir_param_voting(void)$/;"	f	file:
test_dir_split_fps	test/test_dir.c	/^test_dir_split_fps(void *testdata)$/;"	f	file:
test_dir_v3_networkstatus	test/test_dir.c	/^test_dir_v3_networkstatus(void)$/;"	f	file:
test_dir_versions	test/test_dir.c	/^test_dir_versions(void)$/;"	f	file:
test_eq	test/test.h	/^#define test_eq(/;"	d
test_eq_ptr	test/test.h	/^#define test_eq_ptr(/;"	d
test_external_ip	test/test_addr.c	/^#define test_external_ip(/;"	d	file:
test_fail	test/test.h	/^#define test_fail(/;"	d
test_fail_msg	test/test.h	/^#define test_fail_msg(/;"	d
test_geoip	test/test.c	/^test_geoip(void)$/;"	f	file:
test_internal_ip	test/test_addr.c	/^#define test_internal_ip(/;"	d	file:
test_md1	test/test_microdesc.c	/^static const char test_md1[] =$/;"	v	file:
test_md2	test/test_microdesc.c	/^static const char test_md2[] =$/;"	v	file:
test_md3	test/test_microdesc.c	/^static const char test_md3[] =$/;"	v	file:
test_md_cache	test/test_microdesc.c	/^test_md_cache(void *data)$/;"	f	file:
test_mem_op	test/test.h	/^#define test_mem_op(/;"	d
test_mem_op_hex	test/test.h	/^#define test_mem_op_hex(/;"	d
test_memcpy	test/tinytest_demo.c	/^test_memcpy(void *ptr)$/;"	f
test_memeq	test/test.h	/^#define test_memeq(/;"	d
test_memeq_hex	test/test.h	/^#define test_memeq_hex(/;"	d
test_memneq	test/test.h	/^#define test_memneq(/;"	d
test_neq	test/test.h	/^#define test_neq(/;"	d
test_neq_ptr	test/test.h	/^#define test_neq_ptr(/;"	d
test_ntop6_reduces	test/test_addr.c	/^#define test_ntop6_reduces(/;"	d	file:
test_onion_handshake	test/test.c	/^test_onion_handshake(void)$/;"	f	file:
test_policies	test/test.c	/^test_policies(void)$/;"	f	file:
test_policy_summary_helper	test/test.c	/^test_policy_summary_helper(const char *policy_str,$/;"	f	file:
test_pt_parsing	test/test_pt.c	/^test_pt_parsing(void)$/;"	f	file:
test_pt_protocol	test/test_pt.c	/^test_pt_protocol(void)$/;"	f	file:
test_pton6_bad	test/test_addr.c	/^#define test_pton6_bad(/;"	d	file:
test_pton6_same	test/test_addr.c	/^#define test_pton6_same(/;"	d	file:
test_rend_fns	test/test.c	/^test_rend_fns(void)$/;"	f	file:
test_same_voter	test/test_dir.c	/^test_same_voter(networkstatus_voter_info_t *v1,$/;"	f	file:
test_socks_4_supported_commands	test/test.c	/^test_socks_4_supported_commands(void *ptr)$/;"	f	file:
test_socks_4_unsupported_commands	test/test.c	/^test_socks_4_unsupported_commands(void *ptr)$/;"	f	file:
test_socks_5_auth_before_negotiation	test/test.c	/^test_socks_5_auth_before_negotiation(void *ptr)$/;"	f	file:
test_socks_5_authenticate	test/test.c	/^test_socks_5_authenticate(void *ptr)$/;"	f	file:
test_socks_5_authenticate_with_data	test/test.c	/^test_socks_5_authenticate_with_data(void *ptr)$/;"	f	file:
test_socks_5_no_authenticate	test/test.c	/^test_socks_5_no_authenticate(void *ptr)$/;"	f	file:
test_socks_5_supported_commands	test/test.c	/^test_socks_5_supported_commands(void *ptr)$/;"	f	file:
test_socks_5_unsupported_commands	test/test.c	/^test_socks_5_unsupported_commands(void *ptr)$/;"	f	file:
test_stats	test/test.c	/^test_stats(void)$/;"	f	file:
test_strcmp	test/tinytest_demo.c	/^test_strcmp(void *data)$/;"	f
test_streq	test/test.h	/^#define test_streq(/;"	d
test_strneq	test/test.h	/^#define test_strneq(/;"	d
test_util_asprintf	test/test_util.c	/^test_util_asprintf(void *ptr)$/;"	f	file:
test_util_config_line	test/test_util.c	/^test_util_config_line(void)$/;"	f	file:
test_util_config_line_comment_character	test/test_util.c	/^test_util_config_line_comment_character(void)$/;"	f	file:
test_util_config_line_escaped_content	test/test_util.c	/^test_util_config_line_escaped_content(void)$/;"	f	file:
test_util_config_line_quotes	test/test_util.c	/^test_util_config_line_quotes(void)$/;"	f	file:
test_util_control_formats	test/test_util.c	/^test_util_control_formats(void)$/;"	f	file:
test_util_datadir	test/test_util.c	/^test_util_datadir(void)$/;"	f	file:
test_util_di_ops	test/test_util.c	/^test_util_di_ops(void)$/;"	f	file:
test_util_eat_whitespace	test/test_util.c	/^test_util_eat_whitespace(void *ptr)$/;"	f	file:
test_util_exit_status	test/test_util.c	/^test_util_exit_status(void *ptr)$/;"	f	file:
test_util_expand_filename	test/test_util.c	/^test_util_expand_filename(void)$/;"	f	file:
test_util_fgets_eagain	test/test_util.c	/^test_util_fgets_eagain(void *ptr)$/;"	f	file:
test_util_find_str_at_start_of_line	test/test_util.c	/^test_util_find_str_at_start_of_line(void *ptr)$/;"	f	file:
test_util_gzip	test/test_util.c	/^test_util_gzip(void)$/;"	f	file:
test_util_join_win_cmdline	test/test_util.c	/^test_util_join_win_cmdline(void *ptr)$/;"	f	file:
test_util_listdir	test/test_util.c	/^test_util_listdir(void *ptr)$/;"	f	file:
test_util_load_win_lib	test/test_util.c	/^test_util_load_win_lib(void *ptr)$/;"	f	file:
test_util_make_environment	test/test_util.c	/^test_util_make_environment(void *ptr)$/;"	f	file:
test_util_memarea	test/test_util.c	/^test_util_memarea(void)$/;"	f	file:
test_util_mempool	test/test_util.c	/^test_util_mempool(void)$/;"	f	file:
test_util_mmap	test/test_util.c	/^test_util_mmap(void)$/;"	f	file:
test_util_n_bits_set	test/test_util.c	/^test_util_n_bits_set(void *ptr)$/;"	f	file:
test_util_parent_dir	test/test_util.c	/^test_util_parent_dir(void *ptr)$/;"	f	file:
test_util_path_is_relative	test/test_util.c	/^test_util_path_is_relative(void)$/;"	f	file:
test_util_pow2	test/test_util.c	/^test_util_pow2(void)$/;"	f	file:
test_util_set_env_var_in_sl	test/test_util.c	/^test_util_set_env_var_in_sl(void *ptr)$/;"	f	file:
test_util_sl_new_from_text_lines	test/test_util.c	/^test_util_sl_new_from_text_lines(void *ptr)$/;"	f	file:
test_util_spawn_background_fail	test/test_util.c	/^test_util_spawn_background_fail(void *ptr)$/;"	f	file:
test_util_spawn_background_ok	test/test_util.c	/^test_util_spawn_background_ok(void *ptr)$/;"	f	file:
test_util_spawn_background_partial_read	test/test_util.c	/^test_util_spawn_background_partial_read(void *ptr)$/;"	f	file:
test_util_split_lines	test/test_util.c	/^test_util_split_lines(void *ptr)$/;"	f	file:
test_util_sscanf	test/test_util.c	/^test_util_sscanf(void)$/;"	f	file:
test_util_string_is_C_identifier	test/test_util.c	/^test_util_string_is_C_identifier(void *ptr)$/;"	f	file:
test_util_strmisc	test/test_util.c	/^test_util_strmisc(void)$/;"	f	file:
test_util_strtok	test/test_util.c	/^test_util_strtok(void)$/;"	f	file:
test_util_threads	test/test_util.c	/^test_util_threads(void)$/;"	f	file:
test_util_time	test/test_util.c	/^test_util_time(void)$/;"	f	file:
test_v_i_o	test/test_dir.c	/^#define test_v_i_o(/;"	d	file:
testcase_fn	test/tinytest.h	/^typedef void (*testcase_fn)(void *);$/;"	t
testcase_run_bare_	test/tinytest.c	/^testcase_run_bare_(const struct testcase_t *testcase)$/;"	f	file:
testcase_run_forked_	test/tinytest.c	/^testcase_run_forked_(const struct testgroup_t *group,$/;"	f	file:
testcase_run_one	test/tinytest.c	/^testcase_run_one(const struct testgroup_t *group,$/;"	f
testcase_setup_t	test/tinytest.h	/^struct testcase_setup_t {$/;"	s
testcase_t	test/tinytest.h	/^struct testcase_t {$/;"	s
testgroup_t	test/tinytest.h	/^struct testgroup_t {$/;"	s
testgroups	test/test.c	/^static struct testgroup_t testgroups[] = {$/;"	v	typeref:struct:testgroup_t	file:
testing_since	or/or.h	/^  time_t testing_since;$/;"	m	struct:__anon41
testing_tor_network_defaults	or/config.c	/^static const config_var_t testing_tor_network_defaults[] = {$/;"	v	file:
the_directory	or/dirserv.c	/^static cached_dir_t *the_directory = NULL;$/;"	v	file:
the_directory_is_dirty	or/dirserv.c	/^static time_t the_directory_is_dirty = 1;$/;"	v	file:
the_evdns_base	or/dns.c	/^static struct evdns_base *the_evdns_base = NULL;$/;"	v	typeref:struct:evdns_base	file:
the_event_base	common/compat_libevent.c	/^struct event_base *the_event_base = NULL;$/;"	v	typeref:struct:event_base
the_microdesc_cache	or/microdesc.c	/^static microdesc_cache_t *the_microdesc_cache = NULL;$/;"	v	file:
the_nodelist	or/nodelist.c	/^static nodelist_t *the_nodelist=NULL;$/;"	v	file:
the_runningrouters	or/dirserv.c	/^static cached_dir_t the_runningrouters;$/;"	v	file:
the_tor_version	or/config.c	/^static char *the_tor_version = NULL;$/;"	v	file:
the_v2_networkstatus	or/dirserv.c	/^static cached_dir_t *the_v2_networkstatus = NULL;$/;"	v	file:
the_v2_networkstatus_is_dirty	or/dirserv.c	/^static time_t the_v2_networkstatus_is_dirty = 1;$/;"	v	file:
threads_initialized	common/compat.c	/^static int threads_initialized = 0;$/;"	v	file:
time	or/rephist.c	/^  time_t time;$/;"	m	struct:predicted_port_t	file:
time_expiring	or/or.h	/^  time_t time_expiring;$/;"	m	struct:rend_intro_point_t
time_msec_units	or/config.c	/^static struct unit_table_t time_msec_units[] = {$/;"	v	typeref:struct:unit_table_t	file:
time_of_last_signewnym	or/main.c	/^static time_t time_of_last_signewnym = 0;$/;"	v	file:
time_of_process_start	or/main.c	/^time_t time_of_process_start = 0;$/;"	v
time_published	or/or.h	/^  time_t time_published;$/;"	m	struct:rend_intro_point_t
time_to_check_for_correct_dns	or/main.c	/^static time_t time_to_check_for_correct_dns = 0;$/;"	v	file:
time_to_download_next_consensus	or/networkstatus.c	/^static time_t time_to_download_next_consensus[N_CONSENSUS_FLAVORS];$/;"	v	file:
time_to_expire	or/or.h	/^  time_t time_to_expire;$/;"	m	struct:rend_intro_point_t
time_to_record_bandwidth_usage	or/hibernate.c	/^time_to_record_bandwidth_usage(time_t now)$/;"	f	file:
time_unit_t	or/hibernate.c	/^} time_unit_t;$/;"	t	typeref:enum:__anon32	file:
time_units	or/config.c	/^static struct unit_table_t time_units[] = {$/;"	v	typeref:struct:unit_table_t	file:
timed_out	or/or.h	/^  unsigned int timed_out : 1;$/;"	m	struct:rend_intro_point_t
timedout	or/eventdns.c	/^	int timedout;  \/* number of times in a row a request has timed out *\/$/;"	m	struct:nameserver	file:
timeout0	test/test.c	/^#define timeout0 /;"	d	file:
timeout_event	or/eventdns.c	/^	struct event timeout_event; \/* used to keep the timeout for *\/$/;"	m	struct:nameserver	typeref:struct:nameserver::event	file:
timeout_event	or/eventdns.c	/^	struct event timeout_event;$/;"	m	struct:evdns_request	typeref:struct:evdns_request::event	file:
timeout_ms	or/or.h	/^  double timeout_ms;$/;"	m	struct:__anon54
timeouts_after_firsthop	or/or.h	/^  int8_t *timeouts_after_firsthop;$/;"	m	struct:__anon53
timeradd	common/compat.h	/^#define timeradd(/;"	d
timercmp	common/compat.h	/^#define timercmp(/;"	d
timersub	common/compat.h	/^#define timersub(/;"	d
timespec_to_nsec	test/bench.c	/^timespec_to_nsec(const struct timespec *ts)$/;"	f	file:
timestamp	or/or.h	/^  time_t timestamp; \/**< Time when the descriptor was generated. *\/$/;"	m	struct:rend_service_descriptor_t
timestamp_created	or/or.h	/^  struct timeval timestamp_created;$/;"	m	struct:circuit_t	typeref:struct:circuit_t::timeval
timestamp_created	or/or.h	/^  time_t timestamp_created; \/**< When was this connection_t created? *\/$/;"	m	struct:connection_t
timestamp_dirty	or/or.h	/^  time_t timestamp_dirty;$/;"	m	struct:circuit_t
timestamp_last_added_nonpadding	or/or.h	/^  time_t timestamp_last_added_nonpadding; \/** When did we last add a$/;"	m	struct:or_connection_t
timestamp_lastempty	or/or.h	/^  time_t timestamp_lastempty; \/**< When was the outbuf last completely empty?*\/$/;"	m	struct:or_connection_t
timestamp_lastread	or/or.h	/^  time_t timestamp_lastread; \/**< When was the last time libevent said we could$/;"	m	struct:connection_t
timestamp_lastwritten	or/or.h	/^  time_t timestamp_lastwritten; \/**< When was the last time libevent said we$/;"	m	struct:connection_t
timeval	common/compat.h	/^struct timeval {$/;"	s
tinytest_get_verbosity_	test/tinytest.c	/^tinytest_get_verbosity_(void)$/;"	f
tinytest_main	test/tinytest.c	/^tinytest_main(int c, const char **v, struct testgroup_t *groups)$/;"	f
tinytest_set_flag_	test/tinytest.c	/^tinytest_set_flag_(struct testgroup_t *groups, const char *arg, unsigned long flag)$/;"	f
tinytest_set_test_failed_	test/tinytest.c	/^tinytest_set_test_failed_(void)$/;"	f
tinytest_set_test_skipped_	test/tinytest.c	/^tinytest_set_test_skipped_(void)$/;"	f
tinytest_skip	test/tinytest.h	/^#define tinytest_skip(/;"	d
tls	or/or.h	/^  tor_tls_t *tls; \/**< TLS connection state. *\/$/;"	m	struct:or_connection_t
tls_error	or/or.h	/^  int tls_error; \/**< Last tor_tls error code. *\/$/;"	m	struct:or_connection_t
tls_error_to_orconn_end_reason	or/reasons.c	/^tls_error_to_orconn_end_reason(int e)$/;"	f
tls_library_is_initialized	common/tortls.c	/^static int tls_library_is_initialized = 0;$/;"	v	file:
tls_log_errors	common/tortls.c	/^tls_log_errors(tor_tls_t *tls, int severity, int domain, const char *doing)$/;"	f	file:
token_check_object	or/routerparse.c	/^token_check_object(memarea_t *area, const char *kwd,$/;"	f	file:
token_clear	or/routerparse.c	/^token_clear(directory_token_t *tok)$/;"	f	file:
token_rule_t	or/routerparse.c	/^typedef struct token_rule_t {$/;"	s	file:
token_rule_t	or/routerparse.c	/^} token_rule_t;$/;"	t	typeref:struct:token_rule_t	file:
tokenize_string	or/routerparse.c	/^tokenize_string(memarea_t *area,$/;"	f	file:
tor_accept_socket	common/compat.c	/^tor_accept_socket(tor_socket_t sockfd, struct sockaddr *addr, socklen_t *len)$/;"	f
tor_add_bufferevent_to_rate_limit_group	common/compat_libevent.c	/^tor_add_bufferevent_to_rate_limit_group(struct bufferevent *bev,$/;"	f
tor_addr_compare	common/address.c	/^tor_addr_compare(const tor_addr_t *addr1, const tor_addr_t *addr2,$/;"	f
tor_addr_compare_masked	common/address.c	/^tor_addr_compare_masked(const tor_addr_t *addr1, const tor_addr_t *addr2,$/;"	f
tor_addr_comparison_t	common/address.h	/^} tor_addr_comparison_t;$/;"	t	typeref:enum:__anon2
tor_addr_copy	common/address.c	/^tor_addr_copy(tor_addr_t *dest, const tor_addr_t *src)$/;"	f
tor_addr_eq	common/address.h	/^#define tor_addr_eq(/;"	d
tor_addr_eq_ipv4h	common/address.h	/^tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u)$/;"	f
tor_addr_family	common/address.h	/^tor_addr_family(const tor_addr_t *a)$/;"	f
tor_addr_from_in	common/address.h	/^#define tor_addr_from_in(/;"	d
tor_addr_from_in6	common/address.c	/^tor_addr_from_in6(tor_addr_t *dest, const struct in6_addr *in6)$/;"	f
tor_addr_from_ipv4h	common/address.h	/^#define tor_addr_from_ipv4h(/;"	d
tor_addr_from_ipv4n	common/address.c	/^tor_addr_from_ipv4n(tor_addr_t *dest, uint32_t v4addr)$/;"	f
tor_addr_from_ipv6_bytes	common/address.c	/^tor_addr_from_ipv6_bytes(tor_addr_t *dest, const char *ipv6_bytes)$/;"	f
tor_addr_from_sockaddr	common/address.c	/^tor_addr_from_sockaddr(tor_addr_t *a, const struct sockaddr *sa,$/;"	f
tor_addr_hash	common/address.c	/^tor_addr_hash(const tor_addr_t *addr)$/;"	f
tor_addr_is_internal	common/address.c	/^tor_addr_is_internal(const tor_addr_t *addr, int for_listening)$/;"	f
tor_addr_is_loopback	common/address.c	/^tor_addr_is_loopback(const tor_addr_t *addr)$/;"	f
tor_addr_is_multicast	common/address.c	/^tor_addr_is_multicast(const tor_addr_t *a)$/;"	f	file:
tor_addr_is_null	common/address.c	/^tor_addr_is_null(const tor_addr_t *addr)$/;"	f
tor_addr_is_v4	common/address.c	/^tor_addr_is_v4(const tor_addr_t *addr)$/;"	f
tor_addr_lookup	common/address.c	/^tor_addr_lookup(const char *name, uint16_t family, tor_addr_t *addr)$/;"	f
tor_addr_make_unspec	common/address.c	/^tor_addr_make_unspec(tor_addr_t *a)$/;"	f
tor_addr_parse	common/address.c	/^tor_addr_parse(tor_addr_t *addr, const char *src)$/;"	f
tor_addr_parse_PTR_name	common/address.c	/^tor_addr_parse_PTR_name(tor_addr_t *result, const char *address,$/;"	f
tor_addr_parse_mask_ports	common/address.c	/^tor_addr_parse_mask_ports(const char *s, tor_addr_t *addr_out,$/;"	f
tor_addr_port_lookup	common/address.c	/^tor_addr_port_lookup(const char *s, tor_addr_t *addr_out, uint16_t *port_out)$/;"	f
tor_addr_port_split	common/address.c	/^tor_addr_port_split(int severity, const char *addrport,$/;"	f
tor_addr_port_t	common/address.h	/^typedef struct tor_addr_port_t$/;"	s
tor_addr_port_t	common/address.h	/^} tor_addr_port_t;$/;"	t	typeref:struct:tor_addr_port_t
tor_addr_t	common/address.h	/^typedef struct tor_addr_t$/;"	s
tor_addr_t	common/address.h	/^} tor_addr_t;$/;"	t	typeref:struct:tor_addr_t
tor_addr_to_PTR_name	common/address.c	/^tor_addr_to_PTR_name(char *out, size_t outlen,$/;"	f
tor_addr_to_in	common/address.h	/^tor_addr_to_in(const tor_addr_t *a)$/;"	f
tor_addr_to_in6	common/address.h	/^tor_addr_to_in6(const tor_addr_t *a)$/;"	f
tor_addr_to_in6_addr16	common/address.h	/^#define tor_addr_to_in6_addr16(/;"	d
tor_addr_to_in6_addr32	common/address.h	/^#define tor_addr_to_in6_addr32(/;"	d
tor_addr_to_in6_addr8	common/address.h	/^#define tor_addr_to_in6_addr8(/;"	d
tor_addr_to_ipv4h	common/address.h	/^tor_addr_to_ipv4h(const tor_addr_t *a)$/;"	f
tor_addr_to_ipv4n	common/address.h	/^tor_addr_to_ipv4n(const tor_addr_t *a)$/;"	f
tor_addr_to_mapped_ipv4h	common/address.h	/^tor_addr_to_mapped_ipv4h(const tor_addr_t *a)$/;"	f
tor_addr_to_sockaddr	common/address.c	/^tor_addr_to_sockaddr(const tor_addr_t *a,$/;"	f
tor_addr_to_str	common/address.c	/^tor_addr_to_str(char *dest, const tor_addr_t *addr, size_t len, int decorate)$/;"	f
tor_asprintf	common/compat.c	/^tor_asprintf(char **strp, const char *fmt, ...)$/;"	f
tor_assert	common/util.h	/^#define tor_assert(/;"	d
tor_calloc	common/util.h	/^#define tor_calloc(/;"	d
tor_cert_decode	common/tortls.c	/^tor_cert_decode(const uint8_t *certificate, size_t certificate_len)$/;"	f
tor_cert_free	common/tortls.c	/^tor_cert_free(tor_cert_t *cert)$/;"	f
tor_cert_get_cert_digests	common/tortls.c	/^tor_cert_get_cert_digests(const tor_cert_t *cert)$/;"	f
tor_cert_get_der	common/tortls.c	/^tor_cert_get_der(const tor_cert_t *cert,$/;"	f
tor_cert_get_id_digests	common/tortls.c	/^tor_cert_get_id_digests(const tor_cert_t *cert)$/;"	f
tor_cert_new	common/tortls.c	/^tor_cert_new(X509 *x509_cert)$/;"	f	file:
tor_cert_t	common/tortls.c	/^struct tor_cert_t {$/;"	s	file:
tor_cert_t	common/tortls.h	/^typedef struct tor_cert_t tor_cert_t;$/;"	t	typeref:struct:tor_cert_t
tor_check_dh_key	common/crypto.c	/^tor_check_dh_key(int severity, BIGNUM *bn)$/;"	f	file:
tor_check_libevent_header_compatibility	common/compat_libevent.c	/^tor_check_libevent_header_compatibility(void)$/;"	f
tor_check_libevent_version	common/compat_libevent.c	/^tor_check_libevent_version(const char *m, int server,$/;"	f
tor_check_port_forwarding	common/util.c	/^tor_check_port_forwarding(const char *filename, int dir_port, int or_port,$/;"	f
tor_cleanup	or/main.c	/^tor_cleanup(void)$/;"	f
tor_close_socket	common/compat.c	/^tor_close_socket(tor_socket_t s)$/;"	f
tor_decode_libevent_version	common/compat_libevent.c	/^tor_decode_libevent_version(const char *v)$/;"	f	file:
tor_digest256_is_zero	common/util.c	/^tor_digest256_is_zero(const char *digest)$/;"	f
tor_digest_is_zero	common/util.c	/^tor_digest_is_zero(const char *digest)$/;"	f
tor_disable_debugger_attach	common/compat.c	/^tor_disable_debugger_attach(void)$/;"	f
tor_dup_addr	common/address.c	/^tor_dup_addr(const tor_addr_t *addr)$/;"	f
tor_dup_ip	common/address.c	/^tor_dup_ip(uint32_t addr)$/;"	f
tor_errno_to_tls_error	common/tortls.c	/^tor_errno_to_tls_error(int e)$/;"	f	file:
tor_evdns_add_server_port	common/compat_libevent.h	/^#define tor_evdns_add_server_port /;"	d
tor_evdns_add_server_port	common/compat_libevent.h	/^#define tor_evdns_add_server_port(/;"	d
tor_event_base_loopexit	common/compat_libevent.c	/^tor_event_base_loopexit(struct event_base *base, struct timeval *tv)$/;"	f
tor_event_base_loopexit	common/compat_libevent.h	/^#define tor_event_base_loopexit /;"	d
tor_event_free	common/compat_libevent.c	/^tor_event_free(struct event *ev)$/;"	f
tor_event_free	common/compat_libevent.h	/^#define tor_event_free /;"	d
tor_event_new	common/compat_libevent.c	/^tor_event_new(struct event_base *base, int sock, short what,$/;"	f
tor_event_new	common/compat_libevent.h	/^#define tor_event_new /;"	d
tor_evsignal_new	common/compat_libevent.c	/^tor_evsignal_new(struct event_base * base, int sig,$/;"	f
tor_evsignal_new	common/compat_libevent.h	/^#define tor_evsignal_new /;"	d
tor_evtimer_new	common/compat_libevent.c	/^tor_evtimer_new(struct event_base *base,$/;"	f
tor_evtimer_new	common/compat_libevent.h	/^#define tor_evtimer_new /;"	d
tor_fd_getpos	common/compat.c	/^tor_fd_getpos(int fd)$/;"	f
tor_fd_seekend	common/compat.c	/^tor_fd_seekend(int fd)$/;"	f
tor_fix_source_file	common/compat.c	/^tor_fix_source_file(const char *fname)$/;"	f
tor_fix_source_file	common/compat.h	/^#define tor_fix_source_file(/;"	d
tor_fopen_cloexec	common/compat.c	/^tor_fopen_cloexec(const char *path, const char *mode)$/;"	f
tor_fragile_assert	common/util.h	/^#define tor_fragile_assert(/;"	d
tor_free	common/util.h	/^#define tor_free(/;"	d
tor_free_all	or/main.c	/^tor_free_all(int postfork)$/;"	f
tor_fw_add_dir_port	tools/tor-fw-helper/tor-fw-helper.c	/^tor_fw_add_dir_port(tor_fw_options_t *tor_fw_options,$/;"	f	file:
tor_fw_add_or_port	tools/tor-fw-helper/tor-fw-helper.c	/^tor_fw_add_or_port(tor_fw_options_t *tor_fw_options,$/;"	f	file:
tor_fw_backend_t	tools/tor-fw-helper/tor-fw-helper.h	/^typedef struct tor_fw_backend_t {$/;"	s
tor_fw_backend_t	tools/tor-fw-helper/tor-fw-helper.h	/^} tor_fw_backend_t;$/;"	t	typeref:struct:tor_fw_backend_t
tor_fw_fetch_public_ip	tools/tor-fw-helper/tor-fw-helper.c	/^tor_fw_fetch_public_ip(tor_fw_options_t *tor_fw_options,$/;"	f	file:
tor_fw_get_miniupnp_backend	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^tor_fw_get_miniupnp_backend(void)$/;"	f
tor_fw_get_natpmp_backend	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^tor_fw_get_natpmp_backend(void)$/;"	f
tor_fw_options_t	tools/tor-fw-helper/tor-fw-helper.h	/^} tor_fw_options_t;$/;"	t	typeref:struct:__anon72
tor_fw_version	tools/tor-fw-helper/tor-fw-helper.h	/^#define tor_fw_version /;"	d
tor_get_digests	or/config_codedigest.c	/^tor_get_digests(void)$/;"	f
tor_get_exit_code	common/util.c	/^tor_get_exit_code(const process_handle_t *process_handle,$/;"	f
tor_get_libevent_version	common/compat_libevent.c	/^tor_get_libevent_version(const char **v_out)$/;"	f	file:
tor_get_root_bufferevent	common/compat_libevent.c	/^tor_get_root_bufferevent(struct bufferevent *bev)$/;"	f	file:
tor_get_thread_id	common/compat.c	/^tor_get_thread_id(void)$/;"	f
tor_get_thread_id	common/compat.h	/^#define tor_get_thread_id(/;"	d
tor_gettimeofday	common/compat.c	/^tor_gettimeofday(struct timeval *timeval)$/;"	f
tor_gettimeofday_cache_clear	or/relay.c	/^tor_gettimeofday_cache_clear(void)$/;"	f
tor_gettimeofday_cached	or/relay.c	/^tor_gettimeofday_cached(struct timeval *tv)$/;"	f	file:
tor_git_revision	or/tor_main.c	/^const char tor_git_revision[] =$/;"	v
tor_git_revision	test/bench.c	/^const char tor_git_revision[] = "";$/;"	v
tor_git_revision	test/test.c	/^const char tor_git_revision[] = "";$/;"	v
tor_gmtime_r	common/compat.c	/^tor_gmtime_r(const time_t *timep, struct tm *result)$/;"	f
tor_gzip_compress	common/torgzip.c	/^tor_gzip_compress(char **out, size_t *out_len,$/;"	f
tor_gzip_uncompress	common/torgzip.c	/^tor_gzip_uncompress(char **out, size_t *out_len,$/;"	f
tor_inet_aton	common/compat.c	/^tor_inet_aton(const char *str, struct in_addr* addr)$/;"	f
tor_inet_ntoa	common/address.c	/^tor_inet_ntoa(const struct in_addr *in, char *buf, size_t buf_len)$/;"	f
tor_inet_ntop	common/compat.c	/^tor_inet_ntop(int af, const void *src, char *dst, size_t len)$/;"	f
tor_inet_pton	common/compat.c	/^tor_inet_pton(int af, const char *src, void *dst)$/;"	f
tor_init	or/main.c	/^tor_init(int argc, char *argv[])$/;"	f
tor_init_weak_random	common/compat.c	/^tor_init_weak_random(unsigned seed)$/;"	f
tor_join_win_cmdline	common/util.c	/^tor_join_win_cmdline(const char *argv[])$/;"	f
tor_libevent_cfg	common/compat_libevent.h	/^typedef struct tor_libevent_cfg {$/;"	s
tor_libevent_cfg	common/compat_libevent.h	/^} tor_libevent_cfg;$/;"	t	typeref:struct:tor_libevent_cfg
tor_libevent_get_base	common/compat_libevent.c	/^tor_libevent_get_base(void)$/;"	f
tor_libevent_get_method	common/compat_libevent.c	/^tor_libevent_get_method(void)$/;"	f
tor_libevent_get_one_tick_timeout	common/compat_libevent.c	/^tor_libevent_get_one_tick_timeout(void)$/;"	f
tor_libevent_get_version_str	common/compat_libevent.c	/^tor_libevent_get_version_str(void)$/;"	f
tor_libevent_initialize	common/compat_libevent.c	/^tor_libevent_initialize(tor_libevent_cfg *torcfg)$/;"	f
tor_libevent_set_tick_timeout	common/compat_libevent.c	/^tor_libevent_set_tick_timeout(int msec_per_tick)$/;"	f	file:
tor_libevent_using_iocp_bufferevents	common/compat_libevent.c	/^tor_libevent_using_iocp_bufferevents(void)$/;"	f
tor_listdir	common/util.c	/^tor_listdir(const char *dirname)$/;"	f
tor_localtime_r	common/compat.c	/^tor_localtime_r(const time_t *timep, struct tm *result)$/;"	f
tor_lockfile_lock	common/compat.c	/^tor_lockfile_lock(const char *filename, int blocking, int *locked_out)$/;"	f
tor_lockfile_t	common/compat.c	/^struct tor_lockfile_t {$/;"	s	file:
tor_lockfile_t	common/compat.h	/^typedef struct tor_lockfile_t tor_lockfile_t;$/;"	t	typeref:struct:tor_lockfile_t
tor_lockfile_unlock	common/compat.c	/^tor_lockfile_unlock(tor_lockfile_t *lockfile)$/;"	f
tor_log	common/log.c	/^tor_log(int severity, log_domain_mask_t domain, const char *format, ...)$/;"	f
tor_log2	common/util.c	/^tor_log2(uint64_t u64)$/;"	f
tor_log_mallinfo	common/util.c	/^tor_log_mallinfo(int severity)$/;"	f
tor_lookup_hostname	common/compat.c	/^tor_lookup_hostname(const char *name, uint32_t *addr)$/;"	f
tor_lround	common/util.c	/^tor_lround(double d)$/;"	f
tor_main	or/main.c	/^tor_main(int argc, char *argv[])$/;"	f
tor_malloc	common/util.h	/^#define tor_malloc(/;"	d
tor_malloc_roundup	common/util.h	/^#define tor_malloc_roundup(/;"	d
tor_malloc_zero	common/util.h	/^#define tor_malloc_zero(/;"	d
tor_mathlog	common/util.c	/^tor_mathlog(double d)$/;"	f
tor_mem_is_zero	common/util.c	/^tor_mem_is_zero(const char *mem, size_t len)$/;"	f
tor_memcmp	common/di_ops.c	/^tor_memcmp(const void *a, const void *b, size_t len)$/;"	f
tor_memdup	common/util.h	/^#define tor_memdup(/;"	d
tor_memeq	common/di_ops.c	/^tor_memeq(const void *a, const void *b, size_t sz)$/;"	f
tor_memmem	common/compat.c	/^tor_memmem(const void *_haystack, size_t hlen,$/;"	f
tor_memneq	common/di_ops.h	/^#define tor_memneq(/;"	d
tor_memstr	common/compat.h	/^tor_memstr(const void *haystack, size_t hlen, const char *needle)$/;"	f
tor_miniupnp_backend	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^static tor_fw_backend_t tor_miniupnp_backend = {$/;"	v	file:
tor_mlockall	common/compat.c	/^tor_mlockall(void)$/;"	f
tor_mmap_file	common/compat.c	/^tor_mmap_file(const char *filename)$/;"	f
tor_mmap_t	common/compat.h	/^typedef struct tor_mmap_t {$/;"	s
tor_mmap_t	common/compat.h	/^} tor_mmap_t;$/;"	t	typeref:struct:tor_mmap_t
tor_munmap_file	common/compat.c	/^tor_munmap_file(tor_mmap_t *handle)$/;"	f
tor_mutex_acquire	common/compat.c	/^tor_mutex_acquire(tor_mutex_t *m)$/;"	f
tor_mutex_acquire	common/compat.h	/^#define tor_mutex_acquire(/;"	d
tor_mutex_free	common/compat.c	/^tor_mutex_free(tor_mutex_t *m)$/;"	f
tor_mutex_free	common/compat.h	/^#define tor_mutex_free(/;"	d
tor_mutex_init	common/compat.c	/^tor_mutex_init(tor_mutex_t *m)$/;"	f
tor_mutex_init	common/compat.c	/^tor_mutex_init(tor_mutex_t *mutex)$/;"	f
tor_mutex_init	common/compat.h	/^#define tor_mutex_init(/;"	d
tor_mutex_new	common/compat.c	/^tor_mutex_new(void)$/;"	f
tor_mutex_new	common/compat.h	/^#define tor_mutex_new(/;"	d
tor_mutex_release	common/compat.c	/^tor_mutex_release(tor_mutex_t *m)$/;"	f
tor_mutex_release	common/compat.h	/^#define tor_mutex_release(/;"	d
tor_mutex_t	common/compat.h	/^typedef struct tor_mutex_t {$/;"	s
tor_mutex_t	common/compat.h	/^} tor_mutex_t;$/;"	t	typeref:struct:tor_mutex_t
tor_mutex_uninit	common/compat.c	/^tor_mutex_uninit(tor_mutex_t *m)$/;"	f
tor_mutex_uninit	common/compat.h	/^#define tor_mutex_uninit(/;"	d
tor_natpmp_add_tcp_mapping	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^tor_natpmp_add_tcp_mapping(tor_fw_options_t *tor_fw_options,$/;"	f
tor_natpmp_backend	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^static tor_fw_backend_t tor_natpmp_backend = {$/;"	v	file:
tor_natpmp_cleanup	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^tor_natpmp_cleanup(tor_fw_options_t *tor_fw_options, void *backend_state)$/;"	f
tor_natpmp_fetch_public_ip	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^tor_natpmp_fetch_public_ip(tor_fw_options_t *tor_fw_options,$/;"	f
tor_natpmp_init	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^tor_natpmp_init(tor_fw_options_t *tor_fw_options, void *backend_state)$/;"	f
tor_open_cloexec	common/compat.c	/^tor_open_cloexec(const char *path, int flags, unsigned mode)$/;"	f
tor_open_socket	common/compat.c	/^tor_open_socket(int domain, int type, int protocol)$/;"	f
tor_parse_double	common/util.c	/^tor_parse_double(const char *s, double min, double max, int *ok, char **next)$/;"	f
tor_parse_long	common/util.c	/^tor_parse_long(const char *s, int base, long min, long max,$/;"	f
tor_parse_uint64	common/util.c	/^tor_parse_uint64(const char *s, int base, uint64_t min,$/;"	f
tor_parse_ulong	common/util.c	/^tor_parse_ulong(const char *s, int base, unsigned long min,$/;"	f
tor_process_get_pid	common/util.c	/^tor_process_get_pid(process_handle_t *process_handle)$/;"	f
tor_process_get_stdout_pipe	common/util.c	/^tor_process_get_stdout_pipe(process_handle_t *process_handle)$/;"	f
tor_process_handle_destroy	common/util.c	/^tor_process_handle_destroy(process_handle_t *process_handle,$/;"	f
tor_process_monitor_free	common/procmon.c	/^tor_process_monitor_free(tor_process_monitor_t *procmon)$/;"	f
tor_process_monitor_new	common/procmon.c	/^tor_process_monitor_new(struct event_base *base,$/;"	f
tor_process_monitor_poll_cb	common/procmon.c	/^tor_process_monitor_poll_cb(evutil_socket_t unused1, short unused2,$/;"	f	file:
tor_process_monitor_t	common/procmon.c	/^struct tor_process_monitor_t {$/;"	s	file:
tor_process_monitor_t	common/procmon.h	/^typedef struct tor_process_monitor_t tor_process_monitor_t;$/;"	t	typeref:struct:tor_process_monitor_t
tor_procmon_callback_t	common/procmon.h	/^typedef void (*tor_procmon_callback_t)(void *);$/;"	t
tor_pthread_data_t	common/compat.c	/^typedef struct tor_pthread_data_t {$/;"	s	file:
tor_pthread_data_t	common/compat.c	/^} tor_pthread_data_t;$/;"	t	typeref:struct:tor_pthread_data_t	file:
tor_pthread_helper_fn	common/compat.c	/^tor_pthread_helper_fn(void *_data)$/;"	f	file:
tor_read_all_from_process_stderr	common/util.c	/^tor_read_all_from_process_stderr(const process_handle_t *process_handle,$/;"	f
tor_read_all_from_process_stdout	common/util.c	/^tor_read_all_from_process_stdout(const process_handle_t *process_handle,$/;"	f
tor_read_all_handle	common/util.c	/^tor_read_all_handle(FILE *h, char *buf, size_t count,$/;"	f
tor_read_all_handle	common/util.c	/^tor_read_all_handle(HANDLE h, char *buf, size_t count,$/;"	f
tor_realloc	common/util.h	/^#define tor_realloc(/;"	d
tor_set_bufferevent_rate_limit	common/compat_libevent.c	/^tor_set_bufferevent_rate_limit(struct bufferevent *bev,$/;"	f
tor_set_max_memlock	common/compat.c	/^tor_set_max_memlock(void)$/;"	f	file:
tor_snprintf	common/compat.c	/^tor_snprintf(char *str, size_t size, const char *format, ...)$/;"	f
tor_sockaddr_to_str	common/address.c	/^tor_sockaddr_to_str(const struct sockaddr *sa)$/;"	f
tor_socket_errno	common/compat.c	/^tor_socket_errno(tor_socket_t sock)$/;"	f
tor_socket_errno	common/compat.h	/^#define tor_socket_errno(/;"	d
tor_socket_recv	common/compat.h	/^#define tor_socket_recv(/;"	d
tor_socket_send	common/compat.h	/^#define tor_socket_send(/;"	d
tor_socket_strerror	common/compat.c	/^tor_socket_strerror(int e)$/;"	f
tor_socket_strerror	common/compat.h	/^#define tor_socket_strerror(/;"	d
tor_socket_t	common/compat.h	/^#define tor_socket_t /;"	d
tor_socketpair	common/compat.c	/^tor_socketpair(int family, int type, int protocol, tor_socket_t fd[2])$/;"	f
tor_spawn_background	common/util.c	/^tor_spawn_background(const char *const filename, const char **argv,$/;"	f
tor_split_lines	common/util.c	/^tor_split_lines(smartlist_t *sl, char *buf, int len)$/;"	f
tor_sscanf	common/util.c	/^tor_sscanf(const char *buf, const char *pattern, ...)$/;"	f
tor_strdup	common/util.h	/^#define tor_strdup(/;"	d
tor_strisnonupper	common/util.c	/^tor_strisnonupper(const char *s)$/;"	f
tor_strisprint	common/util.c	/^tor_strisprint(const char *s)$/;"	f
tor_strlower	common/util.c	/^tor_strlower(char *s)$/;"	f
tor_strndup	common/util.h	/^#define tor_strndup(/;"	d
tor_strstrip	common/util.c	/^tor_strstrip(char *s, const char *strip)$/;"	f
tor_strtok_r	common/compat.h	/^#define tor_strtok_r(/;"	d
tor_strtok_r_impl	common/compat.c	/^tor_strtok_r_impl(char *str, const char *sep, char **lasts)$/;"	f
tor_strupper	common/util.c	/^tor_strupper(char *s)$/;"	f
tor_terminate_process	common/util.c	/^tor_terminate_process(process_handle_t *process_handle)$/;"	f
tor_threads_init	common/compat.c	/^tor_threads_init(void)$/;"	f
tor_threads_init	common/compat.h	/^#define tor_threads_init(/;"	d
tor_timegm	common/util.c	/^tor_timegm(struct tm *tm)$/;"	f
tor_tls_allocate_tor_tls_object_ex_data_index	common/tortls.c	/^tor_tls_allocate_tor_tls_object_ex_data_index(void)$/;"	f	file:
tor_tls_assert_renegotiation_unblocked	common/tortls.c	/^tor_tls_assert_renegotiation_unblocked(tor_tls_t *tls)$/;"	f
tor_tls_block_renegotiation	common/tortls.c	/^tor_tls_block_renegotiation(tor_tls_t *tls)$/;"	f
tor_tls_cert_get_key	common/tortls.c	/^tor_tls_cert_get_key(tor_cert_t *cert)$/;"	f
tor_tls_cert_is_valid	common/tortls.c	/^tor_tls_cert_is_valid(int severity,$/;"	f
tor_tls_cert_matches_key	common/tortls.c	/^tor_tls_cert_matches_key(const tor_tls_t *tls, const tor_cert_t *cert)$/;"	f
tor_tls_check_lifetime	common/tortls.c	/^tor_tls_check_lifetime(int severity, tor_tls_t *tls,$/;"	f
tor_tls_client_is_using_v2_ciphers	common/tortls.c	/^tor_tls_client_is_using_v2_ciphers(const SSL *ssl, const char *address)$/;"	f	file:
tor_tls_context_decref	common/tortls.c	/^tor_tls_context_decref(tor_tls_context_t *ctx)$/;"	f	file:
tor_tls_context_incref	common/tortls.c	/^tor_tls_context_incref(tor_tls_context_t *ctx)$/;"	f	file:
tor_tls_context_init	common/tortls.c	/^tor_tls_context_init(int is_public_server,$/;"	f
tor_tls_context_init_one	common/tortls.c	/^tor_tls_context_init_one(tor_tls_context_t **ppcontext,$/;"	f	file:
tor_tls_context_new	common/tortls.c	/^tor_tls_context_new(crypto_pk_t *identity, unsigned int key_lifetime,$/;"	f	file:
tor_tls_context_t	common/tortls.c	/^typedef struct tor_tls_context_t {$/;"	s	file:
tor_tls_context_t	common/tortls.c	/^} tor_tls_context_t;$/;"	t	typeref:struct:tor_tls_context_t	file:
tor_tls_create_certificate	common/tortls.c	/^tor_tls_create_certificate(crypto_pk_t *rsa,$/;"	f	file:
tor_tls_debug_state_callback	common/tortls.c	/^tor_tls_debug_state_callback(const SSL *ssl, int type, int val)$/;"	f	file:
tor_tls_err_to_string	common/tortls.c	/^tor_tls_err_to_string(int err)$/;"	f
tor_tls_finish_handshake	common/tortls.c	/^tor_tls_finish_handshake(tor_tls_t *tls)$/;"	f
tor_tls_free	common/tortls.c	/^tor_tls_free(tor_tls_t *tls)$/;"	f
tor_tls_free_all	common/tortls.c	/^tor_tls_free_all(void)$/;"	f
tor_tls_get_buffer_sizes	common/tortls.c	/^tor_tls_get_buffer_sizes(tor_tls_t *tls,$/;"	f
tor_tls_get_by_ssl	common/tortls.c	/^tor_tls_get_by_ssl(const SSL *ssl)$/;"	f	file:
tor_tls_get_error	common/tortls.c	/^tor_tls_get_error(tor_tls_t *tls, int r, int extra,$/;"	f	file:
tor_tls_get_forced_write_size	common/tortls.c	/^tor_tls_get_forced_write_size(tor_tls_t *tls)$/;"	f
tor_tls_get_my_certs	common/tortls.c	/^tor_tls_get_my_certs(int server,$/;"	f
tor_tls_get_my_client_auth_key	common/tortls.c	/^tor_tls_get_my_client_auth_key(void)$/;"	f
tor_tls_get_n_raw_bytes	common/tortls.c	/^tor_tls_get_n_raw_bytes(tor_tls_t *tls, size_t *n_read, size_t *n_written)$/;"	f
tor_tls_get_num_server_handshakes	common/tortls.c	/^tor_tls_get_num_server_handshakes(tor_tls_t *tls)$/;"	f
tor_tls_get_peer_cert	common/tortls.c	/^tor_tls_get_peer_cert(tor_tls_t *tls)$/;"	f
tor_tls_get_pending_bytes	common/tortls.c	/^tor_tls_get_pending_bytes(tor_tls_t *tls)$/;"	f
tor_tls_get_state_description	common/tortls.c	/^tor_tls_get_state_description(tor_tls_t *tls, char *buf, size_t sz)$/;"	f
tor_tls_get_tlssecrets	common/tortls.c	/^tor_tls_get_tlssecrets(tor_tls_t *tls, uint8_t *secrets_out)$/;"	f
tor_tls_handshake	common/tortls.c	/^tor_tls_handshake(tor_tls_t *tls)$/;"	f
tor_tls_init	common/tortls.c	/^tor_tls_init(void)$/;"	f	file:
tor_tls_init_bufferevent	common/tortls.c	/^tor_tls_init_bufferevent(tor_tls_t *tls, struct bufferevent *bufev_in,$/;"	f
tor_tls_is_server	common/tortls.c	/^tor_tls_is_server(tor_tls_t *tls)$/;"	f
tor_tls_log_one_error	common/tortls.c	/^tor_tls_log_one_error(tor_tls_t *tls, unsigned long err,$/;"	f
tor_tls_new	common/tortls.c	/^tor_tls_new(int sock, int isServer)$/;"	f
tor_tls_object_ex_data_index	common/tortls.c	/^static int tor_tls_object_ex_data_index = -1;$/;"	v	file:
tor_tls_peer_has_cert	common/tortls.c	/^tor_tls_peer_has_cert(tor_tls_t *tls)$/;"	f
tor_tls_read	common/tortls.c	/^tor_tls_read(tor_tls_t *tls, char *cp, size_t len)$/;"	f
tor_tls_received_v3_certificate	common/tortls.c	/^tor_tls_received_v3_certificate(tor_tls_t *tls)$/;"	f
tor_tls_renegotiate	common/tortls.c	/^tor_tls_renegotiate(tor_tls_t *tls)$/;"	f
tor_tls_server_got_renegotiate	common/tortls.c	/^tor_tls_server_got_renegotiate(tor_tls_t *tls)$/;"	f
tor_tls_server_info_callback	common/tortls.c	/^tor_tls_server_info_callback(const SSL *ssl, int type, int val)$/;"	f	file:
tor_tls_set_logged_address	common/tortls.c	/^tor_tls_set_logged_address(tor_tls_t *tls, const char *address)$/;"	f
tor_tls_set_renegotiate_callback	common/tortls.c	/^tor_tls_set_renegotiate_callback(tor_tls_t *tls,$/;"	f
tor_tls_shutdown	common/tortls.c	/^tor_tls_shutdown(tor_tls_t *tls)$/;"	f
tor_tls_start_renegotiating	common/tortls.c	/^tor_tls_start_renegotiating(tor_tls_t *tls)$/;"	f
tor_tls_t	common/tortls.c	/^struct tor_tls_t {$/;"	s	file:
tor_tls_t	common/tortls.h	/^typedef struct tor_tls_t tor_tls_t;$/;"	t	typeref:struct:tor_tls_t
tor_tls_unblock_renegotiation	common/tortls.c	/^tor_tls_unblock_renegotiation(tor_tls_t *tls)$/;"	f
tor_tls_used_v1_handshake	common/tortls.c	/^tor_tls_used_v1_handshake(tor_tls_t *tls)$/;"	f
tor_tls_verify	common/tortls.c	/^tor_tls_verify(int severity, tor_tls_t *tls, crypto_pk_t **identity_key)$/;"	f
tor_tls_write	common/tortls.c	/^tor_tls_write(tor_tls_t *tls, const char *cp, size_t n)$/;"	f
tor_upnp_add_tcp_mapping	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^tor_upnp_add_tcp_mapping(tor_fw_options_t *options, void *backend_state)$/;"	f
tor_upnp_cleanup	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^tor_upnp_cleanup(tor_fw_options_t *options, void *backend_state)$/;"	f
tor_upnp_fetch_public_ip	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^tor_upnp_fetch_public_ip(tor_fw_options_t *options, void *backend_state)$/;"	f
tor_upnp_init	tools/tor-fw-helper/tor-fw-helper-upnp.c	/^tor_upnp_init(tor_fw_options_t *options, void *backend_state)$/;"	f
tor_validate_process_specifier	common/procmon.c	/^tor_validate_process_specifier(const char *process_spec,$/;"	f
tor_vasprintf	common/compat.c	/^tor_vasprintf(char **strp, const char *fmt, va_list args)$/;"	f
tor_version_as_new_as	or/routerparse.c	/^tor_version_as_new_as(const char *platform, const char *cutoff)$/;"	f
tor_version_compare	or/routerparse.c	/^tor_version_compare(tor_version_t *a, tor_version_t *b)$/;"	f
tor_version_is_obsolete	or/routerparse.c	/^tor_version_is_obsolete(const char *myversion, const char *versionlist)$/;"	f
tor_version_parse	or/routerparse.c	/^tor_version_parse(const char *s, tor_version_t *out)$/;"	f
tor_version_same_series	or/routerparse.c	/^tor_version_same_series(tor_version_t *a, tor_version_t *b)$/;"	f
tor_version_supports_microdescriptors	or/routerparse.c	/^tor_version_supports_microdescriptors(const char *platform)$/;"	f
tor_version_t	or/or.h	/^typedef struct tor_version_t {$/;"	s
tor_version_t	or/or.h	/^} tor_version_t;$/;"	t	typeref:struct:tor_version_t
tor_vsnprintf	common/compat.c	/^tor_vsnprintf(char *str, size_t size, const char *format, va_list args)$/;"	f
tor_vsscanf	common/util.c	/^tor_vsscanf(const char *buf, const char *pattern, va_list ap)$/;"	f
tor_weak_random	common/compat.c	/^tor_weak_random(void)$/;"	f
tor_x509_name_new	common/tortls.c	/^tor_x509_name_new(const char *cname)$/;"	f	file:
tor_zlib_free	common/torgzip.c	/^tor_zlib_free(tor_zlib_state_t *state)$/;"	f
tor_zlib_new	common/torgzip.c	/^tor_zlib_new(int compress, compress_method_t method)$/;"	f
tor_zlib_output_t	common/torgzip.h	/^} tor_zlib_output_t;$/;"	t	typeref:enum:__anon15
tor_zlib_process	common/torgzip.c	/^tor_zlib_process(tor_zlib_state_t *state,$/;"	f
tor_zlib_state_t	common/torgzip.c	/^struct tor_zlib_state_t {$/;"	s	file:
tor_zlib_state_t	common/torgzip.h	/^typedef struct tor_zlib_state_t tor_zlib_state_t;$/;"	t	typeref:struct:tor_zlib_state_t
torrc_defaults_fname	or/config.c	/^static char *torrc_defaults_fname;$/;"	v	file:
torrc_fname	or/config.c	/^static char *torrc_fname = NULL;$/;"	v	file:
total	common/OpenBSD_malloc_Linux.c	/^	u_short		total;	\/* How many chunk *\/$/;"	m	struct:pginfo	file:
total	or/geoip.c	/^  unsigned total; \/**< Total IP addresses seen in this country. *\/$/;"	m	struct:c_hist_t	file:
total_bandwidth	or/dirserv.c	/^static uint64_t total_bandwidth = 0;$/;"	v	file:
total_build_times	or/or.h	/^  int total_build_times;$/;"	m	struct:__anon54
total_cell_waiting_time	or/or.h	/^  uint64_t total_cell_waiting_time;$/;"	m	struct:or_circuit_t
total_cells_allocated	or/relay.c	/^static int total_cells_allocated = 0;$/;"	v	file:
total_chunks_allocated	common/mempool.h	/^  uint64_t total_chunks_allocated;$/;"	m	struct:mp_pool_t
total_chunks_freed	common/mempool.h	/^  uint64_t total_chunks_freed;$/;"	m	struct:mp_pool_t
total_descriptor_downloads	or/rephist.c	/^static unsigned long total_descriptor_downloads;$/;"	v	file:
total_exit_bandwidth	or/dirserv.c	/^static uint64_t total_exit_bandwidth = 0;$/;"	v	file:
total_in_period	or/rephist.c	/^  uint64_t total_in_period; \/**< Total bytes transferred in the current$/;"	m	struct:bw_array_t	file:
total_items_allocated	common/mempool.h	/^  uint64_t total_items_allocated;$/;"	m	struct:mp_pool_t
total_len_seen	or/microdesc.c	/^  uint64_t total_len_seen;$/;"	m	struct:microdesc_cache_t	file:
total_obs	or/rephist.c	/^  uint64_t total_obs; \/**< Total for all members of obs except$/;"	m	struct:bw_array_t	file:
total_run_weights	or/rephist.c	/^  double total_run_weights;$/;"	m	struct:or_history_t	file:
total_weighted_time	or/rephist.c	/^  unsigned long total_weighted_time;$/;"	m	struct:or_history_t	file:
totals	or/rephist.c	/^  uint64_t totals[NUM_TOTALS];$/;"	m	struct:bw_array_t	file:
touch_file	common/compat.c	/^touch_file(const char *fname)$/;"	f
tp	or/routerparse.c	/^  directory_keyword tp;        \/**< Type of the token. *\/$/;"	m	struct:directory_token_t	file:
trans_id	or/eventdns.c	/^	u16 trans_id;  \/* the transaction id *\/$/;"	m	struct:evdns_request	file:
trans_id	or/eventdns.c	/^	u16 trans_id; \/* Transaction id. *\/$/;"	m	struct:server_request	file:
trans_id_from_random_bytes_fn	or/eventdns.c	/^trans_id_from_random_bytes_fn(void)$/;"	f	file:
trans_id_function	or/eventdns.c	/^static uint16_t (*trans_id_function)(void) = default_transaction_id_fn;$/;"	v	file:
transaction_id_pick	or/eventdns.c	/^transaction_id_pick(void) {$/;"	f	file:
transmit_me	or/eventdns.c	/^	char transmit_me;  \/* needs to be transmitted *\/$/;"	m	struct:evdns_request	file:
transport_add	or/circuitbuild.c	/^transport_add(transport_t *t)$/;"	f
transport_add_from_config	or/circuitbuild.c	/^transport_add_from_config(const tor_addr_t *addr, uint16_t port,$/;"	f
transport_free	or/circuitbuild.c	/^transport_free(transport_t *transport)$/;"	f
transport_get_by_name	or/circuitbuild.c	/^transport_get_by_name(const char *name)$/;"	f
transport_list	or/circuitbuild.c	/^static smartlist_t *transport_list = NULL;$/;"	v	file:
transport_name	or/circuitbuild.c	/^  char *transport_name;$/;"	m	struct:__anon19	file:
transport_new	or/circuitbuild.c	/^transport_new(const tor_addr_t *addr, uint16_t port,$/;"	f
transport_resolve_conflicts	or/circuitbuild.c	/^transport_resolve_conflicts(transport_t *t)$/;"	f	file:
transport_t	or/circuitbuild.h	/^} transport_t;$/;"	t	typeref:struct:__anon20
transports	or/transports.h	/^  smartlist_t *transports;$/;"	m	struct:__anon71
transports_to_launch	or/transports.h	/^  smartlist_t *transports_to_launch;$/;"	m	struct:__anon71
trusted_dir_certs	or/routerlist.c	/^static digestmap_t *trusted_dir_certs = NULL;$/;"	v	file:
trusted_dir_server_free	or/routerlist.c	/^trusted_dir_server_free(trusted_dir_server_t *ds)$/;"	f	file:
trusted_dir_server_t	or/or.h	/^typedef struct trusted_dir_server_t {$/;"	s
trusted_dir_server_t	or/or.h	/^} trusted_dir_server_t;$/;"	t	typeref:struct:trusted_dir_server_t
trusted_dir_servers	or/routerlist.c	/^static smartlist_t *trusted_dir_servers = NULL;$/;"	v	file:
trusted_dir_servers_certs_changed	or/routerlist.c	/^static int trusted_dir_servers_certs_changed = 0;$/;"	v	file:
trusted_dirs_flush_certs_to_disk	or/routerlist.c	/^trusted_dirs_flush_certs_to_disk(void)$/;"	f
trusted_dirs_load_certs_from_string	or/routerlist.c	/^trusted_dirs_load_certs_from_string(const char *contents, int from_store,$/;"	f
trusted_dirs_reload_certs	or/routerlist.c	/^trusted_dirs_reload_certs(void)$/;"	f
trusted_dirs_remove_old_certs	or/routerlist.c	/^trusted_dirs_remove_old_certs(void)$/;"	f	file:
trusteddirserver_get_by_v3_auth_digest	or/routerlist.c	/^trusteddirserver_get_by_v3_auth_digest(const char *digest)$/;"	f
try_load_engine	common/crypto.c	/^try_load_engine(const char *path, const char *engine)$/;"	f	file:
try_locking	or/main.c	/^try_locking(const or_options_t *options, int err_if_locked)$/;"	f
try_to_extract_certs_from_tls	common/tortls.c	/^try_to_extract_certs_from_tls(int severity, tor_tls_t *tls,$/;"	f	file:
tt_abort	test/tinytest_macros.h	/^#define tt_abort(/;"	d
tt_abort_msg	test/tinytest_macros.h	/^#define tt_abort_msg(/;"	d
tt_abort_perror	test/tinytest_macros.h	/^#define tt_abort_perror(/;"	d
tt_abort_printf	test/tinytest_macros.h	/^#define tt_abort_printf(/;"	d
tt_assert	test/tinytest_macros.h	/^#define tt_assert(/;"	d
tt_assert_msg	test/tinytest_macros.h	/^#define tt_assert_msg(/;"	d
tt_assert_op_type	test/tinytest_macros.h	/^#define tt_assert_op_type(/;"	d
tt_assert_test_fmt_type	test/tinytest_macros.h	/^#define tt_assert_test_fmt_type(/;"	d
tt_assert_test_type	test/tinytest_macros.h	/^#define tt_assert_test_type(/;"	d
tt_fail	test/tinytest_macros.h	/^#define tt_fail(/;"	d
tt_fail_msg	test/tinytest_macros.h	/^#define tt_fail_msg(/;"	d
tt_fail_perror	test/tinytest_macros.h	/^#define tt_fail_perror(/;"	d
tt_failprint_f	test/tinytest_macros.h	/^#define tt_failprint_f(/;"	d
tt_int_op	test/tinytest_macros.h	/^#define tt_int_op(/;"	d
tt_ptr_op	test/tinytest_macros.h	/^#define tt_ptr_op(/;"	d
tt_skip	test/tinytest_macros.h	/^#define tt_skip(/;"	d
tt_str_op	test/tinytest_macros.h	/^#define tt_str_op(/;"	d
tt_uint_op	test/tinytest_macros.h	/^#define tt_uint_op(/;"	d
tt_versionstatus_op	test/test_dir.c	/^#define tt_versionstatus_op(/;"	d	file:
tt_want	test/tinytest_macros.h	/^#define tt_want(/;"	d
tt_want_	test/tinytest_macros.h	/^#define tt_want_(/;"	d
tt_want_int_op	test/tinytest_macros.h	/^#define tt_want_int_op(/;"	d
tt_want_msg	test/tinytest_macros.h	/^#define tt_want_msg(/;"	d
tt_want_ptr_op	test/tinytest_macros.h	/^#define tt_want_ptr_op(/;"	d
tt_want_str_op	test/tinytest_macros.h	/^#define tt_want_str_op(/;"	d
tt_want_uint_op	test/tinytest_macros.h	/^#define tt_want_uint_op(/;"	d
ttl	or/dns.c	/^  uint32_t ttl; \/**< What TTL did the nameserver tell us? *\/$/;"	m	struct:cached_resolve_t	file:
ttl	or/eventdns.c	/^	u32 ttl; \/* The RR TTL *\/$/;"	m	struct:server_reply_item	file:
tv	common/compat_libevent.c	/^  struct timeval tv;$/;"	m	struct:periodic_timer_t	typeref:struct:periodic_timer_t::timeval	file:
tv_mdiff	common/util.c	/^tv_mdiff(const struct timeval *start, const struct timeval *end)$/;"	f
tv_sec	common/compat.h	/^  time_t tv_sec;$/;"	m	struct:timeval
tv_start	test/bench.c	/^static struct timeval tv_start = { 0, 0 };$/;"	v	typeref:struct:timeval	file:
tv_to_double	common/util.c	/^tv_to_double(const struct timeval *tv)$/;"	f
tv_to_msec	common/util.c	/^tv_to_msec(const struct timeval *tv)$/;"	f
tv_to_usec	common/util.c	/^tv_to_usec(const struct timeval *tv)$/;"	f
tv_udiff	common/util.c	/^tv_udiff(const struct timeval *start, const struct timeval *end)$/;"	f
tv_usec	common/compat.h	/^  unsigned int tv_usec;$/;"	m	struct:timeval
tx_count	or/eventdns.c	/^	int tx_count;  \/* the number of times that this packet has been sent *\/$/;"	m	struct:evdns_request	file:
type	or/config.c	/^  config_type_t type; \/**< How to interpret the type and turn it into a$/;"	m	struct:config_var_t	file:
type	or/eventdns.c	/^	u16 type : 16; \/* The RR type *\/$/;"	m	struct:server_reply_item	file:
type	or/eventdns.c	/^	unsigned int type;$/;"	m	struct:reply	file:
type	or/eventdns.h	/^	int type;$/;"	m	struct:evdns_server_question
type	or/geoip.c	/^  unsigned int type:1; \/**< Is this a direct or a tunneled request? *\/$/;"	m	struct:dirreq_map_entry_t	file:
type	or/or.h	/^  dirinfo_type_t type;$/;"	m	struct:trusted_dir_server_t
type	or/or.h	/^  networkstatus_type_t type : 8; \/**< Vote, consensus, or opinion? *\/$/;"	m	struct:networkstatus_t
type	or/or.h	/^  store_type_t type; \/**< What's stored in this store? *\/$/;"	m	struct:desc_store_t
type	or/or.h	/^  uint8_t type; \/**< One of CONN_TYPE_*_LISTENER *\/$/;"	m	struct:port_cfg_t
type	or/or.h	/^  unsigned int type:4; \/**< What kind of connection is this? *\/$/;"	m	struct:connection_t
u	common/memarea.c	/^  } u;$/;"	m	struct:memarea_chunk_t	typeref:union:memarea_chunk_t::__anon12	file:
u	common/mempool.c	/^  } u;$/;"	m	struct:mp_allocated_t	typeref:union:mp_allocated_t::__anon13	file:
u16	or/eventdns.c	/^#define u16 /;"	d	file:
u32	or/eventdns.c	/^#define u32 /;"	d	file:
u64	or/eventdns.c	/^#define u64 /;"	d	file:
u6_addr16	common/compat.h	/^    uint16_t u6_addr16[8];$/;"	m	union:in6_addr::__anon6
u6_addr32	common/compat.h	/^    uint32_t u6_addr32[4];$/;"	m	union:in6_addr::__anon6
u6_addr8	common/compat.h	/^    uint8_t u6_addr8[16];$/;"	m	union:in6_addr::__anon6
u8	or/eventdns.c	/^#define u8	/;"	d	file:
u_char	or/eventdns_tor.h	/^typedef unsigned char u_char;$/;"	t
uint	or/eventdns_tor.h	/^typedef unsigned int uint;$/;"	t
uint16_t	common/torint.h	/^typedef unsigned int uint16_t;$/;"	t
uint16_t	common/torint.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	common/torint.h	/^typedef unsigned int uint32_t;$/;"	t
uint32_t	common/torint.h	/^typedef unsigned long uint32_t;$/;"	t
uint64_t	common/torint.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint64_t	common/torint.h	/^typedef unsigned long long uint64_t;$/;"	t
uint64_t	common/torint.h	/^typedef unsigned long uint64_t;$/;"	t
uint8_t	common/torint.h	/^typedef unsigned char uint8_t;$/;"	t
uintptr_t	common/torint.h	/^typedef uint32_t uintptr_t;$/;"	t
uintptr_t	common/torint.h	/^typedef uint64_t uintptr_t;$/;"	t
uname_result	common/compat.c	/^static char uname_result[256];$/;"	v	file:
uname_result_is_set	common/compat.c	/^static int uname_result_is_set = 0;$/;"	v	file:
unconfigured_proxies_n	or/transports.c	/^static int unconfigured_proxies_n = 0;$/;"	v	file:
unescape_string	common/util.c	/^unescape_string(const char *s, char **result, size_t *size_out)$/;"	f	file:
unit	or/config.c	/^  const char *unit; \/**< The name of the unit *\/$/;"	m	struct:unit_table_t	file:
unit_table_t	or/config.c	/^struct unit_table_t {$/;"	s	file:
unit_tests	or/circuitbuild.c	/^static int unit_tests = 0;$/;"	v	file:
unix_addr	or/or.h	/^  char unix_addr[FLEXIBLE_ARRAY_MEMBER];$/;"	m	struct:port_cfg_t
unixoid_environment_block	common/util.h	/^  char **unixoid_environment_block;$/;"	m	struct:process_environment_t
unnamed_server_map	or/networkstatus.c	/^static strmap_t *unnamed_server_map = NULL;$/;"	v	file:
unreachable_count	or/or.h	/^  unsigned int unreachable_count : 3;$/;"	m	struct:rend_intro_point_t
unreachable_since	or/circuitbuild.c	/^  time_t unreachable_since; \/**< 0 if we can connect to this guard, or the$/;"	m	struct:__anon18	file:
up_since	or/rephist.c	/^  time_t up_since;$/;"	m	struct:or_history_t	file:
update_all_descriptor_downloads	or/routerlist.c	/^update_all_descriptor_downloads(time_t now)$/;"	f
update_approx_time	common/util.c	/^update_approx_time(time_t now)$/;"	f
update_approx_time	common/util.h	/^#define update_approx_time(/;"	d
update_certificate_downloads	or/networkstatus.c	/^update_certificate_downloads(time_t now)$/;"	f
update_consensus_networkstatus_downloads	or/networkstatus.c	/^update_consensus_networkstatus_downloads(time_t now)$/;"	f	file:
update_consensus_networkstatus_fetch_time	or/networkstatus.c	/^update_consensus_networkstatus_fetch_time(time_t now)$/;"	f
update_consensus_networkstatus_fetch_time_impl	or/networkstatus.c	/^update_consensus_networkstatus_fetch_time_impl(time_t now, int flav)$/;"	f	file:
update_consensus_router_descriptor_downloads	or/routerlist.c	/^update_consensus_router_descriptor_downloads(time_t now, int is_vote,$/;"	f
update_expected_bandwidth	or/hibernate.c	/^update_expected_bandwidth(void)$/;"	f	file:
update_extrainfo_downloads	or/routerlist.c	/^update_extrainfo_downloads(time_t now)$/;"	f
update_microdesc_downloads	or/microdesc.c	/^update_microdesc_downloads(time_t now)$/;"	f
update_microdescs_from_networkstatus	or/microdesc.c	/^update_microdescs_from_networkstatus(time_t now)$/;"	f
update_networkstatus_downloads	or/networkstatus.c	/^update_networkstatus_downloads(time_t now)$/;"	f
update_or_history	or/rephist.c	/^update_or_history(or_history_t *hist, time_t when)$/;"	f	file:
update_router_descriptor_cache_downloads_v2	or/routerlist.c	/^update_router_descriptor_cache_downloads_v2(time_t now)$/;"	f	file:
update_router_descriptor_downloads	or/routerlist.c	/^update_router_descriptor_downloads(time_t now)$/;"	f
update_router_have_minimum_dir_info	or/routerlist.c	/^update_router_have_minimum_dir_info(void)$/;"	f	file:
update_v2_networkstatus_cache_downloads	or/networkstatus.c	/^update_v2_networkstatus_cache_downloads(time_t now)$/;"	f	file:
upload_service_descriptor	or/rendservice.c	/^upload_service_descriptor(rend_service_t *service)$/;"	f	file:
upnp_status	tools/tor-fw-helper/tor-fw-helper.h	/^  int upnp_status;$/;"	m	struct:__anon72
uptime	or/or.h	/^  long uptime; \/**< How many seconds the router claims to have been up *\/$/;"	m	struct:__anon41
uptime	or/rephist.c	/^  unsigned long uptime;$/;"	m	struct:or_history_t	file:
urls	tools/tor-fw-helper/tor-fw-helper-upnp.h	/^  struct UPNPUrls urls;$/;"	m	struct:miniupnpc_state_t	typeref:struct:miniupnpc_state_t::UPNPUrls
usable_consensus_flavor	or/microdesc.c	/^usable_consensus_flavor(void)$/;"	f
usage	test/tinytest.c	/^usage(struct testgroup_t *groups, int list_groups)$/;"	f	file:
usage	tools/tor-fw-helper/tor-fw-helper.c	/^usage(void)$/;"	f	file:
usage	tools/tor-resolve.c	/^usage(void)$/;"	f	file:
use_begindir	or/or.h	/^  unsigned int use_begindir:1;$/;"	m	struct:entry_connection_t
use_unsafe_renegotiation_flag	common/tortls.c	/^static int use_unsafe_renegotiation_flag = 0;$/;"	v	file:
use_unsafe_renegotiation_op	common/tortls.c	/^static int use_unsafe_renegotiation_op = 0;$/;"	v	file:
used_chunks	common/mempool.h	/^  struct mp_chunk_t *used_chunks;$/;"	m	struct:mp_pool_t	typeref:struct:mp_pool_t::mp_chunk_t
user_callback	or/eventdns.c	/^	evdns_callback_type user_callback;$/;"	m	struct:evdns_request	file:
user_callback	or/eventdns.c	/^	evdns_request_callback_fn_type user_callback; \/* Fn to handle requests *\/$/;"	m	struct:evdns_server_port	file:
user_data	or/eventdns.c	/^	void *user_data; \/* Opaque pointer passed to user_callback *\/$/;"	m	struct:evdns_server_port	file:
user_pointer	or/eventdns.c	/^	void *user_pointer;	 \/* the pointer given to us for this request *\/$/;"	m	struct:evdns_request	file:
username	or/or.h	/^  char *username;$/;"	m	struct:socks_request_t
usernamelen	or/or.h	/^  size_t usernamelen;$/;"	m	struct:socks_request_t
using_evp	common/aes.c	/^  uint8_t using_evp;$/;"	m	struct:aes_cnt_cipher	file:
using_iocp_bufferevents	common/compat_libevent.c	/^static int using_iocp_bufferevents = 0;$/;"	v	file:
ut	common/OpenBSD_malloc_Linux.c	/^struct ut {$/;"	s	file:
util_tests	test/test_util.c	/^struct testcase_t util_tests[] = {$/;"	v	typeref:struct:testcase_t
v	or/dirvote.c	/^  networkstatus_t *v;$/;"	m	struct:dir_src_ent_t	file:
v	or/eventdns.c	/^struct dnslabel_entry { char *v; off_t pos; };$/;"	m	struct:dnslabel_entry	file:
v	or/routerparse.c	/^  directory_keyword v;$/;"	m	struct:token_rule_t	file:
v2_download_status_map	or/networkstatus.c	/^static digestmap_t *v2_download_status_map = NULL;$/;"	v	file:
v2_networkstatus_source_t	or/or.h	/^} v2_networkstatus_source_t;$/;"	t	typeref:enum:__anon63
v2_ns_dl_status	or/or.h	/^  download_status_t v2_ns_dl_status; \/**< Status of downloading this server's$/;"	m	struct:trusted_dir_server_t
v2_share_times_seconds	or/geoip.c	/^static double v2_share_times_seconds;$/;"	v	file:
v3_authority_check_key_expiry	or/router.c	/^v3_authority_check_key_expiry(void)$/;"	f
v3_identity_digest	or/or.h	/^  char v3_identity_digest[DIGEST_LEN]; \/**< Digest of v3 (authority only,$/;"	m	struct:trusted_dir_server_t
v3_share_times_seconds	or/geoip.c	/^static double v3_share_times_seconds;$/;"	v	file:
val	test/test_containers.c	/^  const char *val;$/;"	m	struct:pq_entry_t	file:
valid_after	or/or.h	/^  time_t valid_after; \/**< Time after which this vote or consensus applies. *\/$/;"	m	struct:networkstatus_t
valid_after	or/or.h	/^  time_t valid_after;$/;"	m	struct:ns_detached_signatures_t
valid_until	or/or.h	/^  time_t valid_until; \/**< Time after which this vote or consensus should not$/;"	m	struct:networkstatus_t
valid_until	or/or.h	/^  time_t valid_until;$/;"	m	struct:ns_detached_signatures_t
validate_addr_policies	or/policies.c	/^validate_addr_policies(const or_options_t *options, char **msg)$/;"	f
validate_bridge_stats	or/geoip.c	/^validate_bridge_stats(const char *stats_str, time_t now)$/;"	f	file:
validate_data_directory	or/config.c	/^validate_data_directory(or_options_t *options)$/;"	f	file:
validate_dir_authorities	or/config.c	/^validate_dir_authorities(or_options_t *options, or_options_t *old_options)$/;"	f	file:
validate_fn	or/config.c	/^  validate_fn_t validate_fn; \/**< Function to validate config. *\/$/;"	m	struct:__anon21	file:
validate_fn_t	or/config.c	/^typedef int (*validate_fn_t)(void*,void*,int,char**);$/;"	t	file:
validate_pluggable_transports_config	or/circuitbuild.c	/^validate_pluggable_transports_config(void)$/;"	f
validate_ports_csv	or/config.c	/^validate_ports_csv(smartlist_t *sl, const char *name, char **msg)$/;"	f	file:
validate_transports_in_state	or/config.c	/^validate_transports_in_state(or_state_t *state)$/;"	f	file:
valloc	common/OpenBSD_malloc_Linux.c	/^void *valloc(size_t size)$/;"	f
value	or/or.h	/^  char *value;$/;"	m	struct:config_line_t
var_cell_free	or/connection_or.c	/^var_cell_free(var_cell_t *cell)$/;"	f
var_cell_new	or/connection_or.c	/^var_cell_new(uint16_t payload_len)$/;"	f
var_cell_pack_header	or/connection_or.c	/^var_cell_pack_header(const var_cell_t *cell, char *hdr_out)$/;"	f
var_cell_t	or/or.h	/^typedef struct var_cell_t {$/;"	s
var_cell_t	or/or.h	/^} var_cell_t;$/;"	t	typeref:struct:var_cell_t
var_offset	or/config.c	/^  off_t var_offset; \/**< Offset of the corresponding member of or_options_t. *\/$/;"	m	struct:config_var_t	file:
varname	or/control.c	/^  const char *varname; \/**< The value (or prefix) of the question. *\/$/;"	m	struct:getinfo_item_t	file:
vars	or/config.c	/^  config_var_t *vars; \/**< List of variables we recognize, their default$/;"	m	struct:__anon21	file:
verbose	tools/tor-fw-helper/tor-fw-helper.h	/^  int verbose;$/;"	m	struct:__anon72
verbose	tools/tor-gencert.c	/^int verbose = 0;$/;"	v
verbosity_flag	test/tinytest.c	/^const char *verbosity_flag = "";$/;"	v
verified_digests	or/routerparse.c	/^static digestmap_t *verified_digests = NULL;$/;"	v	file:
version	or/or.h	/^  char *version; \/**< The version that the authority says this router is$/;"	m	struct:vote_routerstatus_t
version	or/or.h	/^  int version; \/**< Version of the descriptor format: 0 or 2. *\/$/;"	m	struct:rend_service_descriptor_t
version_from_platform	or/dirserv.c	/^version_from_platform(const char *platform)$/;"	f	file:
version_known	or/or.h	/^  unsigned int version_known:1;$/;"	m	struct:routerstatus_t
version_status_t	or/or.h	/^typedef enum version_status_t {$/;"	g
version_status_t	or/or.h	/^} version_status_t;$/;"	t	typeref:enum:version_status_t
version_supports_begindir	or/or.h	/^  unsigned int version_supports_begindir:1;$/;"	m	struct:routerstatus_t
version_supports_conditional_consensus	or/or.h	/^  unsigned int version_supports_conditional_consensus:1;$/;"	m	struct:routerstatus_t
version_supports_extrainfo_upload	or/or.h	/^  unsigned int version_supports_extrainfo_upload:1;$/;"	m	struct:routerstatus_t
version_supports_microdesc_cache	or/or.h	/^  unsigned int version_supports_microdesc_cache:1;$/;"	m	struct:routerstatus_t
version_supports_optimistic_data	or/or.h	/^  unsigned int version_supports_optimistic_data:1;$/;"	m	struct:routerstatus_t
version_supports_v3_dir	or/or.h	/^  unsigned int version_supports_v3_dir:1;$/;"	m	struct:routerstatus_t
virtaddress_entry_t	or/connection_edge.c	/^} virtaddress_entry_t;$/;"	t	typeref:struct:__anon23	file:
virtaddress_reversemap	or/connection_edge.c	/^static strmap_t *virtaddress_reversemap=NULL;$/;"	v	file:
virtual_addr_netmask_bits	or/connection_edge.c	/^static maskbits_t virtual_addr_netmask_bits = 10;$/;"	v	file:
virtual_addr_network	or/connection_edge.c	/^static uint32_t virtual_addr_network = 0x7fc00000u;$/;"	v	file:
virtual_port	or/rendservice.c	/^  uint16_t virtual_port;$/;"	m	struct:rend_service_port_config_t	file:
vote	or/dirvote.c	/^  networkstatus_t *vote;$/;"	m	struct:pending_vote_t	file:
vote_body	or/dirvote.c	/^  cached_dir_t *vote_body;$/;"	m	struct:pending_vote_t	file:
vote_delay	or/or.h	/^  int vote_delay;$/;"	m	struct:vote_timing_t
vote_digest	or/or.h	/^  char vote_digest[DIGEST_LEN]; \/**< Digest of this voter's vote, as signed. *\/$/;"	m	struct:networkstatus_voter_info_t
vote_interval	or/or.h	/^  int vote_interval;$/;"	m	struct:vote_timing_t
vote_microdesc_hash_t	or/or.h	/^typedef struct vote_microdesc_hash_t {$/;"	s
vote_microdesc_hash_t	or/or.h	/^} vote_microdesc_hash_t;$/;"	t	typeref:struct:vote_microdesc_hash_t
vote_routerstatus_find_microdesc_hash	or/dirvote.c	/^vote_routerstatus_find_microdesc_hash(char *digest256_out,$/;"	f
vote_routerstatus_free	or/networkstatus.c	/^vote_routerstatus_free(vote_routerstatus_t *rs)$/;"	f	file:
vote_routerstatus_t	or/or.h	/^typedef struct vote_routerstatus_t {$/;"	s
vote_routerstatus_t	or/or.h	/^} vote_routerstatus_t;$/;"	t	typeref:struct:vote_routerstatus_t
vote_seconds	or/or.h	/^  int vote_seconds;$/;"	m	struct:networkstatus_t
vote_timing_t	or/or.h	/^typedef struct vote_timing_t {$/;"	s
vote_timing_t	or/or.h	/^} vote_timing_t;$/;"	t	typeref:struct:vote_timing_t
voter_get_sig_by_algorithm	or/dirvote.c	/^voter_get_sig_by_algorithm(const networkstatus_voter_info_t *voter,$/;"	f
voters	or/or.h	/^  smartlist_t *voters;$/;"	m	struct:networkstatus_t
voting_ends	or/dirvote.c	/^  time_t voting_ends;$/;"	m	struct:__anon25	file:
voting_schedule	or/dirvote.c	/^} voting_schedule = {0,0,0,0,0,0,0,0,0,0};$/;"	v	typeref:struct:__anon25	file:
voting_starts	or/dirvote.c	/^  time_t voting_starts;$/;"	m	struct:__anon25	file:
wait_until_fd_readable	tools/tor-fw-helper/tor-fw-helper-natpmp.c	/^wait_until_fd_readable(tor_socket_t fd, struct timeval *timeout)$/;"	f	file:
want_onehop	or/or.h	/^  unsigned int want_onehop:1;$/;"	m	struct:entry_connection_t
wants_to_be_hs_dir	or/or.h	/^  unsigned int wants_to_be_hs_dir:1; \/**< True iff this router claims to be$/;"	m	struct:__anon41
wantwrite_n	common/tortls.c	/^  size_t wantwrite_n; \/**< 0 normally, >0 if we returned wantwrite last$/;"	m	struct:tor_tls_t	file:
warn	or/config.c	/^  int warn;$/;"	m	struct:config_abbrev_t	file:
warn_if_last_router_excluded	or/circuitbuild.c	/^warn_if_last_router_excluded(origin_circuit_t *circ, const extend_info_t *exit)$/;"	f	file:
warn_nonlocal_client_ports	or/config.c	/^warn_nonlocal_client_ports(const smartlist_t *ports, const char *portname)$/;"	f	file:
warn_nonlocal_controller_ports	or/config.c	/^warn_nonlocal_controller_ports(smartlist_t *ports, unsigned forbid)$/;"	f	file:
warn_too_many_conns	or/connection.c	/^warn_too_many_conns(void)$/;"	f	file:
warned_nicknames	or/routerlist.c	/^static smartlist_t *warned_nicknames = NULL;$/;"	v	file:
warned_nonexistent_family	or/router.c	/^static smartlist_t *warned_nonexistent_family = NULL;$/;"	v	file:
wasV2Handshake	common/tortls.c	/^  unsigned int wasV2Handshake:1; \/**< True iff the original handshake for$/;"	m	struct:tor_tls_t	file:
was_router_added_t	or/or.h	/^typedef enum was_router_added_t {$/;"	g
was_router_added_t	or/or.h	/^} was_router_added_t;$/;"	t	typeref:enum:was_router_added_t
watchable_events	or/main.h	/^typedef enum watchable_events {$/;"	g
watchable_events_t	or/main.h	/^} watchable_events_t;$/;"	t	typeref:enum:watchable_events
we_are_hibernating	or/hibernate.c	/^we_are_hibernating(void)$/;"	f
we_fetch_microdescriptors	or/microdesc.c	/^we_fetch_microdescriptors(const or_options_t *options)$/;"	f
we_fetch_router_descriptors	or/microdesc.c	/^we_fetch_router_descriptors(const or_options_t *options)$/;"	f
we_use_microdescriptors_for_circuits	or/microdesc.c	/^we_use_microdescriptors_for_circuits(const or_options_t *options)$/;"	f
we_want_to_fetch_flavor	or/networkstatus.c	/^we_want_to_fetch_flavor(const or_options_t *options, int flavor)$/;"	f	file:
weight_params	or/or.h	/^  smartlist_t *weight_params;$/;"	m	struct:networkstatus_t
weighted_run_length	or/rephist.c	/^  unsigned long weighted_run_length;$/;"	m	struct:or_history_t	file:
weighted_uptime	or/rephist.c	/^  unsigned long weighted_uptime;$/;"	m	struct:or_history_t	file:
when_added	or/onion.c	/^  time_t when_added;$/;"	m	struct:onion_queue_t	file:
wildcard_increment_answer	or/dns.c	/^wildcard_increment_answer(const char *id)$/;"	f	file:
windows_environment_block	common/util.h	/^  char *windows_environment_block;$/;"	m	struct:process_environment_t
windows_socket_errors	common/compat.c	/^struct { int code; const char *msg; } windows_socket_errors[] = {$/;"	v	typeref:struct:__anon5
wrap_string	common/util.c	/^wrap_string(smartlist_t *out, const char *string, size_t width,$/;"	f
write_all	common/util.c	/^write_all(tor_socket_t fd, const char *buf, size_t count, int isSocket)$/;"	f
write_array	or/rephist.c	/^static bw_array_t *write_array = NULL;$/;"	v	file:
write_blocked_on_bw	or/or.h	/^  unsigned int write_blocked_on_bw:1; \/**< Boolean: should we start writing$/;"	m	struct:connection_t
write_bucket	or/or.h	/^  int write_bucket; \/**< When this hits 0, stop writing. Like read_bucket. *\/$/;"	m	struct:or_connection_t
write_buckets_empty_last_second	or/connection.c	/^static int write_buckets_empty_last_second = 0;$/;"	v	file:
write_bytes_to_file	common/util.c	/^write_bytes_to_file(const char *fname, const char *str, size_t len,$/;"	f
write_bytes_to_file_impl	common/util.c	/^write_bytes_to_file_impl(const char *fname, const char *str, size_t len,$/;"	f	file:
write_bytes_to_new_file	common/util.c	/^write_bytes_to_new_file(const char *fname, const char *str, size_t len,$/;"	f
write_chunks_to_file	common/util.c	/^write_chunks_to_file(const char *fname, const smartlist_t *chunks, int bin)$/;"	f
write_chunks_to_file_impl	common/util.c	/^write_chunks_to_file_impl(const char *fname, const smartlist_t *chunks,$/;"	f	file:
write_configuration_file	or/config.c	/^write_configuration_file(const char *fname, const or_options_t *options)$/;"	f	file:
write_escaped_data	or/control.c	/^write_escaped_data(const char *data, size_t len, char **out)$/;"	f
write_event	or/or.h	/^  struct event *write_event; \/**< Libevent event structure. *\/$/;"	m	struct:connection_t	typeref:struct:connection_t::event
write_http_response_header	or/directory.c	/^write_http_response_header(dir_connection_t *conn, ssize_t length,$/;"	f	file:
write_http_response_header_impl	or/directory.c	/^write_http_response_header_impl(dir_connection_t *conn, ssize_t length,$/;"	f	file:
write_http_status_line	or/directory.c	/^write_http_status_line(dir_connection_t *conn, int status,$/;"	f	file:
write_pidfile	common/util.c	/^write_pidfile(char *filename)$/;"	f
write_str_to_file	common/util.c	/^write_str_to_file(const char *fname, const char *str, int bin)$/;"	f
write_stream_target_to_buf	or/control.c	/^write_stream_target_to_buf(entry_connection_t *conn, char *buf, size_t len)$/;"	f	file:
write_to_buf	or/buffers.c	/^write_to_buf(const char *string, size_t string_len, buf_t *buf)$/;"	f
write_to_buf_zlib	or/buffers.c	/^write_to_buf_zlib(buf_t *buf, tor_zlib_state_t *state,$/;"	f
write_to_evbuffer_zlib	or/buffers.c	/^write_to_evbuffer_zlib(struct evbuffer *buf, tor_zlib_state_t *state,$/;"	f
write_waiting	or/eventdns.c	/^	char write_waiting;	 \/* true if we are waiting for EV_WRITE events *\/$/;"	m	struct:nameserver	file:
writing_to_linked_conn	or/or.h	/^  unsigned int writing_to_linked_conn:1;$/;"	m	struct:connection_t
written	or/rephist.c	/^  size_t written; \/**< Number of written bytes *\/$/;"	m	struct:bidi_map_entry_t	file:
wrterror	common/OpenBSD_malloc_Linux.c	/^wrterror(const char *p)$/;"	f	file:
wrtwarning	common/OpenBSD_malloc_Linux.c	/^wrtwarning(const char *p)$/;"	f	file:
zlib_state	or/or.h	/^  tor_zlib_state_t *zlib_state;$/;"	m	struct:dir_connection_t
